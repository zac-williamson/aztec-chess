{"noir_version":"1.0.0-beta.15+1a930357477fc0c210dc5a8960680282d4cfa24e","name":"HatNFT","functions":[{"name":"__aztec_nr_internals__constructor","hash":"13142259429103564531","is_unconstrained":true,"custom_attributes":["abi_public","abi_initializer"],"abi":{"parameters":[{"name":"chess_contract","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":null,"error_types":{"772947778646992575":{"error_kind":"string","string":"Minter cannot be zero address"},"9967937311635654895":{"error_kind":"string","string":"Initialization hash does not match"},"14415304921900233953":{"error_kind":"string","string":"Initializer address is not the contract deployer"},"14990209321349310352":{"error_kind":"string","string":"attempt to add with overflow"},"15764276373176857197":{"error_kind":"string","string":"Stack too deep"},"16431471497789672479":{"error_kind":"string","string":"Index out of bounds"}}},"bytecode":"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","debug_symbols":"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","expression_width":{"Bounded":{"width":4}}},{"name":"__aztec_nr_internals__exists","hash":"7733706805200688586","is_unconstrained":true,"custom_attributes":["abi_utility"],"abi":{"parameters":[{"name":"token_id","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"private"}],"return_type":{"abi_type":{"kind":"boolean"},"visibility":"public"},"error_types":{"361444214588792908":{"error_kind":"string","string":"attempt to multiply with overflow"},"992401946138144806":{"error_kind":"string","string":"Attempted to read past end of BoundedVec"},"1998584279744703196":{"error_kind":"string","string":"attempt to subtract with overflow"},"3080037330898348111":{"error_kind":"fmtstring","length":132,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"4261968856572588300":{"error_kind":"string","string":"Value does not fit in field"},"4440399188109668273":{"error_kind":"string","string":"Input length must be a multiple of 32"},"6504742485148360234":{"error_kind":"fmtstring","length":40,"item_types":[]},"7564993426627941149":{"error_kind":"fmtstring","length":48,"item_types":[{"kind":"field"},{"kind":"field"}]},"7995966536718645961":{"error_kind":"fmtstring","length":61,"item_types":[{"kind":"field"},{"kind":"field"}]},"9791669845391776238":{"error_kind":"string","string":"0 has a square root; you cannot claim it is not square"},"9885968605480832328":{"error_kind":"string","string":"Attempted to read past the length of a CapsuleArray"},"10791800398362570014":{"error_kind":"string","string":"extend_from_bounded_vec out of bounds"},"11021520179822076911":{"error_kind":"string","string":"Attempted to delete past the length of a CapsuleArray"},"12469291177396340830":{"error_kind":"string","string":"call to assert_max_bit_size"},"12913276134398371456":{"error_kind":"string","string":"push out of bounds"},"13060541637244024094":{"error_kind":"fmtstring","length":98,"item_types":[]},"13450089406971132036":{"error_kind":"fmtstring","length":144,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"13455385521185560676":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"14990209321349310352":{"error_kind":"string","string":"attempt to add with overflow"},"15764276373176857197":{"error_kind":"string","string":"Stack too deep"},"16431471497789672479":{"error_kind":"string","string":"Index out of bounds"},"16792019527863081935":{"error_kind":"fmtstring","length":77,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"17154023812102399658":{"error_kind":"fmtstring","length":128,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"17803644318014042523":{"error_kind":"fmtstring","length":58,"item_types":[{"kind":"field"}]}}},"bytecode":"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","debug_symbols":"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","expression_width":{"Bounded":{"width":4}}},{"name":"__aztec_nr_internals__get_hat_metadata","hash":"13806848228294372047","is_unconstrained":true,"custom_attributes":["abi_utility"],"abi":{"parameters":[{"name":"token_id","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"private"}],"return_type":{"abi_type":{"kind":"tuple","fields":[{"kind":"integer","sign":"unsigned","width":32},{"kind":"integer","sign":"unsigned","width":8},{"kind":"integer","sign":"unsigned","width":8}]},"visibility":"public"},"error_types":{"361444214588792908":{"error_kind":"string","string":"attempt to multiply with overflow"},"992401946138144806":{"error_kind":"string","string":"Attempted to read past end of BoundedVec"},"1998584279744703196":{"error_kind":"string","string":"attempt to subtract with overflow"},"3080037330898348111":{"error_kind":"fmtstring","length":132,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"4261968856572588300":{"error_kind":"string","string":"Value does not fit in field"},"4440399188109668273":{"error_kind":"string","string":"Input length must be a multiple of 32"},"6504742485148360234":{"error_kind":"fmtstring","length":40,"item_types":[]},"7564993426627941149":{"error_kind":"fmtstring","length":48,"item_types":[{"kind":"field"},{"kind":"field"}]},"7995966536718645961":{"error_kind":"fmtstring","length":61,"item_types":[{"kind":"field"},{"kind":"field"}]},"9791669845391776238":{"error_kind":"string","string":"0 has a square root; you cannot claim it is not square"},"9885968605480832328":{"error_kind":"string","string":"Attempted to read past the length of a CapsuleArray"},"10791800398362570014":{"error_kind":"string","string":"extend_from_bounded_vec out of bounds"},"10826617868182774729":{"error_kind":"string","string":"Token does not exist"},"11021520179822076911":{"error_kind":"string","string":"Attempted to delete past the length of a CapsuleArray"},"12469291177396340830":{"error_kind":"string","string":"call to assert_max_bit_size"},"12913276134398371456":{"error_kind":"string","string":"push out of bounds"},"13060541637244024094":{"error_kind":"fmtstring","length":98,"item_types":[]},"13450089406971132036":{"error_kind":"fmtstring","length":144,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"13455385521185560676":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"14990209321349310352":{"error_kind":"string","string":"attempt to add with overflow"},"15764276373176857197":{"error_kind":"string","string":"Stack too deep"},"16431471497789672479":{"error_kind":"string","string":"Index out of bounds"},"16792019527863081935":{"error_kind":"fmtstring","length":77,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"17154023812102399658":{"error_kind":"fmtstring","length":128,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"17803644318014042523":{"error_kind":"fmtstring","length":58,"item_types":[{"kind":"field"}]}}},"bytecode":"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","debug_symbols":"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mect87xlnrfM85Z53jLPW+Z5yzxvmect87xlnrfM85Z53jLPW+Z5yzxvmect87xlnrfM85Z53jLPW+Z5yzxvmect87xlnrfM85Z53jLPW+Z5yzxvmect87xlnrfM85Z53jLPW+Z5yzxvmect87xlnrfM85Z53jLPW+Z5yzxvmect87xlnrfM85Z53jLPW+Z5yzxvmect87xlnrfM85Z53jLPKfOcMs8p85wyzynznDLPKfOcMs8p85wyzynznDLPKfOcMs8p85wyzynznDLPKfOcMs8p85wyzynznDLPKfOcMs8p85wyzynznDLPKfOcMs8p85wyzynznDLPKfOcMs8p85wyzynznDLPKfOcMs8p85wyzynznDLPKfOcMs8p85wyzynznDLPKfOcMs8p85wyzynznDLPKfOcMs8p85wyzynznDLPKfOcMs8p85wyzynznDLPKfOcMs8p85wyzynznDLPKfOcMs8p85wyzynznDLPKfOcMs8p85wyzynznDLPKfOcMs8p85wyzynznDLPKfOcMs8p85wyz3vmec8875nnPfO8Z573zPOeed4zz3vmec8875nnPfO8Z573zPOeed4zz3vmec8875nnPfO8Z573zPOeed4zz3vmec8875nnPfO8Z573zPOeed4zz3vmec8875nnPfO8Z573zPOeed4zz3vmec8875nnPfO8Z573zPOeed4zz3vmec8875nnPfO8Z573zPOeed4zz3vmec8875nnPfO8Z573zPOeed4zz3vmec8875nnPfO8Z573zPOeed4zz3vmec8875nnPfO8Z573zPOeed4zz3vmec8875nnPfO8Z573zPOeee57lWRtsbakGXTluTanlkRJPWkkcZIkaZIlzZt849JNLYmSetJI4iRJ0iRLSo2WGi01Wmq01Gip0VKjpUZLjZYaLTUoNSg1KDUoNSg1KDUoNSg1KDUoNXpq9NToqdFTo6dGT42eGj01emr01BipMVJjpMZIjZEaIzVGaozUGKkxUoNTg1ODU4NTg1ODU4NTg1ODU4NTQ1JDUkNSQ1JDUkNSQ1JDUkNSQ1JDU0NTQ1NDU0NTQ1NDU0NTQ1NDU8NSw1LDUsNSw1LDUsNSw1LDUsNSI/N8ZJ6PzPOReT4yz31flHYnSdIkS5o3+eaom1oSJfWkkcRJkqRJlpQaLTVaarTUaKnR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","expression_width":{"Bounded":{"width":4}}},{"name":"__aztec_nr_internals__get_minter","hash":"84893582399312960","is_unconstrained":true,"custom_attributes":["abi_utility"],"abi":{"parameters":[],"return_type":{"abi_type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"public"},"error_types":{"361444214588792908":{"error_kind":"string","string":"attempt to multiply with overflow"},"992401946138144806":{"error_kind":"string","string":"Attempted to read past end of BoundedVec"},"1998584279744703196":{"error_kind":"string","string":"attempt to subtract with overflow"},"3080037330898348111":{"error_kind":"fmtstring","length":132,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"4261968856572588300":{"error_kind":"string","string":"Value does not fit in field"},"4440399188109668273":{"error_kind":"string","string":"Input length must be a multiple of 32"},"6504742485148360234":{"error_kind":"fmtstring","length":40,"item_types":[]},"7564993426627941149":{"error_kind":"fmtstring","length":48,"item_types":[{"kind":"field"},{"kind":"field"}]},"7995966536718645961":{"error_kind":"fmtstring","length":61,"item_types":[{"kind":"field"},{"kind":"field"}]},"9791669845391776238":{"error_kind":"string","string":"0 has a square root; you cannot claim it is not square"},"9885968605480832328":{"error_kind":"string","string":"Attempted to read past the length of a CapsuleArray"},"10791800398362570014":{"error_kind":"string","string":"extend_from_bounded_vec out of bounds"},"11021520179822076911":{"error_kind":"string","string":"Attempted to delete past the length of a CapsuleArray"},"12469291177396340830":{"error_kind":"string","string":"call to assert_max_bit_size"},"12913276134398371456":{"error_kind":"string","string":"push out of bounds"},"13060541637244024094":{"error_kind":"fmtstring","length":98,"item_types":[]},"13450089406971132036":{"error_kind":"fmtstring","length":144,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"14990209321349310352":{"error_kind":"string","string":"attempt to add with overflow"},"15764276373176857197":{"error_kind":"string","string":"Stack too deep"},"16431471497789672479":{"error_kind":"string","string":"Index out of bounds"},"16792019527863081935":{"error_kind":"fmtstring","length":77,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"17154023812102399658":{"error_kind":"fmtstring","length":128,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"17803644318014042523":{"error_kind":"fmtstring","length":58,"item_types":[{"kind":"field"}]}}},"bytecode":"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","debug_symbols":"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","expression_width":{"Bounded":{"width":4}}},{"name":"__aztec_nr_internals__mint_hat","hash":"8948484259777994177","is_unconstrained":true,"custom_attributes":["abi_public"],"abi":{"parameters":[{"name":"to","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"game_id","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"private"},{"name":"winner_elo","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"private"},{"name":"loser_elo","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"private"}],"return_type":null,"error_types":{"459713770342432051":{"error_kind":"string","string":"Not initialized"},"1998584279744703196":{"error_kind":"string","string":"attempt to subtract with overflow"},"5197614757850103533":{"error_kind":"string","string":"Only minter can mint"},"10837321964194770293":{"error_kind":"fmtstring","length":22,"item_types":[]},"13455385521185560676":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"14990209321349310352":{"error_kind":"string","string":"attempt to add with overflow"},"15764276373176857197":{"error_kind":"string","string":"Stack too deep"},"15978124792480278163":{"error_kind":"string","string":"Cannot mint to zero address"}}},"bytecode":"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","debug_symbols":"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","expression_width":{"Bounded":{"width":4}}},{"name":"__aztec_nr_internals__owner_of","hash":"8578877061079616269","is_unconstrained":true,"custom_attributes":["abi_utility"],"abi":{"parameters":[{"name":"token_id","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"private"}],"return_type":{"abi_type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"public"},"error_types":{"361444214588792908":{"error_kind":"string","string":"attempt to multiply with overflow"},"992401946138144806":{"error_kind":"string","string":"Attempted to read past end of BoundedVec"},"1998584279744703196":{"error_kind":"string","string":"attempt to subtract with overflow"},"3080037330898348111":{"error_kind":"fmtstring","length":132,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"4261968856572588300":{"error_kind":"string","string":"Value does not fit in field"},"4440399188109668273":{"error_kind":"string","string":"Input length must be a multiple of 32"},"6504742485148360234":{"error_kind":"fmtstring","length":40,"item_types":[]},"7564993426627941149":{"error_kind":"fmtstring","length":48,"item_types":[{"kind":"field"},{"kind":"field"}]},"7995966536718645961":{"error_kind":"fmtstring","length":61,"item_types":[{"kind":"field"},{"kind":"field"}]},"9791669845391776238":{"error_kind":"string","string":"0 has a square root; you cannot claim it is not square"},"9885968605480832328":{"error_kind":"string","string":"Attempted to read past the length of a CapsuleArray"},"10791800398362570014":{"error_kind":"string","string":"extend_from_bounded_vec out of bounds"},"10826617868182774729":{"error_kind":"string","string":"Token does not exist"},"11021520179822076911":{"error_kind":"string","string":"Attempted to delete past the length of a CapsuleArray"},"12469291177396340830":{"error_kind":"string","string":"call to assert_max_bit_size"},"12913276134398371456":{"error_kind":"string","string":"push out of bounds"},"13060541637244024094":{"error_kind":"fmtstring","length":98,"item_types":[]},"13450089406971132036":{"error_kind":"fmtstring","length":144,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"13455385521185560676":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"14990209321349310352":{"error_kind":"string","string":"attempt to add with overflow"},"15764276373176857197":{"error_kind":"string","string":"Stack too deep"},"16431471497789672479":{"error_kind":"string","string":"Index out of bounds"},"16792019527863081935":{"error_kind":"fmtstring","length":77,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"17154023812102399658":{"error_kind":"fmtstring","length":128,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"17803644318014042523":{"error_kind":"fmtstring","length":58,"item_types":[{"kind":"field"}]}}},"bytecode":"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","debug_symbols":"tb3djiQ7cqX7Ln2tizAj7Yd6lcFA6NH0DBpotAY90gEOBL37CTfSbLGyTjA9M3LfqD7trrLlTnJZ0Elz+n/+6X/+5X/8x//+l7/+/X/92//90z//t//80//4x1//9re//u9/+du//euf//2v//b353/9zz89rv/T7E//3P7pT83/9M/6/GP86Z/tn/7UH/MPmn/w/KPNP/r8Q+YfOv+w+YfPP2YUmVFkRpEZRWYUmVFkRpEZRWYUmVHkGWX805/0Mf+g+QfPP9r8o88/ZP6h8w+bf/j8Y0axGcVmFJtRbEaxGcVmFJtRbEaxGcVmFJ9RfEbxGcVnFJ9RfEbxGcVnFJ9RfEYZM8qYUcaMMmaUMaOMGWXMKGNGGTPKmFHo8Vh/0vqT159t/dnXn7L+1PWnrT99/bni0YpHKx6teLTi0YpHKx6teLTi0YpHKx6veLzi8YrHKx6veLzi8YrHKx6veLzitRWvrXhtxWsrXlvx2orXnvGILrAETxgLroFO/QJK4IRnWLILnnE5/rIkaIIleMJYcA1+lgsogRNawhVZL5AETbiu+bqLywwTxoLLEI0voAROaAk9QRI0wRI8YSywjGwZ2TKyZeTLLO1qn8suEzTBEjxhLLiMM4ESOKElZGTPyJ6RPSN7RvaMPDLyyMgjI4+MPDLyyMgjI4+MPDLyWJH58lfTCyiBE1pCT5AETbAETxgLKCNTRqaMTBmZMjJlZMrIlJEpI1NG5ozMGZkzMmdkzsickTkjc0bmjMwZuWXklpFbRm4ZuWXklpFbRm4ZuWXklpF7Ru4ZuWfknpF7Ru4ZuWfknpF7Ru4ZWTKyZGTJyJKRJSNLRpaMLBlZMrJkZM3ImpE1I2tG1oysGTk8OC6wBE8YC8KDAZTACS2hJ0hCRraMbBn58mB/OpcvD06ghGfkbhe0hJ4gCZpgCZ4wFlwenEAJGXlk5JGRx8pIPDTBEjxhZaT2eCRQAie0hJ4gCZpgCc/I8rhgLLg8OIESOKEl9ARJ0ARLyMiUkTkjc0a+PCh0QUvoCZKgCZbgCWPB5cEJlJCRW0ZuGfnyoPgFmmAJnjAWXB6cQAmc0BJ6QkbuGbln5J6Re0aWjCwZWTKyZGTJyJKRJSNLRpaMLBlZM7JmZM3ImpE1I2tG1oysGVkzsmZky8iWkS0jW0a2jGwZ2TKyZWTLyJaRPSN7RvaM7BnZM7JnZM/InpE9I3tGHhl5ZOSRkUdGHhl5ZOSRkUdGHhl5rMj98UigBE5oCT1BEjTBEjwhI1NGpoxMGZkyMmVkysiUkSkjU0amjMwZmTMyZ2TOyJyROSNzRuaMzBmZM3LLyC0jt4zcMnLLyOnBnh7s6cGeHuzpwZ4e7OnBnh7s6cGeHuzpwZ4e7OnBnh7s6cGeHuzpwZ4e7OnBnh7s6cGeHuzpwZ4e7OnBnh7s6cGeHuzpwZ4e7OnBnh7s6cGeHuzpwZ4e7OnBnh7s6cGeHuzpwZ4e7OnBnh7s6cGeHuzpwZ4e7OnBnh7s6cGeHuzpwZ4e7OnBnh7s6cGeHuzpwZ4e7OnBnh7s6cGeHuzpQUkPSnpQ0oOSHpT0oKQHJT0o6UFJD0p6UNKDkh6U9KCkByU9KOlBSQ9KelDSg5IelPSgpAclPSjpQUkPSnpQ0oOSHpT0oKQHJT0o6UFJD0p6UNKDkh6U9KCkByU9KOlBSQ9KelDSg5IelPSgpAclPSjpQUkPSnpQ0oOSHpT0oKQHJT0o6UFJD0p6UNKDkh6U9KCkByU9KOlBSQ9KelDSg5IelPSgpAclPSjpQUkPSnpQ0oOSHpT0oKQHJT0o6UFJD0p6UNKDkh6U9KCkByU9KOlBSQ9KelDSg5IelPSgpAclPSjpQUkPSnpQ0oOSHtT0oKYHNT2o6UFND2p6UNODmh7U9KCmBzU9qOlBTQ9qelDTg5oe1PSgpgc1PajpQU0PanpQ04OaHtT0oKYHNT2o6UFND2p6UNODmh7U9KCmBzU9qOlBTQ9qelDTg5oe1PSgpgc1PajpQU0PanpQ04OaHtT0oKYHNT2o6UFND2p6UNODmh7U9KCmBzU9qOlBTQ9qelDTg5oe1PSgpgc1PajpQU0PanpQ04OaHtT0oKYHNT2o6UFND2p6UNODmh7U9KCmBzU9qOlBTQ9qelDTg5oe1PSgpgc1PajpQU0PanpQ04OaHtT0oKYHNT2o6UFLD1p60NKDlh609KClBy09aOlBSw9aetDSg5YetPSgpQctPWjpQUsPWnrQ0oOWHrT0oKUHLT1o6UFLD1p60NKDlh609KClBy09aOlBSw9aetDSg5YetPSgpQctPWjpQUsPWnrQ0oOWHrT0oKUHLT1o6UFLD1p60NKDlh609KClBy09aOlBSw9aetDSg5YetPSgpQctPWjpQUsPWnrQ0oOWHrT0oKUHLT1o6UFLD1p60NKDlh609KClBy09aOlBSw9aetDSg5YetPSgpQctPWjpQUsPWnrQ0oOWHrT0oKUHLT1o6UFLD1p60NKDlh709KCnBz096OlBTw96etDTg54e9PSgpwc9PejpQU8PenrQ04OeHvT0oKcHPT3o6UFPD3p60NODnh709KCnBz096OlBTw96etDTg54e9PSgpwc9PejpQU8PenrQ04OeHvT0oKcHPT3o6UFPD3p60NODnh709KCnB/3yoNIFlMAJz8gqF/QESdAES/CEseDy4ARK4ISMrBlZM7JmZM3ImpE1I1tGtoxsGdkysmVky8iWkS0jW0a2jOwZ2TOyZ2TPyJ6RPSN7RvaM7BnZM/LIyCMjj4w8MvLIyCMjj4w8MvLIyGNFHo9HAiVwQkvoCZKgCZbgCRmZMjJlZMrIlJEpI1NGpoxMGZkyMmVkzsickTkjc0bmjMwZmTMyZ2TOyJyRW0ZuGbll5JaRW0ZuGbll5JaRW0ZuGbln5J6Re0buGbln5J6Re0buGbln5J6RJSNLRpaMnB4c6cGRHhzpwZEeHOnBkR4c6cGRHhzpwZEeHOnBkR4c6cGRHhzpwZEeHOnBkR4c6cGRHhzpwZEeHOnBkR4c6cGRHhzpwZEeHOnBkR4c6cGRHhzpwZEeHOnBkR4c6cGRHhzpwZEeHOnBkR4c6cGRHhzpwZEefO6/P4qoiItaUS+SIi2yIi8qDSoNKg0qDSoNKg0qDSoNKg0qDSoNLg0uDS4NLg0uDS4NLg0uDS4NLo1WGq00Wmm00mil0UqjlUYrjVYarTR6afTS6KXRS6OXRi+NXhq9NHpp9NKQ0pDSkNKQ0pDSkNKQ0pDSkNKQ0tDS0NLQ0tDS0NLQ0tDS0NLQ0tDSsNKw0rDSsNKw0rDSsNKw0rDSsNLw0vDS8NLw0vDS8NLw0vDS8NLw0hilMUpjlMYojVEaozRGaYzSGKVRPqfyOZXPqXxO5XMqn1P5nMrnVD6n8jmVz6l8TuVzKp9T+ZzK51Q+p/I5lc+pfE7lcyqfU/mcyudUPqfyOZXPqXxO5XMqn1P5nMrnVD6n8jmVz6l8TuVzKp9T+ZzK51Q+p/I5lc+pfE7lcyqfU/mcyudUPqfyOZXPqXxO5XMqn1P5nMrnVD6n8jmVz6l8TuVzKp9T+ZzK51Q+p/I5lc+pfE7lcyqfU/mcyudUPqfyOZXPqXxO5XMqn1P5nMrnVD6n8jmVz6l8TuVzKp9T+ZzK51Q+p/I5lc+pfE7lcyqfU/mcyudUPqfyOZXPqXxO5XMun3P5nMvnXD7n8jmXz7l8zuVzLp9z+ZzL51w+5/I5l8+5fM7lcy6fc/mcy+dcPufyOZfPuXzO5XMun3P5nMvnXD7n8jmXz7l8zuVzLp9z+ZzL51w+5/I5l8+5fM7lcy6fc/mcy+dcPufyOZfPuXzO5XMun3P5nMvnXD7n8jmXz7l8zuVzLp9z+ZzL51w+5/I5l8+5fM7lcy6fc/mcy+dcPufyOZfPuXzO5XMun3P5nMvnXD7n8jmXz7l8zuVzLp9z+ZzL51w+5/I5l8+5fM7lcy6fc/mcy+dcPufyOZfPuXzO5XMun3P5nMvnXD5v5fNWPm/l81Y+b+XzVj5v5fNWPm/l81Y+b+XzVj5v5fNWPm/l81Y+b+XzVj5v5fNWPm/l81Y+b+XzVj5v5fNWPm/l81Y+b+XzVj5v5fNWPm/l81Y+b+XzVj5v5fNWPm/l81Y+b+XzVj5v5fNWPm/l81Y+b+XzVj5v5fNWPm/l81Y+b+XzVj5v5fNWPm/l81Y+b+XzVj5v5fNWPm/l81Y+b+XzVj6PsiSdVctW5EVPDZulzI8iKuKiVtSLpEiLrMiLSsNLw0vDS8NLw0vDS8NLw0vDS8NLY5TGKI1RGqM0RmmM0hilMUpjlMZIjShcWkRFXNSKepEUaZEVeVFpUGlQaVBpUGlQaVBpUGlQaVBpUGlwaXBpcGlwaXBpcGlwaXBpcGlwabTSaKXRSqOVRiuNVhqtNFpptNJopdFLo5dGL41eGr00emn00uil0Uujl4aUhpSGlIaUhpSGlIaUhpSGlIaUhpaGloaWhpaGloaWhpaGloaWRvm8l897+byXz3v5PEqgrAVJkRZZkReNpPD5JCriolZUGl4aXhpeGl4aXhqjNEZpjNIYpTFKY5TGKI1RGqM0RmpEcdQiKuKiVtSLpEiLrMiLSoNKg0qDSoNKg0qDSoNKg0qDSoNKg0uDS4NLg0uDS4NLg0uDS4NLg0ujlUYrjVYarTRaabTSaKXRSqOVRiuNXhq9NHpp9NLopdFLo5dGL41eGr00pDSkNKQ0pDSkNKQ0pDSkNKQ0pDS0NLQ0tDS0NLQ0tDS0NLQ0tDS0NKw0rDSsNKw0yudSPpfyuZTPpXwu5XMpn0v5XMrnUj6X8rmUz6V8LuVzKZ9L+VzK51I+l/K5lM+lfC7lcymfS/lcyudSPtfyuZbPowTLPKgV9SIp0iIr8qKRFD6fREWlQaVBpUGlQaVBpUGlQaXBpcGlwaXBpcGlwaXBpXH53B9BXjSSLp8voiIuakW9SIq0qDRaabTSuHzuGkRFXNSKepEUaZEVedFIktK4fO4WxEWtqBdJkRZZkReNpMvni0pDS0NLQ0vj8rnHu3iXzxdZkReNpMvni6iIi1pRLyoNKw0rDSsNKw0vDS8NLw0vDS8NLw0vDS8NLw0vjVEaozRGaYzSGKUxSmOUxiiNURojNaLIazyCqIiLnhqDgnqRFD01Rrx6GK+5TvKikRQvu06iIi5qRb1IikqDSoNKg0qDS4NLg0uDS4NLg0uDS4NLg0uDS6OVRiuNVhqtNFpptNJopdFKo5VGK41eGr00emn00uil0Uujl0YvjV4avTSkNKQ0pDSkNKQ0pDSkNKQ0pDSkNLQ0tDS0NLQ0tDS0NLQ0tDS0NLQ0rDSsNKw0rDSsNKw0rDSsNKw0rDS8NLw0vDS8NLw0vDS8NLw0vDS8NEZpjNIYpTFKY5TGKI1RGqM0RmmM1IhCskVUxEWtqBdJkRZZkReVRvncy+dePvfyuZfPvXzu5XMvn3v53MvnXj738rmXz7187uVzL597+dzL514+9/K5l8+9fO7lcy+fe/ncy+dePvfyuZfPvXzu5XMvn3v53MvnXj738rmXz7187uVzL597+dzL514+9/K5l8+9fO7lcy+fe/ncy+dePvfyuZfPvXzu5XMvn3v53MvnXj738rmXz7187uVzL597+dzL51GUNizIirxoJIXPJ1ERF7WiXiRFpeGl4aURPr/e5o8StUVUxEWtqBdJkRZZkRelRhSrLaIiLmpFvUiKtMiKvKg0qDSoNKg0qDSoNKg0qDSoNKg0qDS4NLg0uDS4NLg0uDS4NLg0uDS4NFpptNJopdFKo5VGK41WGq00Wmm00uil0Uujl0YvjV4avTR6afTS6KXRS0NKQ0pDSkNKQ0pDSkNKQ0pDSkNKQ0tDS0NLQ0tDS0NLQ0tDS0NLQ0vDSsNKw0rDSsNKw0rDSsNKw0rDSsNLw0sjfD6CWlEvemrQ4xGoQAM6cBReZk8kIAMbsAOhNqA2oDagNlKNozwukYAMbMAOFKACDehAqBHUCGoENYIaQY2gRlAjqBHUCGoMNYYaQ42hxlBjqDHUGGoMNYZag1qDWoNag1qDWoNag1qDWoNag1qHWodah1qHWodaDzUOVKABQ00CR6E8gARkYAN2oAAVaECoCdQUago1hZpCTaGmUFOoKdQUago1g5pBzaBmUDOoGdQMagY1g5pBzaHmUHOoOdQcag41h5pDzaHmUBtQG1AbUBtQG1AbUBtQG1AbUBulRo8HkIAMbMAOFKACDehAqBHUCGoENYIaQY2gRlAjqBHUCGoMNYYaQ42hxlBjqDHUGGoMNYZag1qDWoNag1qDWoNag1qDWoNag1qHWodah1qHWodah1qHWocacgkhlxByCSGXEHIJIZcQcgkhlxByCSGXEHIJIZcQcgkhlxByCSGXEHIJIZcQcgkhlxByCSGXEHIJIZcQcgkhlxByCSGXEHIJIZcQcgkhlxByCSGXEHIJIZcQcgkhlxByCSGXEHIJIZcQcgkhlxByCSGXEHIJIZcQcgkhlxByCSGXMHIJI5cwcgkjlzByCSOXMHIJI5cwcgkjlzByCSOXMHIJI5cwcgkjlzByCSOXMHIJI5cwcgkjlzByCSOXMHIJI5cwcgkjlzByCSOXMHIJI5cwcgkjlzByCSOXMHIJI5cwcgkjlzByCSOXMHIJI5cwcgkjlzByCSOXMHIJI5cwcgkjlzByCSOXMHIJI5cwcgkjlzByCSOXMHIJI5cwcgkjlzByCSOXMHIJI5cwcgkjlzByCSOXMHIJI5cwcgkjlzByCSOXMHIJI5cwcgkjlzByCSOXMHIJI5cwcgkjlzByCSOXMHIJI5cwcgkjlzByCSOXMHIJI5cwcgkjlzTkkoZc0pBLGnJJQy5pyCUNuaQhlzTkkoZc0pBLGnJJQy5pM5d4YAcKUIEGdOAonLlkIgEZCDWGGkONocZQY6gx1BrUGtQa1BrUGtQa1BrUGtTmmZ8UOAojlyy81IgDGdiAHShABRrQgaMwcslCqAnUBGoCNYGaQE2gJlATqCnUFGoKNYWaQk2hplBTqCnUFGoGNYOaQc2gZlAzqBnUDGoGNYOaQ82h5lBzqDnUHGoONYeaQ82hNqA2oDagNqA2oDagNqA2oDagNkotyhUTCcjABuxAASrQgA6EGkGNoEZQI6gR1AhqkUuuo3I56hcTHRhq15mPUcKYSEAGNmAHClCBBnQg1BrUGtQa1BrUGtQa1BrUGtQa1BrUOtQ61DrUOtQ61DrUOtQ61DrUOtQEagI1gZpATaAmUBOoCdQEagI1hZpCTaGmUFOoKdQUago1hZpCzaBmUDOoGdQMagY1g5pBzaBmUHOoOdQcag41h5pDzaHmUHOoOdQG1AbUBtQG1AbUBtQG1AbUBtRGqcnjASQgAxuwAwWoQAM6EGoENYIaQY2gRlAjqBHUCGoENeQSQS4R5BJBLhHkEkEuEeQSQS4R5BJBLhHkEkEuEeQSQS4R5BJBLhHkEkEuEeQSQS4R5BJBLhHkEkEuEeQSQS4R5BJBLhHkEkEuEeQSQS4R5BJBLhHkEkEuEeQSQS4R5BJBLhHkEkEuEeQSQS4R5BJBLhHkEkEuEeQSQS4R5BJBLhHkEkEuEeQSQS4R5BJBLhHkEkEuEeQSQS4R5BJBLhHkEkEuEeQSQS4R5BJBLhHkEkEuEeQSQS4R5BJBLhHkEkEuEeQSQS4R5BJFLlHkEkUuUeQSRS5R5BJFLlHkEkUuUeQSRS5R5BJFLlHkEkUuUeQSRS5R5BJFLlHkEkUuUeQSRS5R5BJFLlHkEkUuUeQSRS5R5BJFLlHkEkUuUeQSRS5R5BJFLlHkEkUuUeQSRS5R5BJFLlHkEkUuUeQSRS5R5BJFLlHkEkUuUeQSRS5R5BJFLlHkEkUuUeQSRS5R5BJFLlHkEkUuUeQSRS5R5BJFLlHkEkUuUeQSRS5R5BJFLlHkEkUuUeQSRS5R5BJFLlHkEkUuUeQSRS5R5BJFLlHkEkUuUeQSRS5R5BJFLlHkEkUuUeQSRS5R5BJFLlHkEkUuUeQSQy4x5BJDLjHkEkMuMeQSQy4x5BJDLjHkEkMuMeSSKPN8broENmAHClCBBnTgKIxcspCAUGOoMdQYagw1hhpDjaHWoNag1qDWoNagFrnk+sIIR/lnogFDLRoqcsnEyCULL7VGgQxswA4UoAIN6MBRGLlkIdQEagI1gZpATaAmUBOoCdQil7RoncglCxnYgB0oQAUa0IGj0KBmUDOoGdQMagY1g5pBzaBmUHOoOdQcag41h5pDzaHmUHOoOdQG1AbUBtQG1AbUBtQG1AbUBtRGqUX5aCIBGdiAHShABRrQgVAjqBHUCGoENYIaQY2gRlAjqBHUGGoMNYYaQ42hxlBjqDHUGGoMtQa1BrUGtQa1BrUGtQa1BrUGtQa1DrUOtQ61DrUOtQ61DrUOtQ61DjWBmkBNoCZQE6gJ1ARqAjWBmkANucSRSxy5xJFLHLnEkUscucSRSxy5xJFLHLnEkUscucSRSxy5xJFLHLnEkUscucSRSxy5xJFLHLnEkUscucSRSxy5xJFLHLnEkUscucSRSxy5xJFLHLnEkUscucSRSxy5xJFLBnLJQC4ZyCUDuWQglwzkkoFcMpBLBnLJQC4ZyCUDuWQglwzkkoFcMpBLBnLJQC4ZyCUDuWQglwzkkoFcMpBLBnLJQC4ZyCUDuWQglwzkkoFcMpBLBnLJQC4ZyCUDuWQglwzkkoFcMmYuudagx8wlEwnIwAbsQAEq0IAOhJpATaAmUBOoCdQEagI1gZpATaCmUFOoKdQUago1hZpCTaGmUFOoGdQMagY1g5pBzaBmUDOoGdQMag41h5pDzaHmUHOoOdQcag41h9qA2oDagNqA2oDagNqA2oDagNpItTbrXq8vyLVZ97qQgaGmgR0oQAUa0IGjcOaSiQRkINQIagQ1ghpBjaBGUGOoMdQYagw1hhpDjaHGUGOoMdQa1BrUGtQa1BrUGtQa1BrUGtQa1DrUOtQ61DrUOtQ61DrUOtQ61DrUBGoCNYGaQE2gJlATqAnUBGoCNYWaQk2hplBTqCnUFGoKNYWaQs2gZlAzqBnUDGoGNYOaQc2gZlBzqDnUHGoONYeaQ82h5lBzqDnUBtQG1AbUBtQG1AbUBtQG1AbURqnNuteFBGRgA3agABVoQAdCDbmEkEsIuYSQSwi5hJBLCLmEkEsIuYSQSwi5hJBLCLmEkEsIuYSQSwi5hJBLCLmEkEsIuYSQSwi5hJBLCLmEkEsIuYSQSwi5hJBLCLmEkEsIuYSQSwi5hJBLCLmEkEsIuYSQSwi5hJBLCLmEkEsIuYSQSwi5hJBLCLmEkEsIuYSQSwi5hJBLCLmEkEsIuYSQSwi5hJBLCLmEkEsIuYSQSwi5hJBLCLmEkEsIuYSQSwi5hJBLCLmEkEsIuYSQSwi5hJBLCLmEkEsIuYSQSwi5hJBLCLmEkEsIuYSQSwi5hJBLGLmEkUsYuYSRSxi5hJFLGLmEkUsYuYSRSxi5hJFLGLmEkUsYuYSRSxi5hJFLGLmEkUsYuYSRSxi5hJFLGLmEkUsYuYSRSxi5hJFLGLmEkUsYuYSRSxi5hJFLGLmEkUsYuYSRSxi5hJFLGLmEkUsYuYSRSxi5hJFLGLmEkUsYuYSRSxi5hJFLGLmEkUsYuYSRSxi5hJFLGLmEkUsYuYSRSxi5hJFLGLmEkUsYuYSRSxi5hJFLZt3r9ancNuteF3bgpdYpUIEGdOAojFyykIAMbMAOhJpDbeYSCXTgKJy5ZCIBGdiAHShABUJtQG2U2qx7XUhABjZgBwpQgQZ0INQIagQ1ghpBjaBGUCOoEdQIagQ1hhpDjaHGUGOoMdQYagw1hhpDrUGtQa1BrUGtQa1BrUGtQa1BrUFtfu++BRKQgQ3YgQJUoAEdOAoFagI1gVrkEuHADhTgpSbz7xrQgaF2PVbPuteFBGRgA3agABVoQAdCzaBmUDOoGdQMagY1g5pBzaBmUHOoOdQcag41h5pDzaHmUHOoOdQG1AbUBtQG1AbUBtQG1AbUBtRGqc2614UEZGADdqAAFWhAB0KNoEZQI6gR1AhqBDWCGkGNoEZQY6gx1BhqDDWGGkONocZQY6gx1BrUGtQa1BrUGtQa1BrUGtQa1BrUOtQ61DrUOtQ61DrUOtQ61DrUOtQil/AIJCADG7ADBahAAzpwFCrUFGoKNYWaQk2hplBTqCnUFGoGNYOaQc2gZlAzqBnUDGoGNYOaQ82h5lBzqDnUHGoONYeaQ82hNqA2oDagNqA2oDagNqA2oDagNkpt1r0uJCADG7ADBahAAzoQagQ1ghpBjaBGUCOoEdQIagQ1ghpDjaHGUGOoMdQYagw1hhpDjaHWoNag1qDWoNag1qDWoNag1qDWoNahFrlEeiADGzBmChYoQAXGTMEDHTgKI5csJCADG7ADBahAqAnUBGoKNYWaQk2hplBTqCnUFGoKNYWaQc2gZlAzqBnUDGoGNYOaQc2g5lBzqDnUHGoONYeaQ82h5lBzqA2oDagNqA2oDagNqA2oDagNqI1Sm3WvCwnIwAbsQAEq0IAOhBpBjaBGUCOoEdQIagQ1ghpBjaDGUGOoMdQYagw1hhpDjaHGUGOoNag1qDWoNag1qDWoNag1qDWoNahFLtEWSEAGXmrXsftt1r0uFKACDejAURi5ZCEBGQg1gZpATaAmUBOoCdQUago1hZpCTaGmUFOoKdQUago1g5pBzaBmUDOoGdQMagY1g5pBzaHmUHOoOdQcag41h5pDzaHmUBtQG1AbUBtQG1AbUBtQG1AbUBulNuteFxKQgQ3YgQJUoAEdCDWCGkGNoEZQI6gR1AhqBDWCGkGNocZQY6gx1BhqDDWGGkMtcolx4CiMXLLwUruOgW6z7nVhA15qpoECVKABHTgKI5csJCADGxBqHWodapFLvAc6cBRGLllIQAY2YAcKUIFQE6gJ1CKXXKfmtln3upCBl9qIpo5cslCAl9rwQAN64qy1HEHxVyc+/ypfZ0a1KLVMHIXX8E0kIAMbUC/kQAM6cBTyA0hABjZgBwoQagw1hhpDrUGtQa1BrUGtQa1BrUGtQa1BrUGtQ61DrUOtQ61DrUOtQ61DrUOtQ02gJlATqAnUBGoCNYGaQE2gJlBTqCnUFGoKNYWaQk2hplBTqGmoXWkniioTCcjABuzAUIsBbgo0oAMvNYrxe/3oJV5q15kELYoqExuwAwWoQANeatdr2C2KKheOBzDUNJCBDRhqcb1DgAo0oANHYhRVPjfeAgnIwAa81LgHClCBl9pV/9eiqDJxFEbWaBEsssZCBsZdWOAVN4qxolCSYyMoCiU5tnyiUDKRgQ3YgQK84sbSdhRKJjpwFEZ+iLWtKJRMvNR6XGTkh4UdKEAFGvBSEwochZEfFhLwUouV9iiUTLzUYnk9CiUTFWjAUAvhyA8TIz8sJCADG/BS07icyA8LFWjAS03jIiM/TIz8sDDUJJCBDejAiBB3Ee7WGARxFH9AT5CE65osBlv42iJM+HrhKAxfx89+FDgmMrABO1CACjSgA0fhgNqA2oDagFr42mKwha8XKtCADhwLexQ4JhKQgQ3YgQKMuB44CsPBCwnIwAbsQAEq0IBQC7fbuDDcvpCADLyCOQVe/8z5wrDtQgIysAE78LpIj5sP2y40oANHYdh2IQEZGGoS2IECVKABHRhqemHYdiEBGRgSFihABYZENHV4deEoDK8uRG8qelPRm4reVPSmojcVvWnoTUNvGnrT0JuG3nT0pqM3Hb3p6E1Hbzp609Gbjt509KajNwd6c6A3B3pzoDcHenOgNwd6c6A3B3pzVG9G7WAiARl4SVwf1ehRMMjXrL9HwWCiAb0wvDlaYETogQJUoAEdOArDhSMuJ1y4kIEN2IECVKABQ40DR2GYdyEBQ80CGzDURqAAFWjAp1q75oE9igAXXuZNJCADG/Cp1ij64jJvol4YF3mZN9GBlxpFX1zmTSQgAxvwUuOQuHycqEADOnAUXj5OJCADGxBqGmoxjFSBBnTgKLQHkIAMbMAOhJpBzaBm0ZLRhTYK/QEkIAMbsAMFqEADQs2hNuIuoltGA3agABVoQAeOxCj3SyQgA0OtB3agALWQIpgGxj+zwA4UoAIN6MC4yOvmo24vkYAMbMAOFKACL7XrYaBH3V7iKLzsn0hABl5q11vBPer2EgWowJDgwFEYnl8YEtHU4fmFDdiB1ZtRlpeI3hT0pqA3Bb0p6E1Bbwp6U9Cbit5U9KaiNxW9qehNRW8qelPRm4beNPSmoTcNvWnoTUNvGnrT0JuG3jT0pqM3Hb3p6E1Hbzp609Gbjt4Mb141Uj2K6lqL1hkPIAEZGME8MCLEpYcLA6NQLpGADGzA6yKvcr8ehXKJCjSgA0dh2HQhAUPNAhuwAwUYahxowFDrgaMwzLuQgJeaPAIbsAMFqEADXmrXM1qPQrmF07EeyMAG7MCQ0MDqltbQLR3dEjaVuPmw6cIGjEuPuPHTvP6ZAg0ItQ41gZpgEAgGgWAQhHkXQk0gAfO2+cs7kYENGJc+/1mZt8G8bZo3MMyr0QFh3oUMvOJqjCjr+GcCVCDUDGoGtTDvQgIysAGh5pAIm87bHGiSgSYZaJL4YZ3tMBBh4CIHLjLMG3cclWmJBORsh/6oi+yPDhSgAg3owGqSTg8gARkINfzc9jmvboGjcM6rJxIwLp0Da77eWYEGvC5S5z8bhfETujCaJP7unEFPbMAOhFqDWoNac2A9HUSJWSIBodYhMZ9uo1vm0+3EUTifbifGpUtgPdX1+Ug7UYFXv11rQz1qxRJHYRhSoy+0niGjViyxAaGmUFOoxYPuQgfWE2vUiiVCzSCBB90oBUtEkxiaJFw42wEPuh0Put1xkWG9eceOJnE0SRhytsPARQ5c5ECTDKgNqA2oDTTJQJMMNMmoJpHHA8jAyyLqgQo0oANHYbjQIkK4cCEDG7ADBXipXWttPWq6Eh04CuMn1CyQgAwMtbiy+AldKMBL7foea4+arhYdGzVdzxQaOArDvAsJyMAGjLhxkc2ADhyF8Wu6kArDZNcXPXuUViVeErHoEEVULR7Bo4gq0YGjMEy2kArjNytSWxQ7JTKwATtQgAo0oANHoUPNoeZQc6g51Bxq4ZZIV1HA9FzFDowI0d3xQ7WwAyNCdHf8fC00oANHYhQwJUbcEfiM0K/N0x5FSc/fsEAHjsLLDP3aIetRlJTIwAbsQAGGWg80YKhJ4CjkBzDiamBEsEADRgQKjAhxm+0BJCADI260Q+tAAV5qsfgShUaJDoRah1qHWodab8BefdEFqEADOhC9GR6aXShSXShanSXoTUFvyqi+UPSmojcVvanoTUVvqlS/KXpTrTpL0ZuK3jSuLjSpfjP0pll1oXk1lKF9He3raF/n6ixHbzp68/Lb6ixHbzp606HmUBtQG1Ab1ZtRVdNj2S2qahIZeF3Otbvao6omUYAKNKADR2GYYSEBQy0uJyyysAMFqEADXmoc1xvGmRjGWUjASy2WF6KqJrEDL7VYU4iqmkQDhpoEjsIwzkIChpoGRlwLVKABHRhxr56P+pkez/5RP9Pj0T7qZxIbsAMvtVizifqZRAM68FJrcW/hoVgGiKKZHg/QUTTT40ktimZ6PEBH0UyiAg3owFF4/b4lXmo9Wj2ctfBS6yFsHShABRrQgZeaRDuE3xYSkIGXmsTlhN8WCvBSk7iy8NtCB4ZadHf4LZ6w47C4RAY2YAcK8Iobz2RxLNzEOBZuYdg0HlaieijxihvPLXFQW6IAFWhAB47CsOlCAjIw1CQw1DRQgAo0oANHYRgypthRJ9Rjyhp1Qs/cEWhAB14RLJokrLeQgAxswA681GJ6G3VCiaEWjRqGXDgKw3qx5Ru1P92iHcJkC+OOR6BXQ4XJJsZv1kICRtxokvDbwg5Ebyp6U9GbCjWFmkHNoBZ+mxgOiIl3VOMkCjD8FhLhgIUOHIXhgIUEjHuLJgkHLOxAASrQgJ4YdTc9ng6i7iaxATtQgAo0oANHYfwsLoQaQY2gRlAjqBHUCGoENYIaQ42hxlBjqDHUGGoMNYYaQ42h1qDWoNag1qDWoNag1qDWoNag1qDWodah1qHWodah1qHWodah1qHWoSZQE6gJ1ARqAjWBmkBNoCZQE6gp1BRqCjWFmkJNoaZQU6gp1BRqBjWDmkHNoGZQM6gZ1AxqBjWDmkPNoeZQc6g51BxqDjWHmkPNoTagNqA2oDagNqA2oDagNqA2oDZSTaLWJ5GADGzADhSgAg3oQKgR1AhqBDWCGkFt5hIOVKABx8qIEmU/iQRkYAN2oAAVaEAHQq1BrUGtQa1BrUGtQa1BrUGtQa1BrUOtQ61DrUOtQ61DrUOtQ61DrUNNoCZQE6gJ1ARqAjWBmkBNoCZQU6gp1BRqCjWFmkJNoaZQU6gp1AxqBjWDmkHNoGZQM6gZ1AxqBjWHmkPNoeZQc6g51BxqDjWHmkNtQG1AbUBtQG1AbUBtQG1AbUBtlFpUISUSkIEN2IECVKABHQg1ghpBjaBGUCOoEdQIagQ1ghpyCSGXEHIJIZcQcgkhl9CcjEigAg0YydECR+GcjEyM5KiBDGzADhSgAi+1axlWongpcRRGLllIQAY2YAcKUIFQ61DrUBOoCdQEagI1gZpATaAmUBOoCdQUagq1ORmJHpqTkYkdKEAFGjDUOHAURi5ZGGotkIEN2IFxF/3CyA8jhkbkh4UMjAgxNCI/LBRgtI4HGtCBozDyw4gbivywkIEN+Iwrj2i+y/NyLedJlB4lEjDa1wMbsAMFqEADOjDUrtaJ2qREAvKFLbABO1CACjSgA0chP4AEhBpDjUNNAkNNAxVoQAeOwvYAEpCBDdiBUGuhNgIN6MBQu0ZJFC8lEvBSo+jCy/OJHXipUQS7PJ9oQAeOwsvziQRkYAN2INQuz8tVWChx0liiAy+1ay1TouYpkYCXGkewy/OJHXiptQh2eT7RgJdai4a6PL/w8nzipdZi0F6eT2xArZa0aJ2I6w8gARnYgB0Y1xuX7go04HW9PW7+8vzCy/OJl1qPYJfnExswxtn8uwJUYMS9HBDlT4kEZGADdqAAFWhAB0KNoEZQI6gR1AhqBDWCGkGNoEZQY6gx1BhqDDWGGkONocZQY6gx1BrUGtQa1BrUGtQa1BrUGtQa1BrUOtQ61DrUOtQ61DrUOtQ61DrUOtQEagI1gZpATaAmUBOoCdQEagI1hZpCTaGmUFOoKdQUago1hZpCzaBmUDOoGdQMagY1g5pBzaBmUHOoOdQcag41h5pDzaHmUHOoOdQG1AbUBtQG1AbUBtQG1AbUBtSQSzpySUcu6cglHbmkI5d05JKOXNJnLumBDhyFM5dMJCADG7ADBRhqFmhAB4baNT3oM5dMJCADG7ADBahAAzoQag1qM5eMQAY24KV2lVJKFHElKvBSk7ihmR88sAGvCFe9nMTZX4kKNKADR2HkB43rjfywkIENGGpxZZEfFiow1OJ6Iz8sHIWRHzQuPfLDQgY2YKhFQ0V+sLjeyATXFolE5dbCyAQLCXjFtRgwkQks7iIygcXlRCawUItMsNCADgy1uJzIBAsJyMBLzeN6w/6xUhZVXuJhkbB/PJBGlZfExDuqvBaG/RcSkIEN2IGhFtcQ9l/oNeSm5y+U6fmJBGRgA3agABVoQAdCjaBGUCOoheevt6Akar8SBXipxbNe1H4lOnAUhucXEpCBDdiBAoQaQy08H8+FUfu1MDy/kIAMbMBQizsOzy9UoAGfahpPgFERtvCaPyTShXFlV37QeDSK87wS+4U9UIB6YVzOlR8SHTgK5QEkIAMbsAMFCDWBmkBNoKZQU6gp1BRqCjWFmkJNoaZQU6gZ1AxqBjWDmkHNoGZQM6gZ1AxqDjWHmkPNoeZQc6g51BxqDjWH2oDagNoINQ1swA4UYP0ORTlcogNHYpTDJRKQgQ3YgXEXVyqOcrj5UxflcHrVBUmUwyU2YAcKUIFWyNEOI7DaN87dmrcZ524lKtCAV/vGE2CUwy28PJ9IwOrNKIdL7EABKtCADhx1DdPzEwnIwFbXEJ5fKECowfMKzys8r/C8wvMKz6vU2FFBSwpaUtCS4fl5DYKWFLQkPK/wvMLzCs8rPK/wvMLzqui36fmJaElDSxr6LTy/EC0Jzys8r/C8wvMKzys8r/C8wvPq6DdHSzpa0tGSjpYMz8diRpTZJUZLXr8BUWaXSEAGxr3FNYTnFwpQgQZ04EiMc7cSQ00DGRiefwRqujBO2NLrqBCJE7YSRyE9gNVDUQuY2IAdKEAFGrB6KGoBF/IDSEAGNmAHClCBcRdX3rGZHyYSMO4i2iHyQyylRdVfogAVaEAHjsLIDwsJGHEpUIAKNKADR2FkgoUEZGADQk2gJlATqAnUBGoKNYWaQk2hplBTqCnUFGoKNYWaQc2gZlAzqBnUDGoGNYOaQc2g5lBzqDnUHGoONYeaQ82h5lBzqA2oDagNqA2oDagNqA2oDagNqI1Si7LARAIysAE7UIAKNKADoUZQI6gR1AhqBDWCGkGNoEZQI6gx1BhqDDWGGkONocZQY6gx1BhqDWoNag1qDWoNag1qDWoNag1qDWodah1qHWodasgljlziyCWOXOLIJY5c4sgljlziyCWOXOLIJY5c4sgljlziyCWOXOLIJY5c4sgljlziyCWOXOLIJY5c4sgljlziyCWOXOLIJY5c4sgljlziyCWOXOLIJY5c4sgljlziyCWOXOLIJY5c4sgljlziyCWOXOLIJY5c4sgljlziyCWOXOLIJY5c4sgljlwykEsGcslALhnIJQO5ZCCXDOSSgVwykEsGcslALhnIJQO5ZCCXDOSSgVwykEsGcslALhnIJQO5ZCCXDOSSgVwykEsGcslALhnIJQO5ZCCXDOSSgVwykEsGcslALhnIJQO5ZCCXDOSSgVwykEsGcslALhnIJQO5ZCCXDOSSgVwyZi7hwFE4c8lEAjKwATtQgAo0INQEago1hZpCTaGmUFOoKdQUarGWGbP4KLBcGGuZCwnIwAYMtR4oQAWGmgQ6cBTOXDKRgAyMe9PAUPNAASrQgA4chTOXTCQgAxsQaqP2paPAMtGAtS8dBZaBGgWWidGSHsjABuxAASrQgA4chbGCsRBqBLWZNUbg1TrXGzIa9ZN6vQCjUT+ZSEAGXhGuN2Q0aiL1OlRDoyZyYXh+IQEZ2IBX+1776Bo1kYkKNKADR2F4fiEBQ60FNmAHCjCqDOLeYqdioQNDLdosPL+QgAxswA4UoAIN6ECoKdQUago1hZpCTaGmUFOoKdRi/jB7M+YPCwnIwEutx1AOd88uDHcvxHgId/cYXOHuhQS84vZoX8d4CHcvFCDUHGoONcfoGxh9A6NvYPQNqA1IxESgx3iIiUBgFDcmxqVLIAMbsAOvuF0DFWhAB4baNWijjFGvPTWNMsbEDoy4I1CBBnTgKAxLLyTgpXatjGiUMSZ2oAAVaEAHjsJw9/W6mEY9oko0X/h4oQNHYfh4IQHjIqNRw8cLO1CACjSgA0dh+FiiA8LHCxnYgB0oQK1uCR8vdOAoDPNem8Ya5YardcKmCxVowLj0GBqGJglDLmzAiBtq8SO8UIERN3re0AGGDnB0gEPNoeZQC5suFCC629HdDrUBidg6fMSAmfVGE69gOlGBBnTgSIx6xEQCXpd+HYaiUY+Y2IGh1gIVaMBQo8BRGPP1hVn9qKsecWIDdqAAFWhAB47CWY84sa2KUY3Kw8S4i4kKNKADR2H8Si8kYLSZBjZgB4aaBSrQgKEmgaMw3L0wK1yVOwMbsAMFqEADOnAUygMYd+GBHSjAuIsRaEAHXndhMaLi93jh1WYW3RK/xwsb8FKzGGdh9IUKNKADR2H8Hi8MtRiTYf+FDdiBAlRg1LpHk0S18eys+TZCdOx8G2FiA3agABVowKsv5jCKauOJUW28kICX2uyAqDZe2IECVKABHTgS23w5eGK0Tg/sQAFG60igAR0YfXHdW1QeJkZfWCADGzDU4hriB3uhAg3owFEYP9gLQ20EMrABO1CACrza7BFXFufDjPiv8/iMiQxswA4UoAINePXFtcGhUWO4MN4wWEjAUJvYgB0oQAUa0IGjMDy/ED0v6HlBzwt6XtDzgp4X9Lyi5xU9r+h5Rc8rel7R84qeV/S8oucVPW/oeUPPG3re0POGnjf0vKHnDT3v6HlHzzt63tHzjp539Lyj5x097+h5R88P9PxAzw/0/EDPD/T8QM8P9PxAzw/0/Kiej7rBxKt1fGIHClCBV19c9VEaFYKJozA8v5DWYT46z2tb2IAdKEAFGtCBozDcfZ0SrVELmNiBAlSgAeMuPHAUxu/8QgKG2ghswA681EY0VPzOLzTgpXYVJGkc6KbXSy0aB7ppzEviQLdEBjZgB0phTMdnk8R0fGH8Mw3swPhnFvi8yPhQhEYBYKIDR2GcUb6QgBE3WidsGm6Zh7TFOsE8pG1iHNK2MCJEO8Rp5AsbsAMFqMCnms3xe83ME8eFMfou8yYSsF8YEeJg8jb/q1eTxEPxxJh4LyQgXxHiLi5DJnYg2jem4wsNCLVRalGzZ9dmtEbNXqIA9cIRaEAHjkJ6AAl4Xfp11rVGzV5iBwrwUruO19Go2Ut04KV2lQto1OwZhcT1y5vIwAbsQAEq0IAOvNRiQTBq9hIvtWu1WaNmL7EBO/BS47j0y5uJBnTgKOwPIAEZGGrRQ70Do9+idXqoTTSgA0ehPIAhEUNDGrAD44Y8UIEGvCTCplGot/DyscWwj0K9RAZeamGyKNRLFKACDejAUWihFiPKCMjABuxAAca9xSCI5+5INjLdHX9hunsiAxuwAwWoQMvkOEvyFo7CmQkmUma5WZK3sAE7UIAKNKADR2IU31ksHkbxXWIHClCB0RcW6MBRGElhIQEZeKnFQmMU6iUKUIGXWqxExrl1iaMwkkKsAmokhYUMDDUJDDUNDLW4nEgKCw3owFEYSWHhNcGIFomzjydJkRZZkSeFK2P5KarqFoYrF15zmri/ecp4UCvqRVKkRRExujjsFit/83i5+N/jpdpJUnRN6aLB443aSV40kuJ12klUFCITG/Bq61gqi9K4RAVelxnrTVHuZhItE35aGJPPoAgQXRh2WmhAB47CeTJxUDXnqOYc1ZyjmnNUcw7PRozatdmIUbtmscQYtWuJcasWKMC4Ug+MnaEgLxpJc1soiIq4KCLGhYQBYvls1qfF/x6Po5OoKIrTglpRL5IiLbKiEJlhRmGM+1iYi2K1RAZelxkLc1GAZrGSEAVoC+OltriN+H2bDRO/bwsbsAMjrAQq0IBeDR5OmhhOWgg1gZpATaAmUBOoCdQEagI1hZpCTaGmUFOoxU/dQl1DPYrS5vCNorTEGtRRlJZIhfHjFMtGUTGW2IDXGI/RGieiTtIiK/KikRQ+mkRFXNSKSmOUxiiNURqjNEaMj2tURIlYIgGvm4k1uygRS7waMRaSokQsUYEGdOAojN+ohZdaLD1EiVhiA15qsdQXJWKJCrzUYm0iSsQSR2EcNBz3E+cMT+KiVtSLpCgiXq0VBV8WixlR8GWxFBEFX4kdKMDrSuOxOgq+Eh04CmMauvC61BALl8azdtR7JXbgJXa9t6RR75VowBCLtgiXTgyXetxauHQhA2OtM6gXSZEWWZEnhRN9YlxptEV4Lh6io3or0YAOvK50xA2G6RYSkIENGLsKQVKkRbE8HuRFI2meNRFERVwUIjHkYq65UIBeOOIyo/HjSXLh1aDREPNwqiApulokHumjCivRgdEiV5tGFVZiSHkgA+NiR+BTy+PBOaqwPB6RowrL4xE5qrASHXj9Qkas+IWcREURtAXGP++B8c8lcFx4jaMoq/JYa4uyKn9EBI4IcYUsQAXGDDrIi0bSZUGPxbOoiHKKu4r1mFCK5ZhJ10VR3NNlNY8n36iHSiQgA9uFcVuX1xIFqEADOnAUygMYcaONJCJEG2n8hbhejcuJNlIGNmAHWqFFhGgbI+AVIR6j57cc4yk5ioo8CjiiqCiRgZcaRztcYz1RgFpxr1+v/K8OHIXjAaS648HABuxA3NvwuqExFlqUDyW2NRosCoX8emi3KBTy60ndolAo0YAOHIX0ABIwWkcDG7ADQ80CQ80DQy0uMtzR4iLDHdeQtSgqSiTgFbdNFKACYxc5yItGUrjjmkpb1A759ZBtq3YoyIrioqK5wh0t/n24YyEBGXg1QYv7DncsFKACDejAURjuWBhxoxHDHS0aMdzRohHDBz0aMXywUIAKjGflIC8aSXPRIoiKuKgV9SIp0qLSsNKw0vDS8NLw0vDS8NLw0vDS8NLw0vDSGKUxSmOUxiiN+FGJsRO/KZPGoijnWURFXNSKepEUaZEVeVFpUGlQaVBpUGlQaVBpUGlQaVBpUGlwaXBpcGlwabQYPBYYg6cFxuDxwGt8Xr/8FsUx11OzRW3MIiqKH7IgKdKkyOYykYENeP3zGWlOj4K0yIq8aCTFGJ5ERVzUinpRaVhpXOPVJRogfgOuBQCLmhaP+4+fgElSpEVW5EUjKZL/JCriotIYpTFKY5TGKI1RGiM1osZl0VPj2oOxqHBZ1IqeGtcs0aK8ZZEWRStc2S0KVvxaXbAoWPHr6dKiYCVRgAo0oANHYeT6hQRkINQYagy1+AW4pmAWZSyJDhyF7QEkIAMbsAMFCLUGtQa1BrXrJ2NEJ1y/GIu4qBX1IimKiIGXr1yju65HEYqfwyhVSexAuXD+XQUa0IGj8Po1Sbxa4FpCsSg/8fhNjPKTRAde93qtpliUnyQSkIEN2IECVKABHQg1h1rM1jQGZjh1YQOGWnRIeHVhqEX7hlstbj7sanHz4deJYdiFl5qFcFh24aVm4ZMwrYVwuNZijF62pcinUZSS6MCRGEUpiQSMuB4Y1zsCr+u9Hnktyk8Wxmxt4XW911keFuUniQ3YgQKMuCEcrry2jC1KSvx6UrYoKUnsQAEq0IAOHIXhyoWhpoEMbMBQs0ABKtCAoRZtFq6cGBO5hVf7RhaJQpPEBrycFVkvCk0SFWhAB47C6+eRIh3EYVaJDIx7i96Mn82FAlTgKIxfzsjhUVKSeD3CR1/Nz0ZcNL8aEXRlnOjfy4GLpEiLrMiLRtLlvUVUxEVxMTFy5m/kRAHG71Z09vxxnDgK589jNN78fZzIwOs24oYusy2SIi2yIi8ai6IOZBEVcVEr6kVSpEVW5EWlQaVBpUGlQaVBpUGlQaVBpUGlEb+g12qHxWFRiQSM9hqBDdiBl9K18GFRIJJ4aT1C4vJq4ii8vJpIwJhaSGADXrd1LXhYFIiMR1xZCzUPNKADQy0uMn5BFxLwUotY8Rs6qRdJkRZZ0uXHEb90USUy4mczqkTGtSBiUSWSqEADXldKcduXHxfqA0hABl5Z5RHC1/yWZhNpqEUTaahFC6gBw4Hzn4UF4xrsAQwThoSFCyPYtPrEmAfMv3vlpXgGjqOfKB5c4+inxA6MxBBt5go0oANH4XgACXhdWTznR+1IYgdqXVn8QC50YFz6dZtxClQiAUOiBTZgB143FPcWFSWJ1w2tCA4chRRqGkhABjZgBwpQgQZ04ChkqDHUGGoMNYYaQ42hxlBjqDHUGtQa1BrUGtTCzAsFqMBoSQt04CgMM8fqRVSUJDKwAUNtBEZKfATGvc3/akAHRuq9LB0VJYkEZGADdqAAFWhAB0JNoaZQ02jJuKGw/8IOFKACDejAUWgxRQwJIyAD4944sAMFqMC4t7BI/NwvHIXx474wIoRxIin06PlICgsdOArD/rGGIPOHOjpr/lJPNKADR6LOX+uJV/teW9EWBSOJDdiBAlSgAR0YatdI1fm7PZGADAw1DuzAUGuBCjTg1ZvxcBAFIwvD8wsJyMAGjLg98LreeDiPIpAR88042SmRgQ0Y1+uBAlSgAR14qWk0VPh4IQEZ2IAdeKnFWmyc7JRoQAeGWlxv+HghAUMtrix8HE9yUYaSGLOAR6ACYx4QlxM+XjgKw8cLCcjABuxAASoQago1hZpBzaBmUDOoGdQMagY1g5pBzaDmUHOoOdQcag41h5pDzaHmUHOoDagNqA2oDagNqA2oDagNqA2oRX6I5/I42SmRgAy8PHRtBFpUxyQKUIEGdOAojDnBQgLGXbTAuN4e6MC43muAR5FMIgEZ2IAdKMCIe5khCmBmk0QBzLrj8PzCDhRgtK8FGtCBo7BXb0a1TCIDG7ADBahAq2sIzy9Ebwp6Mzw/ryE8v7ABoSZQE6jB8wbPGzxv8Lwpxo6iJRUtqWjJ6fm4BkVLKloSnjd43uB5g+cNnjd43uB5g+dtej6uwdCShpY0tKSjJafnY6ROz08MtRHYgQJU4KXmM5gDR2F4fiEBGdiAHXipxWpTVOckYoCH0WMNKqpyEgnIwBoaUZWTKEAFGtCBNeyjKme2elTlJDKwATtQgAo0YA2NKMAZsfgVFTiJDRgNpYHRUHFlMRFYaEAHjsKYHiwkIAMbMOJ6oAEdOAojKcRyVNTmJDKwAWPaETcUSWGhAg3owJrkRHFOIgFjehuXM6fuExVowCtuLJT5nKTHlYXRFzZgrMlHD4XRFyrwihtrXlGik/+spqxRopMINYOaQW1O0icKUIEGhJpDInwck/QoxUkUYFx6WCR8vDCaJAZX+Hhi+Hhh7FzE0AgfL2zAaKi4hvDxQgUa0GMNJHogHugnR+1OMW3MwRQswRysG9vGM34LHmB6bEwb88Zt477x1O3BurFt7BsPMD82po154xlTg+e/vdo1zkIqpo1547Zx33he8wjWjW1j33iA+2Nj2pg3Dt1YRYtKoGLZWDe2jX3jgb6Tx8a0MW8cY80DDc0mvvEA62PjCBmrfUO3plLZWDeelxyy6hsPcDyGPyiGiW1dZFsX2dZFtunapmubrtnGvvE2NHwbGr7p+qblteoX1UiJDozdvxiC4wEkYNxFrE1GOVJx33h2eCgO3dg2Ds2JY6FHpVIiARnYgB0oQAUa0IFQI6gR1AhqBDWCGkGNoEZQI6gR1BhqDDWGGkONZ2t6sGysG0drXovAHqVNxTEmrvo1f8x0sZg2jl68Ss38MdPF4tC9lpD9MdPFYt146kqwbzx1+8UzXSymjadu3ONMF4un7giWjUO3xX3NdLHYN750561HtlhIQAY2YAfOyNEyMzu0uNOZHVq0TCzaJbeN+8Zx5S1aY2aNxbaxbzzAM2u06NmZNRbzxm3jvrFsHLo9rn9mjcW+8QDPrNHj+mfWWMwbh26P64y9gMe1gOdRglU8daM33TaeunFtPsDjsTFtzBu3jfvGsrFubBtvugO69HhsTBvzxm3jvrFsrBvbxr7xpkubLm26tOnSpkubLm26tOnSpkubLm26vOnypsubLm+6vOnypjszzzWrdJqZZ7FvPMCRea56EI8PUSYysAE7UIAKNKAXzsRyFYc5zQRyLdk6zQSyOC77Woh1mglksW88wHO+sZg25o1n/LgG2ZpdttufaWQxbcwbR7Nfy7ZOa/NvsmysG2/drZuubt1tW3fb1t22dbdt3W1bd880Mq/Ntu62rbtt627b7nemkevhy2mmkcWz3TS4bdw3lo3n/c6YtrFvPMAzjSymjXnjtnHoaoyZmUYWG/p0pg6N8TNTRzDP1LGYNubqI360jfvGsrFubBv7xuhT3lIHb6mDt9TBW+rgLXXwljp4Sx28pQ6eKeIq7nKeKWIxbxzxw3c8U4TGdc4UsVg3to194wGek5PFtDFvPONLsG5sG/vGM/41lnhOQhbTxrzx/EmNe5w5ZLFsrBvbxr7xAMtjY9p4TvQDBajAObMKdOAonFnl2spwnlllMW88J+WBHSjAELRQnCllsW88LXbhzCgTCcjABuxAASrQgA6EmkPNoeZQc6g51BxqDjWHmkPNoTagNqA2oDZTh0W7zdSxWDaOCo0YTbGosXC2ZnTbTCLBs44vOUohHoEMjAKUEdiBAozCix5owCnYggd4Zo/FcZMeyMAG7EABKnBGDsWZH659B28zP1zrst5mflgsG+vGc+BFzJkfFg/wzA+LaeOpG20xH14W941jC50CFWjA2EKPBo+cMTFSxkICMrABO1CACjQg1DrUZqLwybNr4trmZGNx27hvLBvrxraxbzzAM40s3nRnGvHo3JlGFveNp26M35lJFtvGUzcGxswkk2cqWdw2jjrYCB8JYqEDR2EkiIUEfF45RxKNUsPEDpyXHeNnZojFtvG87BifM0lMnllicTxWxhCLNLGwATtQgAqcipN941HcZ5K4lpG9z5nGYt44GvBat/Y+ZxqLZeO406vC0vucaSz2jUP3Wvf1qDOMR76oM1w0/50H+8YDPGcQi2lj3jhWN+J3LAoOi2Vj3XhWp8c1sG88wG0WqMe1R4ZI5o2nrgT3jWVj3XjqavDUjevvM370T+eN28Z944h/LS16lBxSrLB5FB1SLKZ5fMnyyaEbeWFxJIZk2ngW+se1rUr/yX1j2XjqxvXPEv/4Bemzxj9+bvos8o+lnahRfHJoRTJIbhv3jWVj3dg2nouLcT06wHMyMcfgnE0sbhv3jWXjbVzb1Ip7NN94gH3eY9y708a8cdu4bywb68a2sW88wGPTHZtupI4oYfSofCzuG8vGurFtHLot2nOuogbPWshk2njqWnDbuG88dUdw6F5Vdi5zNXVx6F5FZS5zPXXyXFCNhaVZFpnMG7eN+8aysW5sG/vGA8ybLm+6vOnypsubLm+6vOnypsubLm+6bdNtm27bdNum2zbdtum2Tbdtum3TbZtu33T7pts33b7p9k23b7p90+2bbt90+6Yrm65surLpyqYrm65sujMvxe+LzLeQFvvGAxw5KuYfUUeZyMAG7EABKtCAXmjzdibPtDN5XrYE68a2sW88wDPtLKaNZ7OEJX1rdt9u37fbXzsxk2nj2exh25lGFveNZeOtu8emO7buHuhufTw2po1541bXozONLJaNdWOr69GVRiYP8JZGdEsjuqUR3dKIbmlEtzSiWxpRwjBT8o3RzsqPjQnXw7xx23jT3dKIbmlEtzSiWxrRLY3olka0oX91pZHJWzu3rZ0b+ldXGpm8tfOWRnRLI7qlEd3SiG5pRLc0olsa0S2NaN/6t2/t3Ld27ls7y9bOK414MG88dUdw31g21o1DNxZodaaRxQM8pzqLaWPeuG3cNw7dWCDUOdVZfOnGc2nUbS5b60wnsZYXlZvFbeO+8daNtnWjbd1om11ss8tKM5O3YetbN/rWjb51o2/d6Nuw3dKS+jZ8fBs+Yxs+M/3Emq/O9LNYNp7NFu0z04/Edc70s3gU20w/i2lj3rht3DeWjfE4Oss1F9NjY9qYN24bz/gjWDbWjeO+Yk3ZZppZPMAzzSymjXnjuK9YX7aZZmLt1WaaWawb28a+8QDPNLOYNuaN28abbqSZcEIUiCYa8BKV+XdHYWSYhZdibMrYfKtyYgN2oAAVaEAHjsL5VuVEqAnUZvKIlWWbSSJWgW0mCY3RMpPEYtqYN55xosfn800sm9p8vpk8s8Fi2pg3bhvPAoNozJkNFuvGtrFvPMAzGyymjef1e3DbuG8sG8f2Wwz8SAYLHThFozFnKlhMG/PGbeO+sWysG9vGvjF0/fHYmDbmjdvGfWPZWDe2jX3jUZ3uc4aymDbmjaeuBGt1tK9Ckcm+8byva0D6qhWZTBvP+7JgDB6fKWKxbLzp8qbLmy5j0Hp7bEwb88abbtu05iwjfgp9zjImz1nG4ogZK54+ZxmL28Z944gfq5M+ZxmLbWPfOHRjFdLnbOKqGnafs4nFfeMZP/p3ziYW28a+8QDPRLGYNp660e9zNrG4bywb68a2sW88wDNpeIyBmRxi+dJncljsGw/wTA6LaeO45lg09JkcFveNZWPd2Db2jQd45ocRfTTzw2LeuG3cN5aNFX0388Ni33gUj5UTRnCvdptlo8m6sW087+UaS7M8dLbVLA9NbhvPaw7dOT1YrBvPturBvv1b9NEsD03edHnT5U13en+xbKwb28abbtu0pq+vt+19lo0my8a68bwXDfaNB3h6f/Hcwol/23njtnHfWDbWjW1j33iAp/dH9OP0/uK+sWw87yvaYXp/sW88wPO9bgokIAMbsAMFqEArnJOGEeN1ThoW88Zt476xbHxd99z6mLWgHHu/cXLdk2NMe9u4bxzbFrHAPutFky04xq77xgM8ZgFe9MHcKlnMG7eN+8aysW48dWMMDd94JI9ZN5pMG/PGbR2IMWaRaDTPmFWiyb7xDG8X02Nj2pg3bhvP2/Jg2Vg3to1Dl0I3UsHiSAXJoXvtIYxZNJrcNg7dq/R4zLLRZN146o7gqduDp65c3KZuNFujjXnjGT/ut+nGtrFvPOPH/XbOITlmGWhy31g2NnCcgedxK3EE0kIGtnU0zXjMo1MmClCBBnTgKIwD9RYScLZztKHKxrqxbRztwNGP8VO+OOyeTBvzOstnRM1nYgcKUIEGdOAojAOSFrZ1oNN4zKOQJsbNcDT09P5i29g3njcT/3Z6fzFtzBu3jfvGsk6PGlHQmWhAB47EKOZMJCADG7AD591M9o0HeFp+8bybHswbt437xrKO5hpRrploQAeOwjiyZSEBGTh7R4J1Y9vYNx7gaenF109WRJwntAS1ol4kRVoUP1ZBXjSS4t2vSVTERfP6NXhepwUP8CzhXny1gsRfD38vbMAOFKACDejAURj+Xgg1hZpCTaGmUFOoKdQUasvYHswbt437xrOVRrBubBv7xgPsj41pY944dFv05vzdXywb68ah26IHp/cXD/D0/mJCDy7vT24b941lY93YNt5Gy8BomaWX8QmkMUsvk/vG875a8LyvHmwb+8YDPLPAVaE/ZullMm/cNp66cW3zh//aSB2z9DLZNvaNB3j+8C+mjXnjtnHfeNON89Y0yIq8KH4ZLoqz1iZRUZggqBX1IinSIivyopEUJ6xNoqLS6KURc32+NprHLKvkHv04M0OPfpxvdyzmjdvGM07ElBkn7lofG9PGvHHbuG8cbXvtUIxZR5lsG/vGAzx/7BfTxrzx1I2xN3PCYtlYN5660dczJywO3WvRc8ySSpZok5kTFvPGbeO+sWysG9vGvvEAj0135oRowpkSJjZgiMa4m/lgogKnYqADR+IsrFxIQAY2YAcKUIEGLLVZPsnXhs2YlZIcGX6WSvK12TBmrWSybezg6ehrw2DMYkmO3/dZLJmsG9vGvvEAz9/3mMXNYslk3rht3DeWjXVj23hevwcPcH9sTBtP3RbcNp660W5zPrBYN7aNfeMBntlgMW08daNtZzZY3DeWjXVj29g3HuDIHnMIRPJYyMAG7EABRmSLXpt54KojHm3mgcWRDeOvx6x/oQAVaEAHjsKY9S8k4HRcdO60uUUHTZsvto194wGeNl9MG8/bCa1p9MV9Y9l46obRptkX+8ajeNZIJtPGvPHU1eCpa8GysW5sG/vGAzynBNFNnWhj3rht3DeWjXVj29jBW6KYtZTJbeO+8YzvwUgUfUsUfSWKyfP649/ORLG4bRzxff592f6tbmwbb7pt0+2b7kwUi3njtnHfeNPtm9ZMAh5tNZPAYt44YsbSwKyTTJaNdeOIH8/5s2YyeYDnFGLx1I3xNqcKMbmatZHJuvGMH2NppoLFAzynCotpY964bTx1o9/nVGGxbmwb+8YDPKcKi2njWckcbT7zQDzQzVrHxTMPLKaNeeO28SyUjjZfldKTdWPb2DcexbPWMZk2nro9uG3cN5aNdWPb2KvvZq3j4pkHFtPGs184WKvdZh1jsm88wHPafy2vj1mvONtq1ismy8YzfujOScJi33jGv8bJrFdc/7bRxrzxpts23bbpTu8vto19Y4yNWa+YvGlNX8cUXbpubBv7xjPmNSZFMF0XaRv3jec1j2Dd2Daer2ZE+2+PCbI9Jsj2mCDbY4JsjwmyPSbIekyYrBvbxr7xpmubls1XTKKtTDbWjedbJjHmzTceYH9sPN9ribE9j3td3DbuG0/daH+f8ePafIDHY+MZP8bb4I3bxn1j2Vg3to2nbvT7PPI1eBYoJtPGvHHbuG8sG0fMWGefRYbt2o4Zs8gwuW8sG+vGtnFcc6y5zyLDxfMs18W0MW/cNu4by8ZTtwfbxr7xAM9TXRfTxlx9N4sMk/vGsvHslyu/zQLC1W7zfanFvHHbeN6LBG9tNV+PWjzAMuOHrtDGvPGMb8FbH8nWR7L1kWy6sunKpquPjWnjbWzoNjZ009VNax7OGnseszqwxX7ArA5M5o3bxrpxxIm9gVntlxxxYil+VvW1WE6fVXotFq9nlV4ybRy6sWA9q/eS+8aC+Oss5vnfbWPfeBRH9V58lWhE8V4iAxsQ9zqPWZz3Nyv3ktEGUaEXX20as0CvxfP5LNBrsaAwC/SSdWPb2Dce4GnRxbPJLJg3bhtP3biVadFYaZ0Fei1WUWeBXosV0ijQiy9NjajPWxhrcAuvpnlMjNjzXqcN11/RjW1j33iAp1UX08ZxT7HaOYvxkvvGUzfaeL7f2KJtpoVjtXNW5LXZnfHFqvj1iJK8RAL29QHAMb9lulCBETnWAGehXnLcUawHzkK9ZNo47ijWAG2adHHfOO4oJhU2DbvYNvaNB3gaOdbrZmFfMm/cNu4by8a6sYGnwWMdb34ZNeazsx6vSTRDPJcn+8ZxmbHsN0vykuMyJZpn+n5x2zguM5brZklesm5sG/vGo3iW5CVP3R7MG7eN+8aysW5s2Qyz8q5dBcVjVt4l88Zt4xleg2Vj3dg29vURzjG/jDoxPpa1kIAMbMAOFOBsLgse4PmzvJg2nvcT/3b+LC/uG8vGuj66OubXUxc6cBTG11MXEpCBDTjbaQTbxr5x3E88kvv8yV5MG8f9XAXNY1bjJcf9xBrjrMZL1o1DN9YPZzVe8gDPbLCYNuaN28ZTN4bXzAaLdWPb2Dce4Piw2MKr1WaLxGfENAZgfEdsoQIN6MBRGB/EW3j10RwV8wvkExuwA0MtWjw+i7fQgA4chfFpvIUEZGADXnEjPc0SvDavcuaDxaN4nuKYTBvzxm3j2TEaLBvrxrbxdUOR/uJwx4XxBb2FBGRgA3agABU4b+dq4LE+xTCZNp6348Ft477xvJ0RrBvH7cSK8KzOSx7gmSdiWXAe/JjMG7eN+8aysW48dTnYNx7gOW9YTBvzxtGWPbAGx6zTW53afeNtcMg2OGQbHLINDtkGh2yDQ7bBIdvgkG1wCAaHYHAoBodicCgGh2JwKAaHYnDoHBz/9V//9Ke//du//vnf//pvf/+Xf//HX/7yp3/+z/oP//dP//zf/vNP/+fP//jL3//9T//89//429/+6U//z5//9h/xl/7v//nz3+PPf//zP57/6zPoX/7+P59/PgP+r7/+7S8X/dc/4V8/Xv9Tkmu9KP41PR9oKgCR/RKCXofwa9IVEZ7DBgF8/BKAD9cQR2jOa3iovgxxuI34fsSK8Ogv76K/jtArQt8uwdov/15e//tI6PHvn3sXuADj2z3x6BnhOgTg5T0cO/N6CFqdqXtn/nobfmjIVtfQ6t/32//8ufWk2QzPKQCugPXX4XS4i3hUWC0p22Dg2xGU0hHPtYeK8HyU+jXCaUh2zRDPRvXXMdppRHC1xfPZ/GWMU3MOeVRbeH/dnIeBySzpT34+tSGGfLgVfbdLjjcy8kaeW2/t9Y0cYjzXSzPGE9EnSr+GGKduHWWQ5xLwqxB8GFtm2am+Zzt73I4QX02eEZ66LyMcRic/KuXyM2PCp7/2Bx8GZ3yxcl7EsNcXcUiYLd5VnYPi2ZgY3m7f6w972R/HUWGP/PF44njZpXZozu6Z9Vg6vQzhb/fpeLtP2+PdPm2Hn/IRJavzt5wZw/v5QH7/RuIkkHUjQi9v5DA4Y+91jqzHywDnVDG0BsX2Q/ahR5u8n71PMXosMs+s93wwf5n1mh1/ibgssrUGP7PPLzFOzeHZI899iy1Cuz8wutTAkM1lHwdGP83RxEbFGLoljF/vpB+ugzG/4OeKHzr2C31SLun7T8DHPumH8UlWCYO8bz+I7dfx1Q/p8znbxlzruVy/XcmHfuny/ujo+u7oON/LqBnXk7W9vhc/JQ5DBvSxXcmHnhnvjo/jKL2ZAo/tYbEMN9vj+jrry/YQPv3AWk3+yLb26L9mIDll0niSXZM/236kx6/JVE4/9N7q0ea5oPc6xmkSaiNjsD/8dYzDOCXH081zsfN1jFM2ZTxk8e45vz9AbqZCGe+nQn28O9TPHetc0/rtqfljg+ppkDJ+Ji+jvozR3u9Y7W937Kk5utQkrou9HqOqP9Ac9gPN4e83xyl19LI9d319GXYYo12t1arKltJ/s+zpOkSoZufjcB2HUapc1/F8iHydBr+S1PVlUrf+9jTfTr/51xdG60KeW6evL0RPTcJUTfLLHOZDjMNIff6yVffS9uD0pQa597hg483HheN9WHVKf27JvLwPP62CPmp14vpkB4bYh19r5+PaQnbs9b231zFOq0612rMPUZZfZ6Z+7JFRhuPtB+63GIcxKpwpTNrjexFGzUq3lvgY4TjC0RTa22u7+vFBsnpE1L8Zw2rt64n0vRjOFeO5h/x6fn36mR2PjMEPt5dPLeO08hR1M2sep6+ffEY7jY1a1HwOk71N+X6MeBd3xhhkr2P8wLPTePvZ6ZjNrw/k1M/9ngE/9u14+wn/3LOWa7z83NP83ugYjBiH0RGfEng9TFuND7peiHkxsz1fSK3StkZ+uJCTX7ACdD2gb0E+LJw/+nFDpNWGyL4q95Ug3bjWLPxBhyD6/nCnh/2x413QvdfhlS/He5yE/TIMeV3KdUxQfzFKiN5+hDoNtNbwbNycvuWa1mr20Xp/vB6s1P5Y1zyngTWR0kMKoON2k3iOVdZf1jz9Q5DDWL0+MFG7LC7fC3IV3+ZDtukpiP+Aa07bHDddc5qhjtoi72N7kPrNM/wDU1TiH5ijEr89SSX+gVlqvHz73jT1HOLWPPWTHxrMAIY/Xqf30w7U8ym/fnt9r0D4Lcg4TkbqJ89536b9sKfX/tisip3e597L43tZVfFUaMyvk9lpI+revvfxMrbf/8F6uIzTbyZrlbe0bUXo2ZdfCDK6Yfr/OASxU06V/L0buq+RfXT/aTtq1ExzbNOqJvqV63BcxzikstNKLg2rFa7Hlts/XslxOjPihZT83f3lsepDau787i/E0bvMWK/jvfjno3fPOzlWmzBPHuPVtKofpwC1Qs764MOV6GmhjLEupIffmW4/8It32pe6/Yt32pi6+Ysnjx/4xRN6+xfvGOLeyszpKSK8MK+C+uvdwrPxBuNXc8jBeMeNqWY1Xd1z/PO/fwii7/7ina+j1w4q7w8Bv13Hce6tVYR4bbi9nvGe9qaevxO1xPPYllY+1uSc9qbwRNMfrytR4oDy1+mMKomw7fuwHybep90pml9SX0+Jj+2Z5uNO2zmheW3VN9ofjD4mtNMOlVYtyF681vwLibXFGVlrd2lfSfztOo6DVbYlvMNPuP5EYtWfSKz6fmK1n0is9n5itbcT63GSx4ztpU6HmeJpS+b2M+8pP9+d0ZyKRjEFeG7aHR5pTr81z1xXo+zJ25PRB+PZ8UrwMPFLs/52JeO0GfoYtRk6tgn4x0Jcf7yfnU9bVTez82mn6nZ2Pm1V/VB2bvHKcK7BHR5a/TgPqM7hfSHvt1zk+gNZ0e0HsuJpv+hmVvTxA1lxPN7OiscQP5AVOzlKCA6Pvp9sOdVW4JCDfUd/376nfaub9j1tW92277Afse9xh1WqVFf1ZfH18dH3uX9fmdX3HYUPGcCPWyz1/o/rHuLXnwk+bV01cmSix+Pl/PscpKHs75dVp9+CnFLr3Rcd+jER1Rr86U2HQ4ibZfGP4zrAvXcdTrtWN192eJwS6s23He73ih165ebw6Ft7fHGMPQzzmdcPivwT70jxT7wkdb4dq6qE52/36XYOadW5phFPlJf5/ZMgtVJ7fR/+EMTeNy/52+al999pOb3qdNe8x12re+Zl/gHz3u6Vg3mPw6NVHeL1+e7Xw4OPs5l7ryuxvt+39gN96+/37amU+u4rS8cgN2u6+fiOzM2i7jhY/L2lxE8G2aMSWWvfTWRaZZnXt8heBzluOUlHoer+1qfz/eTeqTZYnj9Vh0lV+4GU2t5Pqe39lNp/IKX291Nq/4mU2n4gpZ6HR1W6Px91x+vhcX6N6t7wOG1Y3Rwe/f2sfHyJ6u7wGG8Pj9Ne1e3hcbtXvj08tuxh9L3pcqfK7H1fCvktyOn1kpuvr7P8wDiV98epvD9O5QfGqbw/TvUnxqn8wDg9j45byyCnhRTCi/Akr49Y4OMmlVqttrkdfvb10B4DFRGP/RnIb5+FolavQKltL6d0/9Ckpz0q4aqZE97H6fgwqTu+SOVVELXN15t+ML4eV6ccq1NbOcRv88LjddTw4D3Ex+s4bS/dXVjm05tU9xaW43WrdxeW+bRHdW9h+Rzi1sLy+VbYsWuw9cvvQY47VIx1lG7fDaLIQT6+GQSbINeBpK+DnHaorFa4rev3QuA0pyHfvAp6cO1hPvTQvacNqme6waLwvgE5vtKmeBNzPwPiix1TY5X2dYMvBfmRu6GaxBB1/6ZrjPCMe3LvcXvqJ4KQYglzL2f8WhCrRZ3nPPGQBE51ojddcwpx0zWDf8A1p/2pu+Ps2KYDmWjwoU2PEwCqxVhh49cTgNObVc8hgmM6trJZfsi3ZjPb3tLH2Ux8RuCwy+21LbRN7z5eR3sci6oU+37beWIfjrmL89lfz9ylfvOuDbaXMQ4ZQGvWrVuJ6XNH+0OI0ztRtffY9z3/30KcrqKW2mzfrPstxOl9f6+Dhp7bso9tbvfhRJrHMaluJ/9t46ONj0FOS0v1kun45QX3jyEOpkPFvG0by7+HOA4wlP7y1rUfBwcdYijVvKzxyxY9+s3gN3/99HAKgfdt1ft4bVnq7z+ANJJ3J/6N9P2Jfzttf9yb+Dfy9yf+7fgu1a2J/znErYn/+VZuTvzbaVvq7sT/kyD3Jv7nIDcn/u20L3VvCnMMcW8KcwxxdwrTTvtSN6cwn7TpvYn/J0HuTfyPQX7kbm5O/M+uuTlnj5dq/9Agdyf+5yA3J/7ttAdy0zXHl6Huuea4E3PXNaetqbvj7NimNyf+5x/emxP/djwu4wcm/vssQvvrWcQn5a33Jv7Ht6luTvy7vT/xP21P3Zz4n3anbk78j1dxb+J/egnq9sRf+Acm/qfzsW5O/E+bDzcn/sccVAVl+1uuX0tj9dbBMHk7E55CHKcg927kGOLejdycCJl8czno1o2cQ9y6kbuLUqcQx9XgezdyDHHvRm6uSZ9CnPf4DHt8/s19wnvHXbfThhT3esuf9+rPjzFO70zd3Ilun2xI3diJPoa4txPdjqvRNw/ePm0l3Tx5+/S+1N2d6Pu98non+jw62nCMDv1eDGGc2dhen79tx6d0qUnc0PHNGPVO/DHG2S23yi3bJwf73RnppxA3R7q/f9RiO74ndeesxfNV3PSbv13Q305vSCnVu7S6lxX+5rf7QeSbQXr9wGnfzvb7Lcigt/vleC/18soTv3svXFNrZeHvBqkDQnQvov9akFa1p9r2Y0Z+a9XTmWkPvNF38X5GSLsf5m6N8idB6gjt8Vze/GYQnBI2muo3g9z+GMAPVEv3x9vV0ufrwDP69WnBw3XcDbI/yH0tSP3QXJ/f+14QemDD4Mn2Osy5i6US29gnEl8cbI7Btvv4a0FqffsZ5GDA+7/hL2sv+2lbymoFxexQr3ic/9/6Kkk/vS91txT1HKTXvfQ+6BDkeKR/HY7F1g93o28/RXSyd+dWxxD35lad3v98T+e3v9/Tmd5/irjfK3bolePoqEduNu/fitEw1p8/ePbdGI+3YzRMrvY89rUYilVcfx3jtCt184nokxi3nojO99IxyLr6+zG+OcYaD7zF6q/7tp1X+atY2fjguuOFGA5ONX2dCpu837nnGD/QuUa4l4NxT6850aMO1SLatti/2KgDn505jLL+9jlUvR+Po5a6l2Gvn86O19GxMbZ/HOm35jj9Zku949zlcK5uPx3vd3Plr//Au1L9/Xel+vvvSvUfeFeqv/+uVP+Jd6X6D7wrdR4d91b+zjHurfz14zz5Zho7j/Rbq3b9/Tel+vtvSvXjm1L3Vu26vPuFlP4D72t1ffu103480O/2gswxzN2HynOQm8/I5yB3Pzd3DnJvaeiTNrm3NHQOcndpSH/g62jd3j6F+nwdd5eGbgc5LQ2dg9xcGjoFub809Mk4ubeq84X0/Hpyd3oX5daCzHlOhQ9p9T3G1xZTpE6R7nJaTLHjh5DvnaXTj+f63TxL53g7+2ukfPhqQj+e7Hf7dvoffTso1JX9y2+/347+kSNNtGbvYnJYtjttafT6KEbn/fOoH9v0/e+jHq+iIuzPMr9dxWmzqjOeZXib0uj9EPRwrcrYh3v/XpDh26vK22FrXwlyHX1XT7uPbSvxK41ap673ceja00L5D4R4NmRV1z9ZXt7KJ0Fu9oz+RM/oD/TM0bmGtwW4v04gctqnuvtdDXm0d717vg4sMtEY/XAdxyBjeyWFvhnEGz5G90uzfgxi7//MyPFkv5s/M8fbufvxBTl9jorU+vZJcHn1DafPgtz6goOcjva7+wUHoWNh1b0vOMiplPvukbpyWkq8+wKUnHZF7r0AJad9prsvQMnxwNRbL0CdQ9x6Aeo8Qm4eiS98fNPvzpH4x+u4eyS+8DGz3jsSX/gnRir/xEjl90cq/8RI5fdHKv+xI/Xu8eByOtvv7vHgcjrb7/YIOW1Y3R4hp7dsbo6Q45nad0dI07dHyDHEvRFy+vG+e3z0J0HqteVnkMMM4PhFqrsTmv5HLwMoFvJUD0dZn4NYzYr09AXGcxCtQaLOrze+5Lw9crdh9Y9uWK8X/tT1dDvH06CeS291P6O/nOR9EuTWlzHktHmlow4btU6vFzbk9DLV3S9jyPFlqntH68vpXap7+8Vy2ry6e7S+HE+Uu320/idhBMPkubXor1d8T0PWtGpoTPdTi3/r4+O7v7fKxeT4aap7W89yOvHv3qbeMcS9TT1Rfns7TbS9u50mp+P+7m493++V11vPn4yOW+Vixxg3y8U+i/F4O8a9aiCxx80tcPlem94sW/skxq2yNTm9YHWzsumTGLdKAs730utXpu3vWfx2HfpHX8et8rn7Mb7puZvlc3I8Zu9m+dwng/3mAHn8wR1zr/RNTptWd0vfPrmQW6VvctqzujmVOb1ldbf07Xgd90rfPpuoGmbvzw3wVxPV02ekbs92T0HubVydp6nWqRzTXw/U8f7XfWS8/XWfY4ib86Dx/td9ZLz9MqCMH/i6z/1eOeXk40NM/WY/t1lezh30QT+QCk9PMepVCqg+Dk8xx5N6aoA8kb4XhB6Pem7ox+epY1ViQ7mJfv+hDIdBP9m+/VBWd3Q9oOkhzLlYE+1C+s126XXcN/f9M+q/BWlvZ3g5Pw49kAb8W9Zhwkf+6PWvt9Lbz/9K/f0fTaUfaNJj1+LEn74vVn1tyBNjB53at9ch4nsTKwzrt52DAxWvkPq95Yxf3rdu/bACd1oTqVO7cDO9fW2b1rZt2lcFDsrtD97rvb3/fd7r3QxM39zrtVHfDPbHntI+BNHTztVzyaT2FHR/A/0L27TYU2Tu/M293pvH1MVXQf7QIHfPujsHuXnWnR73rm6ddXcMce+su2OIu2fd6Wnb6eZZd8ftbyJU9Dx5q+t9Lvl+uBR/KxWdm/TW+UrnELfOV7rbsSbftFyc9rw2abevdH8tyM2TXfVU3nxzdBxj3D1x85Mg+JT7fqjH14LcPIT0HOTmYbefBLl32O0nt3PvsFs9bVndTGWnEDdTmdAPpDL5owfrzcNuzw1yLxEdQ9xLRDe75RDis8LTKn17cns1L/ssSN/2APVV9arqDxQnH4P8RLn27Rahn2gR+YkWkbdb5Pw2znYzj4e9/i7UZ2Ewh3iGObylZMdTs2+/G3QK81w1qkOX9tNI9QshUNmgQ+l7IQxXMV6GOB+jc7t3Pglzt3eOdc73e+cU5mbvHEPc651ziDu988nZXo86V3l/qeeLp4xVBeszyOsDwj75FvOtF+rV+e3VfPX27mr+McS91Xw9Hg54bzVfT/tF91bz9bRvdXc1/36vHD7qeBwd916oP8e490K9Dnp7g/WTGLd2FY5fHb/56VH+5Pfu3gvg5w9+33wB/Bzk5gvgn3y//N6725/czr13t8/fL7/5uvP9IIfXnT8Jcu9150/a5N57yp/k91vvKdvpS1X3Do47foy917q39722+EN9pJ0+VXVz49ke739G3R5vf0b9GOLeT5XR+59RN3r7PAujH/iM+v1esUOv6Nsbz0bvHz/1yXXcquK146eqbu3iGfn7u87H67i3i3dsjpsbo+cY9zZG7fT5n5tNetysurkxeryOe016TqZazeG6nbjy2yeu2488H34W5ubz4Sdh7j4fGo8/PMy9x8xziFuPmZ+EuPOYeXxL8ubnGuztx0Nr75+3Zu3tifcxxM3f3Pb+GVLW3j5vzfoPnLd2v1fse4Pj5tOhvf1waL2//XD4SYx7D4dvTws/S6Y3D2un95/HjjHuHqX1eP9p7HaM47Hk7z+LHV9rvH8oOb3/uH2+ktvnxz3eXz04xviBu7l97tvj/bEqP3BQ2u0Yh7EqP3BMmvzMKWmPH1h8sPfXHvTdk6tOv3MdVQjPufd+RNqHuZge3yKq7bLW+qvy/XOIXrUdv76882sIe7t4/9gYjxoanYxeN4YdF5bvvYpsp/eh7hbtnT6Wd69J2/lrLznF/uVAsnY/Qs0qdS+j+BjhtPghdRck+wdDW78fo+PYK+H2MoYdj/DbMumT9dXpPce6oXv7yscP2woqdlX2xcIPjWrObzv2GOKeY/395jh/rqomyE78cqP+3TF+jHBrjB9PL7g5xs8nINwc48eXqO6O8eOn0+vQTebty6ncvhBD8GaJyCHG8evN26t6z7Xi8dopp5egbjrlGOKeU46H/72fOH5tjm3p9WNzyHk9G+9gC57j+Lfzi+7G8Pdj7MdUfoxx3DCpD6KRbYflPddC78fwOmnnifLNGF4xxjbCfotxzoNV1ercvxujI4a8H6M9XsY4TaBEayH5uUQ3XsZQe79vjzFu9u05xr2+Pc3xW3x0ao51lvF+jM0vX4tRT8WNTb4XozUc1tUf34vRK5G1X84g/9J1aM2v2/50/u0Y+s0YA78u45vjozPe82/f7Fuc+vtE+2YMwvkL8t2+1XpFv6t903OKw1hPfXuMMTAP2j6p8EXvY0Pswe/HoG9fhyGGfi/GQHX/6Pb+dZxyYfuBvN5+IK+3H8jr/AN5nX8gr/MP5HX+gbzO7+f14xqQ1mtsXb1/a/7RBz7BOPwwDzrOT7dzhvz1/NRPB/3d3E+LA+ded8wDhwTtb138diGn6lOxDGKyHyvtH2IcH4Jw+MovB8nZhxinT4Y98CD12Lf2P8b45LULvDK1v1Tz290cm1W23347NOsxyNgOcHo9SI6F/c9dzMqqtm8z/vaUe4wiD0SR7fi2j1H8+GqN4XT5vYs/bryeamq2zw/sE5Hf7ub0inCrHwlp43WLnKrHxercwyfK92KMmszI2IqMvtYzVkng+eO3n9T5pSje8fDv8rpNxtvLwePt5WB6nJZhn3MYvN/zXK96sRbietwEptq+4ZcrMp+EqIE6WF+tPB47xQ134r+8HvyVrvVR9U5PPiwIu8q7y1znELeWufw0Rby3zPWF5uj+7UY1RJH+3SgyEMVer0C60dtdcwxxr2tOO1I/0jV7c/j4dtfg8W6MbybE8cBv1SB+neDp9At+LyOeQ9xKied7wReqaGh/HH6sHu9upRxDPH+sHqhBN+rfC4K1zCezfDMIXli2/a3nL4zXYaglGaf8TMdTbcaoUfJkse+FYcZ57G2r0eVm3wxC/M0gUm9Qs2y1gl8K8ryFSmqP/QHpQ5DTYwlT/Yozt93Cv1ZQ+PGl45vb9T5+4Iyd493gveVfv5jz2928+y7K+IHCg1MMQT76MHe+fx2Cs+XEtp+bjzF8vF2Xcg5x65dzPN6uSzk3RtWBibfxukEfxx+a2lbRvn8n47cgxyupHzx6vHpyPl+G1PxM949CfO1epJa9nptF8u0g2ycQxreD1HH/+sum6ocgp/dqvFwr4xTj7TKG8XYZw/iBMobxA2UMg9r7ZQx0eq2v91pF6PsX9+hjJqS3H6vOIe5lIHr7sercGlJjtIv5oTXG+60x3m4Npj+2NbTjI5n76xIfW+P0wtTN1jiGuNkabx91cpz8jPp16vunLD5OXM4xqp6jP35ZxPwYw9+fyo3Te0V3J0B0OuxMCedXyGEO9QPz0tH4J27meKJO9S/txyUSjw9Xclr+x7cKtpVu8y9chtaBuLQXkH+8DDpWgt79ZTgFGciF16fM0ar98YUg+qijrPaJw1eD1EsG2ugQ5Pgu7Paqo+5vO3xok35837omIM+nl/Y6yPF24vWyeTu2VxB8qU0cDeuHU0bHabfqR4L88mLufg70hzY5B9kPK93b5Lcgp2FPKCOgwd8Mgu2q51Do3wzSt1P694NkPwY5fZTq5ol253Zt9RVj3r988tuAtVNR5b23BOl4mtW9NcRjiHvbKsc7uTl3/6Q5bk7e5SdS9DhWu946DGP8wNeoxvtfoxrvf41q/MDXqMb7X6MaP/E1qvEDX6M6j457h2GM01bVzVdi6fh1jJtfYTgHufkVBjp/j/3eeRjnK7n5FQYax5+qu19h+CTM3U/jfRbm5scczi1z82MO5yA3P+ZA4/i+350DNo7uuXlmyTnGvTNLxmmP596ZJWH1w9bZrTNLjtdxt0mPXXvvYw6fjNW7H3P4JMzdjzl8FubmxxzOU5ttjbZ9d3ZUZ41sSem3hc3z1Lcug34pF//a1LdejKJ9seb7k/BDkE+eswxnIPvrrzmM8f7y1Xh/+WrIHxri5nrguUGr0uvZtv3QoP72Stw4fkkN5dH6OIzTYxBFgYW28c0gXh/JpP0R7WtBhmFL9EHfC3J3ZeJ8JdhYvWoSXtsu5lHvPoZ/EuXmc/gnUW4+iD+j+PtP4ue2HajYIvp2q9xL0Z+1yr0c/YUeOkWht9eQ52nn7y4iX4di/MAqMp1Oqhi1jmX7F28/fpXpGMStEoKPvSrgK0EG1bsbY/8G8G9BHu/vZX1yIYIPIsj45t1wpfznvsYhyIP5j72bhknFfiTK/8+F9D/2QrrjwxuP44Xo2xdyjnFrcvKM8fasgE4H3Q3dZif7Cw+/jbPx9jLlMcS9ZcrjuZ13lymPQW4uU9Kj9R9YpzyuZt1bp6TH6ei+mwuVzyD27krlOca9pcrr8yBvr1VeX/Z4d7HyGYPeX638Qt8cliuPg+TecuXzdt4/wo9O7zzcXq88Brm7Xqn0A+uVxyu5u155Wlv/wnrlOczt9cpPwtxdrzy2zN31ymOQu+uV+v7imoz31yuPMe6tV9JD3j63+hnD31+xPF/JzVY99+7NJcvzcL29ZHkOc3vJ8pMwd5csj9Oce0uW55nSnSVLOn2a6O7jo9pPPD4ej/a7+/h4qrhrWm/ttr1Z6StBnsO+KtUayTeD9HqLqf96/tpvjXIIYuy1bvKgQxB7e0p+DHHzhUz9gSn5McjtKbn9ROnAsYpQHa/r+ON11xyPWsehy88p2/4NavtKkFGniz+YvhnE6yWmX18r+Rjk4fwTmcB/4OUSOp+AaKhXU5PXnTxO/qv3O7vvJv69VfRHWsV+oFVOo5bxjNAe25td9KUgXg8r7cGHof84HiJ4u1VO72XdbpVjQhB8aODJ/dVnKek0au9PzY9ny0p9urTLdj8fz5Z9tsrp3bs4tD4fng6PguMn1gvGD6wXjB9YLxg/sF5Aj/fXC44TrvvrBeMH1gs+GSU11thOTyvHnVUyHLE47NtBHu8HsdpLbKavB/1xpvPL+od8s2HbVsa+r3F/MUiNtrZXnv52O6fvW938qsNnQe6tCT0+2YEf/7+L3L9dSfvDrwQOfO5u/kCQ7xqw8cCRfG6HNjn9eMUnitfaMB/Tkv3AQLltnm93j+EEqFNWIj4u/OEUW9of4X7/0TheSr3S0vwwUuj48tW95Rzi/gPLOccrubmc88lMyTBrG/56543PUbaqgjH4W1Fubnmdz3+4t68SXz94d55Ep/e4bs6TjjFuzpOOr6Tdnied9rzuzpOa/MA86X7fHNL0cZDc3Fc5vj11NzWenq5v76scg9zdVzk+59/dVzleyd19lfNT1+19lU8e3u5uiBxv6e6GyDHI3Q2RU8nyzVzvj/c3RI4xbm6IkDze/wUV+olfUHl/m+ncuzc3RM7D9faGyDnM7Q2RT8Lc3RD5ZMWuBv6Th7ycFRx3vtTqyKArysu1nP4TpWz97kdb6XX5NJ0KuW3Uacj+OLxhSsctK9FamhLdy2w/bG2enLy/YLq93n3NvO4HsaoZfi5RPV4HIZU/OsrzuemBceLfjWKGit/Bpyinrx7WrpXt+ytfijE6ytn8mzFm9d+8m/3M29+jnI4RvFntS6eXAJ8K+CQu/XKq2uO3azmdSVwNi+TW21ea9YHiy293Ta2zDZP3u/cU4+i+VltwTzPTN4M8V/8ryOM04E9fybo7RI5BCB+lI+r+zUuZmXNFcflulFZLObR/oeGLUQTn58t2fv5XoygeerbnhK/eUS3YUePTHZ32vu5mNtf3M9txD+52ZvM/fNg2nDnZxL7bKDfz0jHGzbx0s3NOMY7VBfcqYc4FCrde3tN3L+J8MtqtapzzmZl4wv/FuV86eFNxeqeO9s0gjjS/f739i6d34pMzD359O37aJ757BOgxyL2P0Z9D3PoY/Schbn2MXs47ux3LN49vdu4vQfp3gzCCtMMw48f778ecY9x7fyIeUv/IGDcXpM+NiuNmbH8o+VrP1IIl7w/AXwyyXcm3g3jtKj3x20FqDnEOcjw/+95vzPkI7jv5/ZOvAVSM56/2Nz8oUNt9g+1VVdPx6wr3fun87ZY4fjejjvAS++VkxC/EwMcqxOXxvRij6l+f+M3vd7jhOr77HRGvXn2G++53RLYthv7t9nDEeN0vx2+z4O3yLoN/IMb3vu/SsYjX90W8L8XASfXdTmOMjkt4tR32eByW8Pj0hlDXeh2165CXS6yfXMm9xUQ+bmXdWkz0u4fVHdYSjzHuLgLy8dtZPxLl9lLiOcrdpUQ+raLffOA+xrj5wH2McfuBm0/L33cfuM8NO7CSMfjUsD/i4uMG0k0Xf3YpN20s7+8J8A/4+BzktgVF/ugo940sP7EnwPL+nsAxxl0jy0/sCbD+wJ7AuWFvGvn41bdHvVIjv34/4+PAP21PCHvNG3mf8/nHIKcTp6xaVm3/BJV/4W7qEAOhB5/uxn7ibvyPvRuUAT/xezNHaVVVIq3r92IwroPtB2L445v3UkUp0mh88zrwUZD2+HabDrSpfDNGRwxth5Eq7+/GnWPcW/W+m1iPMfoP7Madf4Fv7sbxqSbldnI+1oTd3Y37JMrN3bhzlLu7cecod3fjPolyczfukzu6uRvHp/2ru3OKU4y7c4pTjPtzivGHD9u7u3HnRrmZl44xbualm51zzkv9/Xs5xrh5LzefQg8x/AdSrP9Ehm2PHxiqxyC3M+wnUW5m2HOUuxn2HOVuhv0kys0M+8kd3cyw7fF+hj3GuJlhjzFuZ9hGf/iwvZthz41yLyudY9zLSnc75xBDj4fo6fZR+G3hZfA3Y+g3YwxsvW4W/lKMjh3+vm0Cfy1Gw6t027fcvxaD8Hbh/vmTL8Wo8++eeLiOUym0K746fOrbY4yB0yn242y/FANHyI4Hvx+Dvn0dhhj6vRgDPxKj2/vX0V+PddH3+/Yc417fnmPc69vbMejb13Grb48xbvbt7es49G0/HWnBdVgIs+y74h+P927vF7OcY9wrRGmd/tgY94pZjm3a8AHoZo9Dmx4PJLzzKdnjZXRUw/R9pvr7Zej7S6TttJt1c4n0eDeCY8qF5eXdnGPUQQks+rpF7HQoPwveIxR5fC/IvbK8c4hbZXmfhLhTltffLh7tbxePtrfLetrbZT3HI0gf+0cCH/uP5IcNzk+i4N2PZ5T2MoodXyF5kCAMmX4vzM0xegxxb4yeQ9wZo6e3w0erDPbLwdtN2hdi1JP2Mwa9jHE6dPf+GPkkyt0xIj8zRuT9MSLvjxH53hj578//58//+td//Mvf/u1f//zvf/23v//f57/7ryvUP/765//xt7+s//d//cff/3X7X//9//0/+b/8j3/89W9/++v//pf/849/+9e//M//+MdfrkjX//anx/o//208H4j/aYzR//s//ak9//9ntzwfyp7/l8fzv9D8K8/x8/x7118hmn/nuaZ1/V/+7/91Xeb/Bw==","expression_width":{"Bounded":{"width":4}}},{"name":"__aztec_nr_internals__total_supply","hash":"14825801997775708703","is_unconstrained":true,"custom_attributes":["abi_utility"],"abi":{"parameters":[],"return_type":{"abi_type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"},"error_types":{"361444214588792908":{"error_kind":"string","string":"attempt to multiply with overflow"},"992401946138144806":{"error_kind":"string","string":"Attempted to read past end of BoundedVec"},"1998584279744703196":{"error_kind":"string","string":"attempt to subtract with overflow"},"3080037330898348111":{"error_kind":"fmtstring","length":132,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"4261968856572588300":{"error_kind":"string","string":"Value does not fit in field"},"4440399188109668273":{"error_kind":"string","string":"Input length must be a multiple of 32"},"6504742485148360234":{"error_kind":"fmtstring","length":40,"item_types":[]},"7564993426627941149":{"error_kind":"fmtstring","length":48,"item_types":[{"kind":"field"},{"kind":"field"}]},"7995966536718645961":{"error_kind":"fmtstring","length":61,"item_types":[{"kind":"field"},{"kind":"field"}]},"9791669845391776238":{"error_kind":"string","string":"0 has a square root; you cannot claim it is not square"},"9885968605480832328":{"error_kind":"string","string":"Attempted to read past the length of a CapsuleArray"},"10791800398362570014":{"error_kind":"string","string":"extend_from_bounded_vec out of bounds"},"11021520179822076911":{"error_kind":"string","string":"Attempted to delete past the length of a CapsuleArray"},"12469291177396340830":{"error_kind":"string","string":"call to assert_max_bit_size"},"12913276134398371456":{"error_kind":"string","string":"push out of bounds"},"13060541637244024094":{"error_kind":"fmtstring","length":98,"item_types":[]},"13450089406971132036":{"error_kind":"fmtstring","length":144,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"14990209321349310352":{"error_kind":"string","string":"attempt to add with overflow"},"15764276373176857197":{"error_kind":"string","string":"Stack too deep"},"16431471497789672479":{"error_kind":"string","string":"Index out of bounds"},"16792019527863081935":{"error_kind":"fmtstring","length":77,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"17154023812102399658":{"error_kind":"fmtstring","length":128,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"17803644318014042523":{"error_kind":"fmtstring","length":58,"item_types":[{"kind":"field"}]}}},"bytecode":"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","debug_symbols":"tb3dji27caX7Lrr2xYwg44d+lUbDULvVDQGC3FDbBzgw/O5nZpARg6vWmaysmrVvVN9eqoqRSXJEZpKRzP/80//8y//4j//9L3/9+//6t//7p3/+b//5p//xj7/+7W9//d//8rd/+9c///tf/+3vz3/9zz89rv9p8qd/bv/0p6Z/+md9/rA//bM9f/j8MeJHf8wfNH/w/NHmjz5/yPyh88czynj+8PljxA95zB80f/D80eaPPn/I/KHzx4wiM4rMKDqj6IyiM4rOKDqj6IyiM4rOKDqj6IxiM4rNKDaj2IxiM4rNKDaj2IxiM4rNKD6j+IziM4rPKD6j+IziM4rPKD6j+IwyZpQxo4wZZcwoY0YZM8qYUcaMMmaUMaPQ47F+0vrJ62dbP/v6Keunrp+2fvr6ueLRikcrHq14tOLRikcrHq14tOLRikcrHq94vOLxiscrHj/jEV0gCZpgCc+Y1C8YC9oj4RmW7IJnXL5+ubWEniAJmmAJz8gsF4wF16CfQAlXZL2gJfSE65ivs7gMMMESnpEbXzAWXEaYQAmc0BJ6giRogiVkZMnImpE1I18GaVf7XBaZ0BMkQRMswRPGgsswEyghI1tGtoxsGdkysmVky8iWkT0je0b2jOwZ2TOyZ2TPyJ6RL1O1qy8uWwVcxppACZzQEnqCJGiCJWTksSLz45FACZzQEnqCJGiCJXhCRqaMTBmZMjJlZMrIlJEpI1NGpoxMGZkzMmdkzsickTkjc0bmjMwZmTMyZ+SWkVtGbhm5ZeSWkVtGbhm5ZeSWkVtG7hm5Z+SekXtG7hm5Z+SekXtG7hm5Z2TJyJKRJSNLRg4PjgskQRMswRPGgvBgACVwQkvIyJqRNSNfHux8gSeMBZcHu11ACZzQEnqCJGiCJXjCWOAZ2TOyZ2RfGYm9J0iCJliCJ6yMxOORQAmckJFHRh4Z+fKgPC6wBE8YE9rlwQmUwAktoSdIgiZYgidk5MuDQhdQAie0hJ4gCZpgCZ4wFnBG5ozMGfnyoPgFPUESNMESPGEsuDw4gRI4ISO3jNwycsvILSO3jNwycs/IPSP3jNwzcs/IPSP3jNwzcs/IPSNLRpaMLBlZMrJkZMnIkpElI0tGloysGVkzsmZkzciakTUja0bWjKwZWTOyZWTLyJaRLSNbRraMbBnZMrJlZMvInpE9I3tG9ozsGdkzsmdkz8iekT0jj4w8MvLIyCMjj4w8MvLIyCMjj4w8VuT+eCRQAie0hJ4gCZpgCZ6QkSkjU0amjEwZmTIyZWTKyJSRKSNTRuaMzBmZM3J6sKcHe3qwpwd7erCnB3t6sKcHe3qwpwd7erCnB3t6sKcHe3qwpwd7erCnB3t6sKcHe3qwpwd7erCnB3t6sKcHe3qwpwd7erCnB3t6sKcHe3qwpwd7erCnB3t6sKcHe3qwpwd7erCnB3t6sKcHe3qwpwd7erCnB3t6sKcHe3qwpwd7erCnB3t6sKcHe3qwpwd7erCnB3t6sKcHe3qwpwd7erCnB3t6sKcHe3qwpwd7erCnB3t6sKcHe3qwpwd7elDSg5IelPSgpAclPSjpQUkPSnpQ0oOSHpT0oKQHJT0o6UFJD0p6UNKDkh6U9KCkByU9KOlBSQ9KelDSg5IelPSgpAclPSjpQUkPSnpQ0oOSHpT0oKQHJT0o6UFJD0p6UNKDkh6U9KCkByU9KOlBSQ9KelDSg5IelPSgpAclPSjpQUkPSnpQ0oOSHpT0oKQHJT0o6UFJD0p6UNKDkh6U9KCkByU9KOlBSQ9KelDSg5IelPSgpAclPSjpQUkPSnpQ0oOSHpT0oKQHJT0o6UFJD0p6UNKDkh6U9KCkByU9KOlBSQ9KelDSg5IelPSgpAc1PajpQU0PanpQ04OaHtT0oKYHNT2o6UFND2p6UNODmh7U9KCmBzU9qOlBTQ9qelDTg5oe1PSgpgc1PajpQU0PanpQ04OaHtT0oKYHNT2o6UFND2p6UNODmh7U9KCmBzU9qOlBTQ9qelDTg5oe1PSgpgc1PajpQU0PanpQ04OaHtT0oKYHNT2o6UFND2p6UNODmh7U9KCmBzU9qOlBTQ9qelDTg5oe1PSgpgc1PajpQU0PanpQ04OaHtT0oKYHNT2o6UFND2p6UNODmh7U9KCmBzU9qOlBTQ9qelDTg5oe1PSgpgc1PajpQU0PanrQ0oOWHrT0oKUHLT1o6UFLD1p60NKDlh609KClBy09aOlBSw9aetDSg5YetPSgpQctPWjpQUsPWnrQ0oOWHrT0oKUHLT1o6UFLD1p60NKDlh609KClBy09aOlBSw9aetDSg5YetPSgpQctPWjpQUsPWnrQ0oOWHrT0oKUHLT1o6UFLD1p60NKDlh609KClBy09aOlBSw9aetDSg5YetPSgpQctPWjpQUsPWnrQ0oOWHrT0oKUHLT1o6UFLD1p60NKDlh609KClBy09aOlBSw9aetDSg5YetPSgpQctPWjpQUsPWnrQ0oOWHrT0oKUHPT3o6UFPD3p60NODnh709KCnBz096OlBTw96etDTg54e9PSgpwc9PejpQU8PenrQ04OeHvT0oKcHPT3o6UFPD3p60NODnh709KCnBz096OlBTw96etDTg54e9MuDSheMBZcHJzwjq1zACS2hJ0iCJliCJ4wFlwcnZGTJyJKRJSNLRpaMLBlZMrJkZM3ImpE1I2tG1oysGVkzsmZkzciakS0jW0a2jGwZ2TKyZWTLyJaRLSNbRvaM7BnZM7JnZM/InpE9I3tG9ozsGXlk5JGRR0YeGXlk5JGRR0YeGXlk5LEij8cjgRI4oSX0BEnQBEvwhIxMGZkyMmVkysiUkSkjU0amjEwZmTIyZ2TOyJyROSNzRuaMzBmZMzJnZM7ILSO3jNwycsvILSO3jNwycsvILSO3jNwzcnpwpAdHenCkB0d6cKQHR3pwpAdHenCkB0d6cKQHR3pwpAdHenCkB0d6cKQHR3pwpAdHenCkB0d6cKQHR3pwpAdHenCkB0d6cKQHR3pwpAdHenCkB0d6cKQHR3pwpAdHenCkB0d6cKQHR3pwpAdHenCkB0d6cKQHR3pwpAdHenCkB0d6cKQHR3pwpAdHenCkB0d68LkW/yiiIi5qRb1IirTIiryoNKg0qDSoNKg0qDSoNKg0qDSoNKg0uDS4NLg0uDS4NLg0uDS4NLg0uDRaabTSaKXRSqOVRiuNVhqtNFpptNLopdFLo5dGL41eGr00emn00uil0UtDSkNKQ0pDSkNKQ0pDSkNKQ0pDSkNLQ0tDS0NLQ0tDS0NLQ0tDS0NLw0rDSsNKw0rDSsNKw0rDSsNKw0rDS8NLw0vDS8NLw0vDS8NLw0vDS2OUxiiNURqjNEZpjNIYpTFKY5RG+ZzK51Q+p/I5lc+pfE7lcyqfU/mcyudUPqfyOZXPqXxO5XMqn1P5nMrnVD6n8jmVz6l8TuVzKp9T+ZzK51Q+p/I5lc+pfE7lcyqfU/mcyudUPqfyOZXPqXxO5XMqn1P5nMrnVD6n8jmVz6l8TuVzKp9T+ZzK51Q+p/I5lc+pfE7lcyqfU/mcyudUPqfyOZXPqXxO5XMqn1P5nMrnVD6n8jmVz6l8TuVzKp9T+ZzK51Q+p/I5lc+pfE7lcyqfU/mcyudUPqfyOZXPqXxO5XMqn1P5nMrnVD6n8jmVz6l8TuVzKp9T+ZzK51Q+p/I5lc+5fM7lcy6fc/mcy+dcPufyOZfPuXzO5XMun3P5nMvnXD7n8jmXz7l8zuVzLp9z+ZzL51w+5/I5l8+5fM7lcy6fc/mcy+dcPufyOZfPuXzO5XMun3P5nMvnXD7n8jmXz7l8zuVzLp9z+ZzL51w+5/I5l8+5fM7lcy6fc/mcy+dcPufyOZfPuXzO5XMun3P5nMvnXD7n8jmXz7l8zuVzLp9z+ZzL51w+5/I5l8+5fM7lcy6fc/mcy+dcPufyOZfPuXzO5XMun3P5nMvnXD7n8jmXz7l8zuVzLp9z+ZzL51w+5/I5l8+5fM7lcy6fc/m8lc9b+byVz1v5vJXPW/m8lc9b+byVz1v5vJXPW/m8lc9b+byVz1v5vJXPW/m8lc9b+byVz1v5vJXPW/m8lc9b+byVz1v5vJXPW/m8lc9b+byVz1v5vJXPW/m8lc9b+byVz1v5vJXPW/m8lc9b+byVz1v5vJXPW/m8lc9b+byVz1v5vJXPW/k8SpF0BEmRFj01bBYZe9FIuny+iIq4qBX1IinSotLQ0tDSsNKw0rDSsNKw0rDSsNKw0rDSsNLw0vDS8NLw0vDS8NLw0vDS8NLw0hilMUpjlMYojVEaozRGaYzSGKUxUiMKlxZRERe1ol4kRVpkRV5UGlQaVBpUGlQaVBpUGlQaVBpUGlQaXBpcGlwaXBpcGlwaXBpcGlwaXBqtNFpptNJopdFKo5VGK41WGq00Wmn00uil0Uujl0YvjV4avTR6afTS6KUhpSGlIaUhpSGlIaUhpVE+7+XzXj7v5fNePo+yJ2tBragXSZEWWZEXjaTw+SQqKg0rDSsNKw0rDSsNKw0rDS8NLw0vDS8NLw0vDS8NLw0vDS+NURqjNEZpjNIYpTFKY5TGKI1RGiM1ojhqERVxUSvqRVKkRVbkRaVBpUGlQaVBpUGlQaVBpUGlQaVBpcGlwaXBpcGlwaXBpcGlwaXBpcGl0UqjlUYrjVYarTRaabTSaKXRSqOVRi+NXhq9NHpp9NLopdFLo5dGL41eGlIaUhpSGlIaUhpSGlIaUhpSGlIaWhpaGuVzKZ9L+VzK51I+l/K5lM+lfC7lcymfS/lcyudSPpfyuZTPpXwu5XMpn0v5XMrnUj6X8rmUz6V8LuVzKZ9L+VzK51F2ZR5ERVzUinqRFGmRFXnRWBQFWIuoiItaUS+SIi2yIi8qDSoNKg0qDSoNKo3L5/4I0iIr8qKRdPl8ERVxUSvqRaXBpcGlcfncNWgkXT5fREVc1Ip6kRRpkRWVxuVzv97Bi0KtRVTERa2oF0mRFlmRF5WGlIaUhpTG5XMfQb1IirTIirxoJF0+X0RFXFQaWhpaGloaWhpaGloaVhpWGlYaVhpWGlYaVhpWGlYaVhpeGl4aXhpeGl4aXhpeGl4a8QZrjLB4iTUo3mOd9NQYFMRFreipMebLhVKkRVbkRWNRFHktoiIuakW9SIq0yIq8qDSoNKg0qDSoNKg0qDSoNKg0qDSoNLg0uDS4NLg0uDS4NLg0uDS4NLg0Wmm00mil0UqjlUYrjVYarTRaabTS6KXRS6OXRi+NXhq9NHpp9NLopdFLQ0pDSkNKQ0pDSkNKQ0pDSkNKQ0pDS0NLQ0tDS0NLQ0tDS0NLQ0tDS8NKw0rDSsNKw0rDSsNKw0rDSsNKw0vDS8NLw0vDS8NLw0vDS8NLw0tjlMYojVEaozTK51Y+t/K5lc+tfG7lcy+fe/ncy+dePvfyuZfPvXzu5XMvn3v53MvnXj738rmXz7187uVzL597+dzL514+9/K5l8+9fO7lcy+fe/ncy+dePvfyuZfPvXzu5XMvn3v53MvnXj738rmXz7187uVzL597+dzL514+9/K5l8+9fO7lcy+fe/ncy+dePvfyuZfPvXzu5XMvn3v53MvnXj738rmXz7187uXzKEQbFiRFWmRFXjSSwueTqIiLWlFpWGlYaYTPOciLRlL4fBIVcVEr6kVSpEWl4aXhpTFKY5TGKI1RGqM0RmmM0hilMUpjpEYUqy2iIi5qRb1IirTIiryoNKg0qDSoNKg0qDSoNKg0qDSoNKg0uDS4NLg0uDS4NLg0uDS4NLg0uDRaabTSaKXRSqOVRiuNVhqtNFpptNLopdFLo5dGL41eGr00emn00uil0UtDSkNKQ0pDSkNKQ0pDSkNKQ0pDSkNLQ0tDS0NLQ0tDS0NLQ0tDS0NLI3w+gqiIi54a9HgEdqAAFWhAB47Cy+6JBGQg1BxqDjWHmkPNoeZQG1AbUBtQG1AbUBtQG1AbUBtQG6nGUSqXSEAGNmAHClCBBnQg1AhqBDWCGkGNoEZQI6gR1AhqBDWGGkONocZQY6gx1BhqDDWGGkOtQa1BrUGthRoHdqAAQ00CDejAUdgfQAIysAE7UIBQ61DrUOtQE6gJ1ARqAjWBmkBNoCZQE6gJ1BRqCjWFmkJNoaZQU6gp1BRqCjWDmkHNoGZQM6gZ1AxqBjWDmkHNoeZQc6g51BxqDjWHmkPNoeZQG1AbUBtQG1AbUBtQG1AbUBtQG6VGjweQgAxswA4UoAIN6ECoEdQIagQ1ghpBjaBGUCOoEdQIagw1hhpDjaHGUGOoMdQYagw1hlqDWoNag1qDWoNagxpyCSGXEHIJIZcQcgkhlxByCSGXEHIJIZcQcgkhlxByCSGXEHIJIZcQcgkhlxByCSGXEHIJIZcQcgkhlxByCSGXEHIJIZcQcgkhlxByCSGXEHIJIZcQcgkhlxByCSGXEHIJIZcQcgkhlxByCSGXEHIJIZcQcgkhlxByCSGXEHIJIZcQcgkhlxByCSGXEHIJIZcQcgkhlxByCSGXEHIJIZcwcgkjlzByCSOXMHIJI5cwcgkjlzByCSOXMHIJI5cwcgkjlzByCSOXMHIJI5cwcgkjlzByCSOXMHIJI5cwcgkjlzByCSOXMHIJI5cwcgkjlzByCSOXMHIJI5cwcgkjlzByCSOXMHIJI5cwcgkjlzByCSOXMHIJI5cwcgkjlzByCSOXMHIJI5cwcgkjlzByCSOXMHIJI5cwcgkjlzByCSOXMHIJI5cwcgkjlzByCSOXMHIJI5cwcgkjlzByCSOXMHIJI5cwcgkjlzByCSOXMHIJI5cwcgkjlzByCSOXMHIJI5cwcgkjlzByCSOXMHIJI5cwcgkjlzByCSOXNOSSNnOJBzKwATtQgAo0oANH4cwlE6FGUCOoEdQIagQ1ghpBjaDGUGOoMdQYagw1htrc55MCDejAS42uJ5QoOkwkIAMbsAMFqEADOhBqHWodah1qHWodah1qHWodah1qHWoCNYGaQE2gJlATqAnUBGoCNYGaQk2hplBTqCnUFGoKNYWaQk2hZlAzqBnUDGoGNYOaQc2gZlAzqDnUHGoONYeaQ82h5lBzqDnUHGoDagNqA2oDagNqA2oDagNqA2qj1KJ0MZGADGzAUOuBAlRgqFmgA0dh5JKFBGRgA3agABUINYIaQY2hxlBjqDHUGGoMNYYaQ42hxlBrUGtQa1BrUGtQa1BrUGtQa1BrUOtQ61DrUOtQ61DrUOtQ61DrUOtQE6gJ1ARqAjWBmkBNoCZQE6gJ1BRqCjWFmkJNoaZQU6gp1BRqCjWDmkHNoGZQM6gZ1AxqBjWDmkHNoeZQc6g51BxqDjWHmkPNoeZQG1AbUBtQG1AbUBtQG1AbUBtQG6UmjweQgAxswA4UoAIN6ECoIZcIcokglwhyiSCXCHKJIJcIcokglwhyiSCXCHKJIJcIcokglwhyiSCXCHKJIJcIcokglwhyiSCXCHKJIJcIcokglwhyiSCXCHKJIJcIcokglwhyiSCXCHKJIJcIcokglwhyiSCXCHKJIJcIcokglwhyiSCXCHKJIJcIcokglwhyiSCXCHKJIJcIcokglwhyiSCXCHKJIJcIcokglwhyiSCXCHKJIJcIcokglwhyiSCXCHKJIJcIcokglwhyiSCXCHKJIJcIcokglwhyiSCXCHKJIJcIcokglwhyiSCXCHKJIpcocokilyhyiSKXKHKJIpcocokilyhyiSKXKHKJIpcocokilyhyiSKXKHKJIpcocokilyhyiSKXKHKJIpcocokilyhyiSKXKHKJIpcocokilyhyiSKXKHKJIpcocokilyhyiSKXKHKJIpcocokilyhyiSKXKHKJIpcocokilyhyiSKXKHKJIpcocokilyhyiSKXKHKJIpcocokilyhyiSKXKHKJIpcocokilyhyiSKXKHKJIpcocokilyhyiSKXKHKJIpcocokilyhyiSKXKHKJIpcocokilyhyiSKXKHKJIpcocokilyhyiSKXKHKJIpcocokilyhySZR5Phc8AgnIwAbsQAEq0IAOHIUENYIaQY2gRlAjqBHUCGoENYIaQ42hxlCLXHJ9VYSj/DNRgKEWDRW5ZKEDL7V2TZ1EEWgiARnYgB0oQAUa0IFQ61DrUOtQ61DrUOtQ61DrUItc0qJ1IpdMjFyykIAMbMAOFKACDQg1gZpCTaGmUFOoKdQUago1hZpCTaFmUDOoGdQMagY1g5pBzaBmUDOoOdQcag41h5pDzaHmUHOoOdQcagNqA2oDagNqA2oDagNqA2oDaqPUopQ0kYAMbMAOFKACDehAqBHUCGoENYIaQY2gRlAjqBHUCGoMNYYaQ42hxlBjqDHUGGoMNYZag1qDWoNag1qDWoNag1qDWoNag1qHWodah1qHWodah1qHWocacokjlzhyiSOXOHKJI5c4cokjlzhyiSOXOHKJI5c4cokjlzhyiSOXOHKJI5c4cokjlzhyiSOXOHKJI5c4cokjlzhyiSOXOHKJI5c4cokjlzhyiSOXOHKJI5c4cokjlzhyiSOXOHKJI5c4cokjlzhyiSOXOHKJI5c4cokjlzhyiSOXDOSSgVwykEsGcslALhnIJQO5ZCCXDOSSgVwykEsGcslALhnIJQO5ZCCXDOSSgVwykEsGcslALhnIJQO5ZCCXDOSSgVwykEvGzCUc6MBROHPJRAIysAE7UIAKhFqDWoNah1qHWodah1qHWodah1qHWodah5pATaAmUBOoCdQEagI1gZpATaCmUFOoKdQUago1hZpCTaGmUFOoGdQMagY1g5pBzaBmUDOoGdQMag41h5pDzaHmUHOoOdQcajOX9MBROHPJxFDTQAY2YAcKUIEGdOBY2Gbd60ICMrABO1CACjSgA6FGUCOoEdQIagQ1ghpBjaBGUCOoMdQYagw1hhpDjaHGUGOoMdQYag1qDWoNag1qDWoNag1qDWoNag1qHWodah1qHWodah1qHWodah1qHWoCNYGaQE2gJlATqAnUBGoCNYGaQk2hplBTqCnUFGoKNYWaQk2hZlAzqBnUDGoGNYOaQc2gZlAzqDnUHGoONYeaQ82h5lBzqDnUHGoDagNqA2oDagNqA2oDagNqA2rIJYRcQsglhFxCyCWEXELIJYRcQsglhFxCyCWEXELIJYRcQsglhFxCyCWEXELIJYRcQsglhFxCyCWEXELIJYRcQsglhFxCyCWEXELIJYRcQsglhFxCyCWEXELIJYRcQsglhFxCyCWEXELIJYRcQsglhFxCyCWEXELIJYRcQsglhFxCyCWEXELIJYRcQsglhFxCyCWEXELIJYRcQsglhFxCyCWEXELIJYRcQsglhFxCyCWEXELIJYRcQsglhFxCyCWEXELIJYRcQsglhFxCyCWEXELIJYRcQsglhFxCyCWEXELIJYRcQsglhFxCyCWEXELIJYRcQsglhFxCyCWMXMLIJYxcwsgljFzCyCWMXMLIJYxcwsgljFzCyCWMXMLIJYxcwsgljFzCyCWMXMLIJYxcwsgljFzCyCWMXMLIJYxcwsgljFzCyCWMXMLIJYxcwsgljFzCyCWMXMLIJYxcwsgljFzCyCWMXMLIJYxcwsgljFzCyCWMXMLIJYxcwsgljFzCyCWMXMLIJYxcwsgljFzCyCWz7vX6PG6bda8LGXipdQrsQAEq0IAOHIWRSxYSkIFQM6jNXCKBCjSgA0fhzCUTCcjABuxAqDnUHGoONYfagNqA2oDagNqA2oDagNqA2oDaKLVZ97qQgAxswA4UoAIN6ECoEdQIagQ1ghpBjaBGUCOoEdQIagw1hhpDjaHGUGOoMdQYavMb9y1wFM7v3E8kIAMbsAMFqEADQq1BrUMtcolwIAMb8FKT+bsCVGCo9UAHjsLIJQsJyMAG7EABKhBqAjWBmkJNoaZQU6gp1BRqCjWFmkJNoWZQM6gZ1AxqBjWDmkHNoGZQM6g51BxqDjWHmkPNoeZQc6g51BxqA2oDagNqA2oDagNqA2oDagNqo9Rm3etCAjKwATtQgAo0oAOhRlAjqBHUCGoENYIaQY2gRlAjqDHUGGoMNYYaQ42hxlBjqDHUGGoNag1qDWoNag1qDWoNag1qkUt4BI7CyCULCcjABuxAASrQgFDrUBOoCdQEagI1gZpATaAmUBOoCdQUago1hZpCTaGmUFOoKdQUago1g5pBzaBmUDOoGdQMagY1g5pBzaHmUHOoOdQcag41h5pDzaHmUBtQG1AbUBtQG1AbUBtQG1AbUBulNuteFxKQgQ3YgQJUoAEdCDWCGkGNoEZQI6gR1AhqBDWCGkGNocZQY6gx1BhqDDWGGkONoRa5RC7Pz7rXhQSMOwULbMAOjDsFD1SgAR04CiOXLCQgAxuwA6HWodah1qHWoSZQE6gJ1ARqAjWBmkBNoCZQE6gp1BRqCjWFmkJNoaZQU6gp1BRqBjWDmkHNoGZQM6gZ1AxqBjWDmkPNoeZQc6g51BxqDjWHmkPNoTagNqA2oDagNqA2oDagNqA2oDZKbda9LiQgAxuwAwWoQAM6EGoENYIaQY2gRlAjqBHUCGoENYIaQ42hxlBjqDHUGGoMNYZa5BJtgaMwcsnCS+3adr/NuteFDdiBAlSgAR04CiOXLIRah1qHWodah1qHWodah1qHmkBNoCZQE6gJ1ARqAjWBmkBNoKZQU6gp1BRqCjWFmkJNoaZQU6gZ1AxqBjWDmkHNoGZQM6gZ1AxqDjWHmkPNoeZQc6g51BxqDjWH2oDagNqA2oDagNqA2oDagNqA2ii1Wfe6kIAMbMAOFKACDehAqBHUCGoENYIaQY2gFrnEONCADrzUrm2g26x7XUjAS800sAE7UIAKNKADR2HkkoUEhFqDWoNa5BLvgQo0oANHYeSShQRkYAN2INQ61DrUIpdcu+a2Wfc6MXLJwkttRFNHLlnYgJfa8EABamGM3xEUvzrx+at87RnVotQy0YAOHIlRaplIwH4hBwpQgQZ04CikB5CADGxAqBHUCGoENYIaQY2hxlBjqDHUGGoMNYYaQ42hxlBrUGtQa1BrUGtQa1BrUGtQa1BrUOtQ61DrUOtQ61DrUOtQ61DrUOtQE6gJ1ARqAjWBmkBNoCahJoEOHIX6ABKQgaE2AjtQgAq81CjG73XRS7zUrj0JWhRVJhKQgQ3YgQK81K7XsFsUVSY6MNSuvBRFlYkEDLU4Xm/ADhSgAg14qXELHIXXRS+RgJcax5FdSSOxAy+1Fg0VWWOhAS+1NoONxCiqTIyzsMAr7lWM1aJQkmMhKAolOZZ8olByYeSHhQRkYANecWNqOwolExVowEst5raiUHJh5IceBxn5YSEDG7ADBXipCQUa0IGjMPJDzLRHoWTipRbT61EomdiBAgy1EI78sNCBozDyw0ICXmoahxP5YWEHCvBS0zjIyA8LHRhqlyGjUDKRgAqMCHEW4W6NQRBb8QdwQku4jiluPaLAMVGBBnTgKAxfW5x2+Hrh1QIWAyh8vbADL4nrmwstqhoTHTgKw8wLL4m41kdVY2IDdqAAFRhqcfJh5oWjMMy8MNTieMPMCxvwUhtxZGHmhQq81OLOIqoan6uFgZfaePZYj6rGRAIysAE7MOJ6oANHYVh8IQG58PLfc5ExsAH7hRxoF/ZAB47Cy2mJBOTCHv8ax9sZ2IAdKEAFGtCBo1AeQKgJ1ARqAjWBmkBNIq5eqBHBAiPCCOxAAV4RrutdjxK+RAeOwsstiQS84lJ0gEWE6ACLCHFkNgr9AYwI0dSXGRIbsAMFqMBQizN2B4ZanPx4AAkYcWMYjYgQ7TAcGBGeY71HqV27XtTrUWqXyMAGvOIyBQpQgZcac6ADRyFBjaBGUCOoUQdK9kWU2iUa0IHVm1Fql9iyC6N8bnZhlM/NzoryucTqzSifm30R5XOJDGzADhSgZr9F+VyiZ2dF+dzC/gC27MIoiZv9FiVxiV5dGH6bDSVoX0H7Cto3/DY7S9Cbgt4Mv83OEvSmoDcFago1hZpCTdGbYQaOJgkzLGzAOJxonTDDQgUa0IGjMMywkIAMvNRaHE5YZKEAFWhAB15q111cj7qyRAIyMNQksAMFGGoaaEAHhto1HqKuLJGADAw1D4y4I9CADhyFYZGr3qdHBdlzXTXwinvdM/aoIEvsQAFeaj3OOOy00IGjMOzU49zCQz2ONzzU43DCQxKHEx6S+WcKNKADR2F4aCEBLzWJVg9nLQy1EI7r20IFGtCBozD8ptEO4beFDGzAS03jcMJvCxV4qWkcWfht4SgMv2l0d/hN4xjCbwsbsAMFqMArrkV3x1VvIRWGTS2Ew6YLr7gWXRg2XahAAzpwFIZNFxKQgQ0YanHGYVOLARM2XWhAB47EKNlKjLgj8Ipw3bL2KMN6zikEOnAUhvWcAwnIwAbsQAGGWg80YKhJ4CgMQy6MuBoYESzQgBGBAkc2VJRWJRKQgRE3miT8tlCA1ZtRWpXoQKh1qHWodaiF3yaGA0a0ejhgoQLDbyERDlg4CsMBCwnIwEttRJOEAxYKUIEGdOAovJ6S2ogutAbsQAEq0IAOHIVxj7iQgFBzqDnUHGoONYeaQ82hNqA2oDagNqA2oDagNqA2oDagNkotypoSCcjABuxAASrQgA6EGkGNoEZQI6gR1AhqBDWCGkGNoMZQY6gx1BhqDDWGGkONocZQY6g1qDWoNag1qDWoNag1qDWoNag1qHWodah1qHWodah1qHWodah1qHWoCdQEagI1gZpATaAmUBOoCdQEago1hZpCTaGmUFOoKdQUago1hZpBzaCGXNKRSzpySUcu6cglHbmkI5d05JKOXNKRSzpySUcu6cglHbmkz1zSAw3ohTOBUCABGdiAHShABRrQgZV05fEAEpCBDdiBAlSgAR0INYIaQY2gRlAjqBHUCGoENYIaQY2hxlBjqDHUGGoMNYYaQ42hxlBrUGtQa1BrUGtQa1BrUGtQa1BrUOtQ61DrUOtQ61DrUOtQ61DrUOtQE6gJ1ARqAjWBmkBNoCZQE6gJ1BRqCjWFGm47BLcdgtsOwW2H4LZDcNshuO0Qg5pBzaBmUDOoGdQMagY1g5pBzaHmUHOoOdQcag41h5pDzaHmUEMuEeQSQS4R5BJBLhHkEpm5xAIN6MBQu27zdeaSiQQMNQ9swA4UoAIN+FTrMQ0btUwLr1ySSEAGNmAHClCBBoQaQY2hxlBjqDHUGGoMNYYaQ42hxlBrUGtQa1BroUaBHShABRrQgaF2XXGilimRgKEmgQ3YgQKMuNcjQdQn9ZgrjvqkxAaMCDE0RIAKvI435hGjPilxFF75IfFSi4nGqE9KbMAOjLjRfBYRWiABGRjHGxLWgQJUoAEdOAo91KJ1nIAMjOONlvQOFKACDejAUTgeQAIyEGoDaiPUoodGqIX1hgEdOBKj5iiRgAxswA4UoAIvtZgYjZqjxFEYno8Z2ag5SmTgpXYtOPeoOUoU4KXWZjADOvBSu/b56FFzlEjASy3mHKPmKLEDL7WY5Iuao0QDXmp9BhuF4fmFl1pM0UXNUWIDXmryCBSgAkedcfg4JpOjjiixAwWoQANexxvThFFHtPC6J0i8jjem/qKOKLEB43gjWHh+oQJjnM3fdeAoDHfHPGLslJfYgQJUoAEdOAojEywkINQMagY1g5pBzaBmUDOoOdQcag41h5pDzaHmUHOoOdQcagNqA2oDagNqA2oDagNqA2oDaqPUonwrkYAMbMAOFKACDehAqBHUCGoENYIaQY2gRlAjqBHUCGoMNYYaQ42hxlBjqDHUGGoMNYZag1qDWoNag1qDWoNag1qDWoNag1qHWodah1qHWodah1qHWodah1qHmkBNoCZQE6gJ1ARqAjWBmkBNoKZQU6ghlzhyiSOXOHKJI5c4cokjlzhyic9cooEEZGADdqAAFWhAB4badQ3wmUsmEjDULLABO1CACjSgA0fhzCUTCQi1AbXIJVc9T4+irkQFXmrqgQ4ciVHU1WPhJHa/e973ByrwinDVAPco6kochZEfFhKQgdfxxkR5FHUlClCBoRZHFvlh4SiM/BBrHVHUlcjASy1WQKKoK1GACrzUYp0hirp6rItE+VaPpYwo30pswA6MuBoYceMsIhN4HE5kglgEiPKthZEJFhLwUouHwSjfSuxAAV5qI4437B8zWlGz1aNSJ2q2ejw4Rs2WxA1ybG6X2IAdKEAFGtAvjGO47L8wPK8TGdiAHShABRrQgaMwPL8QagY1g5pBzaBmcULRZmZAB8YJRUtenk8kIAMbsAMFqEADOhBqA2oj1KLfBgMbsAMFqMBLLR7EovYrcSyUqP1KvNSuJzWJ2q/EBrzUrhtDiR3t5HqEkdjRLjHUNNCBoWYX0gNIQAY2YAcKUIEGdCDUGGoMNYYaQ42hxlBjqDHUGGoMtQa1BrUGtQa1BrUGtQa1BrUGtQa1DrUOtQ61DrUOtQ61DrUOtQ61DjWBmkBNoCZQE6hFArkeMiVK3BIN6MC8DknsaJdIQAY2YAcKUIFWaHEWI7CtS51E4Ztc9TsSu9QlKtCADhyFkR8WXu3AYSdH+zrO2HHG4fmJ4fmFV/ty+C08v7ABOxC9OaA20JsDvTmqN+nxABKQ8xhoen5iBwpQ8xiiHC7RgVCD5wmeJ3ie4HmC5wmeJ6qxQ2RAB1ZLRjncOgYmIAOhBs8TPE/wPMHzBM8TPE+t+o2m5yeiJRtaslW/RelcIloSnid4nuB5gucJnid4nuB5guepo986WrKjJTtasqMlw/PXZIZEmV1itGQPbMAOFGCcWxxDeH6hA0ehPoAEZGADhlocpAowPB8tqSNdGHvMyfUGvMQec4kMbED0kKGHDD1kGOuGsT4zQaBj9Dl6yNFDjh5y9JBj9CFrkGM8OMaDYzxEfrhq9iSq/hI78Irboh0iP7Q4ssgPCx04EqPqL5GADGzADoy4LdCBozAywUICMrABO1CACoQaQY2gxlBjqDHUGGoMNYYaQ42hxlBjqDWoNag1qDWoNag1qDWoNag1qDWodah1qHWodah1qHWodah1qHWodagJ1ARqAjWBmkBNoCZQE6gJ1ARqCjWFmkJNoaZQU6gp1BRqCjWFmkHNoGZQM6gZ1AxqBjWDmkHNoOZQc6g51BxqDjWHmkPNoeZQc6gNqA2oDagNqA2oDagNqA2oDaiNUmuPB5CADGzADhSgAg3oQKghlzTkkoZc0pBLGnJJQy5pyCUNuaQhlzTkkoZc0pBLGnJJQy5pyCUNuaQhlzTkkoZc0pBLGnJJQy5pyCUNuaQhlzTkkoZc0pBLGnJJQy5pyCUNuaQhlzTkkoZc0pBLGnJJQy5pyCUNuaQhlzTkkoZc0pBLGnJJQy5pyCUNuaQhlzTkkoZc0pBLGnJJQy5pyCUNuaQhlzTkkoZc0pBLGnJJQy5pyCUNuaQhlzTkkoZc0pBLGnJJQy5pyCUNuaQhlzTkkoZc0pBLGnJJQy5pyCUNuaQhlzTkkoZc0pBLGnJJQy5pyCUNuaQhlzTkko5c0pFLOnJJRy7pyCUduaQjl3Tkko5c0pFLOnJJn7mkBzKwATtQgAo0oANH4cwlE6HGUGOoMdQYagw1hhpDjaHWoBZzmXEXHwWWiQ3YgQJUYKhpoANH4cwlFkhABjZgBwowzs0DL7X+CHTgKIxcspCADGzADhSgAqEmuS4tUWC5MGYlFua6tESBZWIDxrp0BItZiYUKNKADR2HMcC4kIAMbEGoGtcgaPY438kOPLoz80GM8RH5Y2IECjAjRseH5Hj0Unl/YgB0oQAVG+45AB47EqIlMJCADG7ADQ00CFWhAB0b7XucWNZGJBLzUrtV1iZrIxA4UoAIN6MBRGJ5fSECoMdQYagw1hhpDjaHGUGtQa1CL+4foTYn7h4UdKMBQ48CRXRjVj4kEjLNogQ3YgXEW0b5d8WcGdCDUBGoCNWFgA3agAKEmkIgbAYnxEDcCCxswDn3+rgAVaMDoAA8chXEjsJCAoRaDNi7515qaRBljogGvuBr9Fpf8iXHJX0hABjZgB4Za9GZc8hca0IGjMC75CwnIwAgWHRs+vl7gkqhHTCQgAxuwA+MgLVCBBnTgKIxr90ICMjDUPLADBahAAzpwZLdEPWIiARkYY0cDLVsnyg0TR2HYdGEEG4FokjDkQgVecS3U4iK8cBSGTY0C0QEdHdDRAR1qHWodamHThQ5Edwu6W6AmkIjKgVhAWjWGE+PQJ47CuF9fSEAGNmAHXodu0ZJh04UGDLU4nLDpxLDpwlBrgQxswKiimyhABRrQgaNw1iNOJCADGzDqHGMYRY3AwjiLiaMwbLqQgAxswA6MNosBHj5eaMBQizEZ7g6MysPEULNABjZg1HBOFKACDejAUTirjScSkIENeJ3FtZYvUWOY6MDrLK4Vfokaw0QCXmdxvc0oUWOYeLXZVQ0gUWOYqMBQ64EOHIVh9IUEZGADhpoEClCBBnTgKIx3FDyaZL6WGJ0VbyNcbz5KVB4mKtCADhyF8TbCwqvOPIZRVB4mNmAHhlp0QLyNsNCADhyF8TbCQgIysAGjdUItPL/QgdE60STh+YUEjL6IcwvPL4y+iOaLC/ZCBV5qI44hLtgLR2FcsBcSkIENeKmNGIhxwV6oQAM6cBTOjTLiyOINA5r/evUFTxSgAg3owJHoc/uMiVdfxAKHz+0zJjZgB15qNFGBBnTgKIy3lRYSkIENWD3vZEAHVs87P4AErJ53bsDqeWcBKrB6PqoJE6vno5owkYAMbMDq+agmTFSgAR1YPe+9et579XzUDa5+6wJUoAEdiJ4X9Lyg5wU9L+h5Qc8Lel7Q84KeF/S8oOcVPa/oeUXPK3o+PD8mGtCBozA8f9VHSVQIJjKwAa+ziAtKVAgmKtCADhyF8a7RQgIyMPo4hud090QDOnAUxnV+4TOuPmLsXNf5xAbsQLkwuvDyfKIB/cJoqMvzE6MWMDHUemCoSWCoaWAHClCBBvRCij+zQAHGn3mgAePPRuBYe9PJ3NVtIQEZ2IAdeMWlwMumGm6ZO7XFLODcqW1hA0aEaJLYqW2hAg3owFHYQ20iAa9Gjfu+KPVL7MA43uiA2H0tJqGikm81iTCwATvwat+o0YpKvkQDon1lFOoDCDWFmkaw6Dc1oAOvYJFAomYvkYAMbMAOvA6d4yAvFyYa0IGhFoPLH0AChlqMqOvKq7MlrytvogAVaEAHjsLLm4kEvNRmz4c3F4ZadGx4c6ECDRhqcejhzQs1avYSCcjABuxAAYaaBRow+s0DQy2QHkACMrABQ2IEKtCAl8Q1y6pRqLfw8nHiJXG9j6NRqJd4SVwTmBqFeokCvNSuWUuNQr1EB47C8PxCAjIw1CSwAwWoQAM6MNTowunuOLfp7viF6e6JAlSgAR04CuWxkqM+ZiaYyMAGDLU4nJkJJirQgA4chfoAEpCB0ToxuCIpLDSgA0dhJIUeQyOSwkIGNmAHCvBSkxgEkRQWOnAURlKQ6ONICgsZeKlJtG8khYUCDLVwSyQFifaNpCBxOJEUJkZSWEhABjbgdYMRhxB345O8aCyaO9lNoqRw5TX9pFFVl9iAcWcWJEVaZEVeNJLChNc0okaNnOr811gTCrIiL4pJj4vinZpJVMRFragXhUgLVODV1hpnGy5bOArDZdd8k0a5m16bjmqUuyXGVENQBLDAURh2WkhABrZsEqnmlGpOqeaUak6p5gzLzEa8Zq1WI4ZlrilGjdq1xDjVEejA60gtjn9WsQZRERe1ol4kRVdECwwDWBxIGGD+YyvqRXFvFqRFVuRFIykG/qQQiS6Mcb/wUrHot7gYLhRgHObVm1GAptdMgkYBWmLcsAf1bJjYdS5RgQaMsBY4CuP6tpCywXk6aWIDQo2gRlAjqBHUCGoMNYYaQ42hxlBjqDHUGGpxqVs41lCPorQ5fKMoLZGBDdgL4+JkcQhhpoUKvMZ4dEQ8Nk4aSXO/uCAq4qJW1IukSItKQ0pDSkNLQ0sjrkbXTJ5GiVhiB14nc83ZaZSIJV6N6NFeYbiFozCuUQsJyMAGDLU4nLhGLVRgqPVAB47CuEZ59ENYdCEDrwaMbpg7VQRJkRZZkSeFH68pDo2CL/X5r9eRjjj+uA1daEAHXkd6PVZrFHwlEpCBDRgTgkEh1gIVaMAQk8BRGC5dGGIRLFy6MMQ8sAMFeF2z5q9akReNpPlWWRAVRcQR+Pxjux6tNaq37HqI1qjeWniZLpGAfGGc4GW6xA4UoALjbaEgLxpJ89WxICriolbUi6QoRHqgAb1QCBiHGY0vArwaNJo21nUmeVG0SLSePoAEjBaJY9EGvKTidjmqsBKvg40bzajCMopBddnVKNrpsqtRHOxl10QCxjxfUCvqRRE0zsrjzzUw/jwO9vKfxaNRlFUZxcFeBjSOI7zcZhxHeNktcRTGRTH+Kkw4iYuuc+U4qxF/HmcVZrv0oyBq0XVQV329Rj2UXU++GvVQiR0owKsFr4dgjXqoRAeOwstriQRkYANG3DgyighXG0UJk11F9RolTHbNu2iUMCUq0ArDOguvCNdjtEZZUmJE4MDr0K+nZI2iIot74SgqShRgqEU7xFhf6MBRceVR/xoOWMjABux1xuGLhQq0QsW5hQnmCYUJFuKMY7jHaIhCIYvrWxQKWSTRKBRaGMN9IQEZ2IAdGK0TR2YKNGCoRRdeVyeLO4rYic3iTj2Kiixu+KOoaA7ZKCpK7MArbp/owFE4n5WCqIiLroONZ/OoHbI+/zXmKJ4kc0IkKA5KA6+DivQdlUOJHSjAqwkib0XlUKIDR2G4YyEBGdiAEXcEXhEibUexj8UNeZT12FVoo1HWk+jAUTjdEURFXNSKepEUaZEVedFI6qXRS6OXRi+NXhq9NHpp9NLopdFLQ0pDSkNKQ0pDSkNKQ0oj/BRtGHaaxEWtqBdJkRZZkReNJCsNKw0rDSsNKw0rDSsNKw0rDSsNLw0vDS8NLw0vDS8NL40RgycGWjgkZiuiKsfiSSzqbywe6GZxDAe1ol70jBT3slECs2gkRTaPx9fYZCtRgdeBxDN5VL1cpQQaRS+TYgxPoiIuakW9SIq0yIpKo5VGjNdIHFHTYjEBEDUtcbsbJS2LvGgkXaNzERVxUSvqRVJUGlIaUhpSGloaWhpaGloa19iN2+6ocFmkRU+NET16jd1FIynGadwyRMGKxexCFKxY3HJEwUqiA0dhjMyFBGRgA3agAKHmUHOoxRUgnlqjjCWRgAxswA4UoAIN6MBSizKWRAIy8KkWN/xRxbJIirTIijwpLgvhy9gOy2KWZX6Cj+a/KtCAfmGoxyf4JsYn+BYSkIENGC3QA+NcLxNE+UkiAeNcNbABO1CACjSgA0dhXEEWEhBqHWpxFQnTRlFKogLD6HFucSVZGFaPNotriUf7xsUknqGjKCWxASOnhHBcUBZGVrHAUAthCbXozfhEZ9ylRFFKIgEZ2IAdeMUNz0b5iYVBo/zE4pE3yk8SG/A63hGHHg5eqEADemF4NZ6Uo6TERpxmuDKelKOkJNGADhyF4cqFBGRgA4ZaNF+4cqECQy0aNVy5cCRGoUnilRjjMTsKTRIb8GrfmIn3+VneiQq8nHWVYqrPz/JOHIXzs7wTCcjAqzfjAdHrs7zq9VlejfITj+d7n5fNiQ4chczA64Jxra1rlJQsnNvPBXFRK7oyzvw9K/KikXTZbxEVcVEr6kVSFAcjgQb0wrg2xtN7lIMkMjD6J9omro8LBXidRpzQZbZFXjSSLqctoiIuakW9SIpKQ0tDS0NLw0rDSsNKw0rDSsNKw0rDSsNKw0rDS8NLw6O9YpR7A3bg1V5xTYgCkUQDXl0SEx9RILLw8qrHzEUUiCQysAE7MNSi+4YCQy36bIRaHNnlVY8JjygQSSTgpRYTHlEgktiBVxNakBZZkReNpMumiyIiB15HGs+WUSXiMSESVSKJo5AfwDhSDWRgA3agAK+sEmknakco3BDbRHk83Me3/zwe7qOiJPFSi1mFqCjxmIyIipLESy0e7qOixOPJOypKEuM+ICLEh2lnsPgEbcxAxNZPiQa8jiye3WMXqIXh3oUEZGADduB1ZPGcH7UjiQYcdWRxgVxIwDj0OOO4QC7swJCIQ1cFGvA6oXhUj4qShZeBPR72o6IkkYGhNrEDBahAAzpwFMY3rBcSkIFQc6g51BxqDjWHmkNtQG1AbUBtQG1AbUBtQC3MHDMSUVGSOBZaVJT4NU9hUVGSyMBraFyzFxYVJYkCVOCldk1vWFSU+PVcaVFRQi2CxYV3IQEvtWud3qKiJLEDBahAAzpwFIb9FxIQagw1hlp8w7pF64T9FxrQgaMwvmG9kIAMjFvEaJ34hvVCAca59UADOnAU9jg3CSQgAwUYESwwIsThRFJYSEAGXhE0OjYeZTUOMp5lJ8bD7EICMrABr/bVaN/w/EIFGtCBozA8v5CAcbwxjKwBO1CAoRbNZwYMtWgoG4X+ANL64LhFwUhiA3agABUYcQPjoqzRF3FR1mjquCgvFKACr+O16Ivw8cKRGOUhiQS81K5ZM4udnRI7UIAKNGCoWeAopAeQgKHmgQ3YgZeax5GFj68nOYsylMRL7XqosyhEWRg+9jic8PFCBjZgBwpQgQZ04ChsUGtQa1BrUGtQa1BrUGtQa1BrUOtQ61DrUOtQ61DrUOtQ61DrUOtQE6gJ1ARqAjWBmkBNoCZQE6gJ1BRqCrXID9dzucXOTokdKEBdX763qI5JdOAovPJDIgEZ2IAdGGdxGT32cPJrbsCiRiYxjjcGeNy0L+xAASrQgF4Yt+cewgPtO3DG4fmFBnRgtO+Vz2K3pkQCMrB6M6plEgWoQAM6sHozqmXmMUS1TCIDG7DXMUzPT1Qg1AhqBDV4nuF5hucZnmeuscMsQAUa0OsYGC3Z0JLwPMPzDM8zPM/wPMPzDM8zPM/T83EMHS3Z0ZIdLdnRkuH5awbJoiInMaabKdCADhyFc1o7gs157YkMbMAOFKACDRhqEjgKtQY4z3ltDWzADhQghkbcCCxEZyk6y9BZhmFvGPaGzjJ0lqGzDJ1l6CxDZxkGomMgOoZG2P96NrWowElUYDRUtEPYf8SRxY3AxHhmX0hABjZgBwpQgdcz8/WYalGbk0hABl7TG9d0lEVtTqIAFRi3SRbowFEYSWEhARnYgB0YceNwwv4LR2HYf2GcBQdGhDiyMPpCBV7zCVf9jEWJTuIobNE6PbBuWaNEJ7EBodag1qAWRl/owLpBjiqdRKh1SISP4yY9SnESHRiHflkk9k9KjCbxQAY2YHTsCBSgAmMFKY4hJuEWjsKYhlt4qVF0QEzELWzADrzUKJp6Lk1FU8+1qcCYelsYceM0Y/JtYQN2oAAVaMBQi9aJObiJMQm3kIAMbMAOFGAEi0Yd8WfRfKMBO1CACjRgTNtGo4ZjA6PCJ5GADGzADhRgTBFzoAEdOApjUm0hATm7JUp8EjtQgHFClzdjR6PZOrGjUSIDGzAOvQVWk8TeRYmjMGzKodYIyMBoEgns+DMBKhBqDWoNajFzvpCADGxAqHVI9Jyts6giSiRgrNrFoUsDdmD0ZjRU2HShAaM3Qy1sOjFsujDULJCBDdiBAlSgAR04CuMWeyHUDGoGNYOaQc2gZlAzqBnUHGoONYeaQ82h5lBzqF3X49Fi0F7X48RReF2PR4vOuq7HidcgaDFow/MLO/DqtxYDMTy/MNSiY8PzC0di1C2Nqx7LonApMdQ0sAE7MNRGoAJjIYICHRhLEddZROFSIgGvlrwm7y0KlxI7UIAKtMKw/7XSaVHZNHqcWxj9mr212MYoUYEGjOONkw/7Twz7LyQgAy+1mHOMmqdEASrQgA681GIqLSqfEgnIwFCL4w37LxRgqMWR9VDzQAeGWnRWXMYXXmpxkxNVUIkN2IECVKABHTgKIz8shJpCTaGmUFOoKdQUago1hZpBzaBmUDOoGdQMagY1g5pBzaDmUHOoOdQcag41h5pDzaHmUIv8ELdqsSdSIgEZeHkoJiXj046JAlSgAR04EmMrpUQCxllwYBzv/FcHxvFegza2R0okIAMbsAMFGHGvAR5bHs0miS2P5hnHJxgTO1CA0b4aaEAHjsJWvRkFYokMbMAOFKACDeh1OK16M3ZKSiQgzi08Hw8rsVNSYqh5oAIN6MBYx4xg4fmFBGRgA3agABUYa6YxCMLzE6fRo7PC6DF7G6VliQ3YgVIdoOgsRWcpOkvRWdPoEwmIzoLRFUZXGF1hdIXRFUZXGF1h9Cg8GxbDMyy9UIDRUNEOYemYgI/Cs8RRGJZeSEAGNmAHCjDixtCIi3tglJglEjDiemADdqAA42LZAw3owFE4L+4TCcjABuxAWyvbNsvPFo7CKD+L5+5ZfraQgVfcmLePnZISBRiL5xMN6MDrLGKOP0rVEgnIa83dolQtsQMFqEADOnAU9geQgFDrUOtQ61DrUOtQ61DrUBOoCdQEagI1gZpALewfM09RqpbowCh6iLETs+4LoyWjuyMTLGzAWOyPpo7JuIVRhhA9FJNxCx0YpQWXA6KsLTHU4ngjEyxswDi3OLJ4JFioQAM6cBTGxT2m5aOsbcSkepS1DZ+/YEAHjsLwfEyiRllbIgMbsAOjADROPm7zFxow1oQnjsQoa0uMNeFHIAMbsAMFqEADOnAUztX1iVAjqEUmuCq+LMraxlVtaFHWlqhAAzpwFMbN/0ICMrABoRb5ISZ9owQu0YCh1gNHYeSHhaFmgQxsQAVGCWf8WXh+IQEZ2IAd+DxejowYVXKJBpzZc/IAT9cvjkP2QAY2YDx1jUABKtCADhyFOuVirMVUQDJvHHkmpj+jfq5YNp4VTzFI1Db2jedpXqaOWrpi2njqRpfGtojR+7ErYlA83T9iGikq5Ip547Zx31g2nheZOHa3jX3jAR5TN45x0Ma88dSNYx99Y9l46sYoG7axbzyKo2ruyR48r6eP4Igf83hRIlesG9vGET/m0aJU7snXeUWx3JM1eMYPXeKN28Z946kbx0a6sW3sG4du5JQx7w0ix415cxAXkSite3IcG4dWzHFEcV2xbmwb+8YDHCU2yVM3jmfeJizuNQbHvDtYrBvbxr4xxvWYtwg9znHeIyzmjeMcY7plzNuExbKxbmwb+8YDPNPGYtqYN950ZdOddwyRt6Jir9g29o0HeOaPxVM32nPmj8Vt477x1B3BurFtPG+N4jhn/ojqsDHzx+J5dxRje+aPxfP+KI5t3kQslo11Y9vYNx7gmX8W08a88abrm65vur7p+qbrm65vumPTHZvu2HTHpjs23bHpjk13bLpj0x2l64/HY2PamDduG/eNZWPd2Db2jTdd2nRp06VNlzZd2nRp06VNlzZd2nRnXrrm5PwxH18W08a88aXr8aeRohYKUIEGdOAojOS0kIDzdDR4pp3J87AteIDXk8lk2pg3bhv3jWez+MWyNbtspy/b6a/Hjsl949nsI1g3to194627ddPVrbt1627dulu37tatu2camccz08hi33jr7pVG4nhWGpnMG2+6tunapmvbMLNtmNk2zGw7X9+GmW/t7Fs7+9bOK43E8fjWzr61s2+6vun6pju2dh5bO4+tncd2vmPr35VGJm/tPLZ2Hlv/rjRyMT0eG0OXtjRCWxqhLY3QlkZoSyO0pRHa0gg90L9Ej41pY964bRy616SR00wji0P3muNzmmlksW88wDONaBzPTCOLeeO2cd9YNtaNbeOpG8c8b3UmRza5JoOc1szH5Bleg2Vj3dg2RjdS27qxb93YaWPeuG3cN966sW/d2Ldu7Fs3dgxb2tISyTZ8ZBs+sg2fmX6uyVenmX4W+8az2aJ9ZvrROM6Zfhbzxm3jvrFsrBvbxg62fA71qDJMbMAOFKACI7LFQJsJZvEAzwRzTfI6zQSzmDduG/eNZeM4o2vW12kmGIuBNhPM4gGeCWYxbcwbt437xrKxbrzpRoKROLTIL4FR0ph4iV73fx4ljYkNeCleN5TO8z3AiQo0oANH4XwPcCIBGdiAUCOozbRxTQY7z/QQnuWZHq49s5xneljcN5aN53RXxJxPNh6NMJ9sFreN+8aysW48Z9N6sG88wDMPLKaNeeO2cd946j6CdWPb2DeO5a2r86MmMZGAUzQacyaBxX1j2Vg3to194wGeyWExbbzp6qarm65uurrp6qarm65uurbp2qY7701mp897k8V9Y9l46lrwQEfPFLF4GzwzRXgMyJkiFveNZ/wYhL4NnpkiFvvGm+7YdMemO7ZBO7ZBO7ZBO7ZBOzbdAa027y+uCVhv8/5icds4Yo75+7KxbmwbR/xrKtLbvL+YPO8vFtPGU7cHz/gSrBvbxjO+Bg/wvI9YTBvzxm3jvvHUtWDd2Db2jQd4Tpkspo154xlzBEf9zSPaNpJDMm3MG7eN+8ZRhfOINo/kkGwb+8YDPEuoFtPGvPHUjT6aZVSLZWPd2Db2jQf6buaHxbQxbzz7hYIN7Ta9v3iAp/cXz3OJsWRbW836qMW68Tzm0J0lUosHeBZJxTNl862PfOsj3/rIN13fdH3TddvYN97GxtjGxth0x6Y1ZswYY8M29o1HcRRCUqz0eFRCFvPGbeO+loB8FkMuVKABHTgKY+10IQEZOJtoBOvGtrFvHKdzzUx7n/t3LKaNeeOrFviazPU+X0CeKEAFGtCBozDeYlgYzXTV73oUSBbLxrqxbezgafurhtH7tDdF/Gnva0bd+7T3Ytt4xpHgAZ72vmbRfZVILuaN5/FHH0x7L5aNdWPb2DceYJ26MXRmseRi3rht3DeWja8uiSy0aiNn88ziyMVbs83ySIrhMesjF/eNZWPdOE6LY6jMDLB4gGcGWDwrTkN3ZoDFbePQ5eiimQEW68ZTN7prZoDFAzwzAMcwmRmAo+vG1I0mn9mAo9lG31g2nvHjfGc2CJaZDRbTxhH/WnzwqIdcQzIKIottYwfTY+O2dkvxqHlMFKCuPVQ8ah4THTgKL68nEpCBDdiBcZzX4olHKWTxAMcVPDna4Vpg8SiHLG4b941lbTrjcx+4hQZ04CiMnXwWEpCBDahr5yGfm78tnCcTDT29P3l6fzFtPE8m/nZ6f3HfWDbWjW1jX9sceVRBLowd4xYSkIEN2IECVKAVTsu3ybQxb9w2nmcTXT8tv1g3to197SHlc9u4ibE710ICMrABO1CAs3cseICnpRfTxrxx2zheMwmSIi2yIi8ai6LCMUZQFDgu4qJW1IukaB7/lT6iuJFiIwGP6sbitvHVCjp/XYAKNKADR2H4eyEBGdiAUGOoMdQYagw1hlqDWoPaNHaP1pvX8cW6sW0crdSjxeZt/eR5W7+YNuaN28Z9Y9l46nKwbewbD/D0/rX67zq9v5g3bht39ODy/mTd2Db2jQd4XvcXb6NFt9Eyr+/X6qfrfCNisW08z0uC53ldLtWZBRbTxrzxPC8L7hvLxrrx1I1jmxf+mG/SeeGfPC/8i2lj3rht3DeWjXVj23jTnTsYXBTvLU6iouv9uTjueGlxUi+67maj1eKNxUlW5EVjURRQLqIiLmpFvUiKtGi21TX2bGaGmFO2mRlimSAKIotlY914xrnOZe2+F3Pxa/u9xX1j2Vg3to2jbWNJwubFfvK82C+mjXnjtnHfWDaeuhpsG/vGAzxzQix5zIrI5KnbgqdutMnMCYtlY93YNvaNB3jmhMW0MW+86c46qTjkWSc1UYFRJxV9NeukJo7CyAZxBzt38lvIwAbsQAEq0IAOHIUGNYPazACxQjNrHiky/Cx6pFhdmFWPi6fTF9PG862n6Knp3Li+23Tu4gGe1/fFtDFvPF+qCqfMW/bFsrFubBv7xqN4lkEmT91HMG/cNu4bT10J1o2nrgf7xgM8b/cX08a8cdu4bxy6MfHqMxssto194wGeT/6LaWPeOJYWokkieSwUoAIN6IUzP8RUqc88cNUCu888sDjuOjTQgA4chXHXv5CADGzADpwNEoc0bR7pd9ZCLp42X0wb88Zt477xPJ3Qmpf+xbaxbzx1L7PPoshk2pg3bhv3jWXjqRsDY94SxIz5LIpMHuB5S7CYNuaNG7rJtu6zrfvmLcFi29g3HuCZKBbTxkgUvt6PnKwb28YRP27UfUsUviUKX4licsSPm/NZJJmsG0f8MX/ft79FghqPx8a0MW/cNu4by8a6sW0M3UGb1kwCMeM/CyOTZeN5LhJsG/vGAzyTQDznzyLJZN64bTx1LXjG92DfeIDnrULMLM9iyGTeuG3cN5aNdeO4nsXs7SyMTB7guFVIpo1547Zx33jGjDaX+bfRtsIbt437xrKxbjyPOdp8XvIXD/C86C+mjXnjtnHfeOpGH81L/2Lb2Dce4Hn5X0zou5kHFreN+8azX3rwQLv5Y2PamDee5xJjybe2ctvYN57xQ3c8NqaNZ/wYJ2Pro7H10dj6aGy6Y9Mdm+4YyWMWKCbTxrxx21g2nre1FjzA0+OLaeOIeU3BjwfV7fp4kG5sG8cxX1PiYxYZLg6PJ8cxX3O+44HHhPHAY8J44DFhPHjT5U2XN93p/cUDPL2/mDbedNumNX1N0VbT14sHePr6mqIfs/IwmTduG0e/X9P1IzYbLNaNbeOpG+0/vU9xbNP7i9vGM/4Ilo11Y9vYNx7g6f3FocvR79P7i9vGfWPZWDe2jR1sM2aMAZt/G21rurFt7BsP8PT44nnM0ebT44vbxn1j2Vg3to1946kbfTS9v5g25o3bxn1jQd9N7y+2jb14VhLytVQ0ZsXgbLdZMZgsG+vG81yusTQrA2dbzcrAZN54xg/ducHBYtl4xh/Btv2tb4w+mpWByZsub7rcNu4by8a68abLm1b4Or5hPWY5YHwJesxywGTZWDce4OnlFm04vbx4xgmt6dkW/TK9eU1ej1mWl9w3nroarBvbxo7405vz36c3F9PGvPH11CFx6jE3v1CACtzOdV575/nNZ+/FWxvE7vo9TnVatMWQmhZtMSymRRcP8LToYtqYN24bzyaL4TUtulg3Dt0epzIt2uNUpkV7HPK0aI+mjI35e/RCbMy/sAGvpqGJM3ac67Th+pVRPKvvkmlj3rht3DeOc7pmO8eswUu2jaeuBU/dq21mHR5fs51jFuJxdGdU4sUX2UZU4iV24PVMexVUjKjESxyF06TXHOCY9XnJc75n/k7buG88p3zi7KZJF9vGc9YnzmgadnJ7bEwb88ahq3Gm08iLZWPd2Db2jQd4XsQXz/gUfA2ERxxyn78ezSCPjWnjOMxr2m/MSrzkeZjRPGv+bbJuPA8ztKbvFw/w9P1i2pg3bhtP3ejzeU1erBvbxr7xAMdHOGYz2AwfPWF9Y9lYN57hY7zOnLB4gGdOWHx58xEdEUtzCxuwAwWoQAN64bwsa3hlXpYXt437xnE+Nv9WN7aNfeOxvg465mc+FxKQgQ3YgQJU4JyCvUbjLLZLpo3jfK5H8tHmJXtx33ieTwvWjef59GDfeIBnNrjmD8cswkvmjdvGfWPZWDeeuhrsGw/wzAaLaWPeuK1vHI+ox9PZIvH562v/iBFbDCaOwsvwiQRkYAP29YHh0eansicq0IChFi0e38qeGN/KXkhABjZgBwpQgVfcSE+z8o7nUc58sJg3bhv3jWVj3Xh2jAf7xgM87xEWXycU6S+2I0xswA4UoAIN6MBROO8NLBp43hss7hvH6VwV02MW5SXbxnE6Hk037w0mz3sDD62ZJxbzxqHr4ZmZJxbLxrqxbewbj+JZuMfXFPCYhXvJvHHbuG8sG0dbamANjk4YHJ1oY964bdw3lo11YwyOTr4xBkfnx8Y1ODozsAE7UIAKNKAD5+D4r//6pz/97d/+9c///td/+/u//Ps//vKXP/3zf9Y//N8//fN/+88//Z8//+Mvf//3P/3z3//jb3/7pz/9P3/+23/EL/3f//Pnv8fPf//zP57/73N4/OXv//P58xnwf/31b3+56L/+CX/9eP2nzxtzWX/9vLv2CvB8GPolBL0O4dfsbkR4Zg0E8PFLAD4cw+OaS5nH8HzgfhnicBqxsdyK8Ogvz6K/jtArQt8Owdovfy+v/75d90Hx90/j4QCMb/dEvIY9z4Ee4+U5HDvzmvBYnal7Z/56Gn5oyFbH0Orv++0/b/Ht2tkMz0VOHAHrr8PpcBatSbWkbIOBb0dQSkdoQ4TnBfnXCKch2TVDPBvVX8dopxHB1RZq7WWMU3PGvoWrLby/bs7DwOR4+IkYz4cPHAbJh1PRd7vkeCIjT+R53WivT+QQQ7RljCeiT5R+DTFO3TrKICL8KgQfxlZ8yjAi+J7t7HE7gvc8jefq5OsIh9HJj0q5z6doZKv+a3/wYXDGF0bmQQx7fRCHhNmiyGkOimdjYni7fa8/7GV/HEeFPfLi8cTxskvt0JzdM+s9n3XpZQh/u0/H233aHu/2aTtcykfMPM5r+XNWBH0q7f6JRJnoOhGhlydyGJxxYztH1uNlgHOqGFqDYruQfejRJu9n71OM3ihj9Cavr4bNjlciLotsrfGcPPo1xqk5PHtEH7JFaPcHRpcaGLK57OPA6Kd7NLFRMYZuCePXM+mH42DcXzyfxBFDv9An5ZK+XwI+9kk/jM/n9HDdJnnfLojt1/HVD+nzebeNe63ro7JblA9tKu+Pjq7vjo7zuYy646Lro3+vz8VPicOQAX1sR/KhZ8a74+M4Sm+mwGN7XJ9ayPa4ttl/2R7Cpwus1c3fcxEC7dF/zUByyqRNqz2e8xc4m/FrMpXThT6+XjmPw7u+jnG6CY2PFc/j8Ie/jnEYp+R4uvFGr2OcsinjIYt3z/n9AXIzFcp4PxXq492hfu5Y57qt356aPzaongYp4zJ5GfVljPZ+x2p/u2NPzdGlbuK62OsxqvoDzWE/0Bz+fnOcUkcv2z8Xkl4fhh3GaFdrNauypfTfLHs6DhGqu/NxOI7DKFWu43g+RL5Og19J6voyqVt/+zbfTtf8a/P3OhDr/vpA9NQkTNUkv9zDfIhxGKnPK1t1L20PTl9qkHuPCzbefFw4nodVp3S3x8vz8NMs6KNmJ669yzDEPlytnY9zC9mx1wa9r2OcZp1qtmcfos913l8jHHtklOF4u8D9FuMwRoUzhUl7fC/CqLvSrSU+RjiOcDSF9vbarn58kKweEfVvxrCa+3oifS9GfG99xnB+HeP41BKfgpv9+nB7+dQyTjNPsVn4uo/T108+o53GRk1qPofJ3qZ8P0Z8CHjGGGSvY/zAs9N4+9npmM2vnQLrcr9nwI99O95+wj/3rOUcLw/q3xsd8XGuFeMwOuJDAK+HaavxQdcC8Is72/OB1Cztc+ndDwdy8gtmgK4H9C3Ih4nzRz8uiLRaENln5b4SpBvXnIU/6BBE3x/usS3LHzneBd17vfT8crzH5iovw5DXoVzvrPQXo4To7Ueo00B7LqjUs3Fz+pZrWqu7j9b74/VgpfbHuuZ5G1g3UnpIAXRcbhLPscr6y5ynfwhyGKvXDly1yuLyvSAjKgnmQ7bpKYj/gGtOyxw3XXO6Qx21RN7H9iD1m2f4B25RiX/gHpX47ZtU4h+4S42Xb9+7TT2HuHWf+smFBncAwx+v0/tpBer5lF/XXt8rEH4LMo43I3XJc96XaT+s6bU/Nqtipfe59vL4XlZVPBUa8+tkdlqIurfufTyM7fo/WA+HcbpmRkHs7Ja2zQg9+/ILQeIrinn7/zgEsVNOlbzeDd3nyD66/7QcNepOc2y3VU30K8fhOI5xSGWnmVyKr4etFtly+8cjOd7OXLWpuO7+8lj1ITV3fvcKcfQuM+breC/++ejd80qO1SLMk8d4dVvVj7cANUPO+uDDkehpoowxL6SH60y3H7jindalbl/xTgtTN6948viBK57Q21e8Y4h7MzOnp4jwwjwK6q9XC8/GG4yr5pCD8Y4LU83qdnXP8c9//xBE373inY+j1woq7w8Bvx3H8d5bqwjxWnB7fcd7WpuiUZ3Dj21q5WNNzmltCk80/fG6EiV2m3mdzqiSCNu+Dvvhxvu0OvV8+iMUND62Z5qPK23nhOa1VN9ofzD6mNCOK1StLlnPq9JjO5IvpNYWr7mt9aV9LvG3IzkOV9km8Q4Xcf2J1Ko/kVr1/dRqP5Fa7f3Uam+n1uNtHjMWmDod7hVPizK3n3pPGfruPc2pbBQ3Ac9lu8NDzelq88x2NcqevD0bfTCeHY8EjxO/NOtvRzJOy6GPUcuhY7sF/1iK64/38/Npsepmfj6tVd3Oz6fFqh/Kz63xNgt3eGz1451AdQ7vU3m/5SLXH8iKbj+QFU8rRjezoo8fyIrj8XZWPIb4gazYyVFEcHj4/WTRqRYDhxzsO/r79j2tXN2072nh6rZ9h/2IfY9rrFLFuqovy6+PD7/PFfzKrL6vKXzIAH5cZKk3gFz3EL9eJvi0eNXIkYkej5d34OcgDYV/v8w7/RbklFrvvurQj4moZuFP7zocQtwsjH8cZwLuve1wWre6+brD45RQb77vcL9X7NArN4dH39rji2PsYbifef2oyD/xlhT/xGtS59Oxqkt4XrtPp3NIq9eHmnKUMMvL/P5JkJqrvb6Vcwhi75uX/G3z0vtvtZxedrpr3uO61T3zMv+AeW/3ysG8x+HRqhLx+iTK6+HBx7uZey8ssb7ft/YDfevv9+2pmPruS0vHIDeruvn4lszNsu7Yh+i9ycRPBtmjEllr301kWoWZ1365r4McF52ko1R1f+/T+X5y71RLLM9L1eGmqv1ASm3vp9T2fkrtP5BS+/sptf9ESm0/kFLPw6Nq3Z+PuuP18Di/SHVveJyWrG4Oj/5+Vj6+RnV3eIy3h8dpter28LjdK98eHlv2MPre7XKnyux9nwr5LcjpBZObL7Cz/MA4lffHqbw/TuUHxqm8P071J8ap/MA4PY+OW9Mgp4kUwqvwJK83WeDTMpXGtlFzts3tcNnXQ3sM1EQ89mcgv70byj4HupchdP/QpKc1que8sNdEytYg/FyP+DXIaZyyYqZs24Pjw9YwrMeX+6Xmlq8pqVcxTmtUWuNUt/Z4zgF/CHHMYg2TZIcQp6Oom1Pbp7d+C3F64Pd6Of85kfl6IZSPK1S07Zazzda18THI6Ra3XswYv7wU9jHE6SWTWhaybSr2txDnAYZyGd669rfB4e8vLn+SgQwZyL+ZxW5ux3FanXre/SqWMPvrGPz+dfK0OnXzOnkKcfM6eVyXunmdPC5L3btOnhalbl8nb/fK4Tp5HB1tOEaHfi+GMN4pbS/3B+FxXKsXqdUgHd+MUTV7xxhnt9ybDBrvT/SP9yf6j2tS914F5dOS1K13Qc9HcdNv4+370vY47mFWlT66T3p89NsXgsg3g/RaKtC+vXv4e5B3t/T55FzqEvfE754L1/2L8nZZ+GKQKmDWfYr/a0FazYw9J9r0EOR02X+g3uBiejlveQxzdwb1kyC1xce1/+43g+Atpmtf128GuTmX207LUnfnchv1d+dyz8eBN3+Hb88wvx/H3SD73fLXgtSF5on6vSDPR9R6zH2yHcIcu1gqsY39RuKLg80x2HYffy2IDgR5bcAvXMNfzgy10ztVVo+pZofZlOP9/71d005LU3cnys5Bep1L74MOQezovXohyvrhbPztp4h2Wlm6d291DHHv3qqdlqbubi94Wpm6eVdzfKHq5lPE/V6xQ68cR0dVuD4frPu3YjSM9ecFz74b4/F2jIabqz2PfS2GYqrMX8foj7efiD6JceuJ6HwuHYOsq78f45tjrPFAjY2/7tvjCoji1T/jg+uOB2J4sdv0dSo8vUp1u3PtD+5cI5zLwbhy3Gq7Xvoh2kpKv9ioA9viHUbZcYu/W4WcTY4v/kudy7DD09npODqWyPbNG39rjtM1W6oCq8vhvf92fJHq3sxfk/cX+pu8vdB/DHHzmq3vL/Q3fXuhv+kPLPTf75VDPj2Ojnszf+cY92b+2un9qbtp7DzSb83aNX1/lOr7o/T87tS9/Z5PC1P3ZofsB7xib++J3o7LUvcnZE5h7j5UnoPcfUY+Brk7NXQOcnNq6NwmN6eGjkHuTg35D5T5NX+7zO98HHenhm4HOU0NnYPcnBo6BfnC1NB5nNyc1bmfnl/f3J1en7o1IXO+p8JGn32P8bXJFKldLrqcJlNOC1V3K/3b+IFK/+Pp7EUufNjVqX2y9d/N09E/+nTYt/fjTqfjf+RIE627dzF5PW3XT0savTbt6rxv3/74EOLt/f3PR1ER9meZ34/iMFA741mGt1savR+CHq61P93DvX8vyPCtkGp7FewrQa4X8+pp97EtJX6lUWtXmD5OXet/aIhnQ9bbpE+W16fiP9Ez/hM94+/3zNm5hrdjub9OIP20TnV3369+3H3knnePx4FJJhqjH47jGKSWMfjB9M0g3rBZ7i/N+jHIeP8y009vUN29zBxP5+7mUP30EhWp9e2TJfJqj8nPgtzaYaofN/+7ucNUP75FdXOHqc4/8MJ/5x944b/z2y/8d/6BF/57e/uF/3OIWy/8n0fIzS17+mm16m5V5fFI7m7Z04/7F9zcsiduft4eq+0nxmp7f6y2nxir/f2x2v/YsXp3+5Lej1/6ubd9ST9t/3d7hJyWrG6PkNOLUDdHyGm16f4I8fdHiL89Qui4Afi97S0+CUKGIId7APmBV/67/NETAYqpPNXDVhvnIFb3RXraI/ocRGuQqPPrpa9+XiC527D+Rzes1w416no4HT1/V7phwWf0l7d5nwS5tXNXPy1f6aiXoa3TYWrj9Imquzt3dX1/65+ub2/90/UHtv7p+iNb/3wSRjBMnouL/nrO9zRkTauKxnTfVeFjH9t53+o7BWPd6O3F527nHdZvLOsdQ9xb1us/8KGqfny/6taCWj+9X3V38fl+r9ihV46j41bB2DHGzYKxz2I83o5xrx6on9avflkEl++16c3CtU9i3Cpc6+dvTd2qbfokxq2igPO59LrKtP1Ni9+Ow//o47hVQHc/xjc9d7OAro/jfNO9ArpPBvvNAcJ/cMfcK37rp2Wru8VvnxzIreK3flq1unkrM457Vd8rfjsex73it89uVA13788l8Bc3qvLg9+92j0FuLl0db1OtUzmmvxyo8nh/mwp5vL1NxTHEvfsgeby/TYU83n4dUOgHtqm43yuHnHx+iKlr9nOh5eW9g5xeArqbCo9PMbp9Z2r/tOxvTzHHndBrgDyRvheEHo96bujH56ljXWJDwYl+/6HMFQ9l2xXzqw9ldUbXA5oewpzLNdEupN9sl17bkXDfP/TyWxB5P8OfH4ceSAP+LeswYRNien31Fn77+V9OS1Z3L5rCP9Ckx67Fxip9n6z62pAnxho6tW/PQ8R+WCsM67edw3WDdoXU701n/PLGdeuHCcXTnEgOFMPJ9Pa1hVrbFmpflTjIcf+/n1jtvb0Cfl7t3QxM31zttVHfNPDHntI+BJHTypVoTXmJ7u+gf2GhFmuKzJ2/udprhHqNw+KGdP6Dgzyf0R4YJP7NIFY7qz6nWfgQ5GSamqG1rt8LMXp93Uz8eyHowWWah8ohyOmxxpGiff92xvjCAjihpufJ+wewHx8O5fS+1Y1UdG7SSof7J/S+1is1ezdM3u5Yk29aLvbIWIu021dEvhYEJaPPeIeBfipwvjk6jjGI8K4Ddf/egRDhUzP7th5fC9Jqooj2XZW/FkQYz/DdvhtE8Yjl47unU/OA1PhwOqclq5up7BTiZirT9gOpTP/owdqwYVwT+2aD3EtExxD3EtHNbjklok9KTxmfz360l/dlnwTp2xqgvqpfFfuB8uRjkJ8o2L7dIu0nWsR+okXs3Rb55H2c7WQej/0Nsq+91vPAPcQzzOk9pVOr3H876BTmOWtU2y7tmz7qF0KgskGH0vdCGI5ivAxx3kjndu98EuZu7xwrne/3zinMzd45hrjXO+cQt3rnvLvXI+8ldH+t54v7jFUN6zPI6y3CPvlWxK1X6uX4zaqbs/mnV65uzuafQtyczR/vf7JCxtufrJDTutXt2fzbvXLYTPM4Om5upnmMce+Ven20txdYP4lxbzNNfn9rdB7njHrvFfDzB0nu7it2DHLzFfBPvq9y7+3tT07n3tvb5++r3Hzh+X6QwwvPnwS598LzJ21y703lL3wL6OXChNJp1N/aOu74sZhe897e2+vPGunpc1M3F571/MrVrUuV8uPdJHAMce9Spaf595uXKuW3d7TQ4+T7zUvV/V55fak6j457C8/K729A9clx3Kri1ZPz763iaXu8v+p8PI57q3jH5ri5MHqOcW9hVFt/v0nl/YXR43Hca9JPvrxVzeG67bny+5e3fuTp/bMwN58PPwlz9/lQ+x8f5t5j5jnErcfMT0Lcecw8fzn33gcb7O3HQ+3v77im/e29rI4hbl5z5f1dpFTe3nFN5Qd2XLvfK/a9wXHz6dDefzgUff/hUN7fs43f326NfuLR8PjscXc3LXr/cez05uvdp7HbMQ4PY+cY957F+uNn5i/ff9w+H8ndMXJsk5uzB8cYP3A2d8fq+VzujdXTh+LujtXbMQ5j9Rzj3liVH5lrP7fqzckHe3/uwd7eu0pON9zll+e9975J2od7MT++RYTvh7f+qnz/HKJXbcevL+98CPF28f6xMR41ND587PLjYRwnlu+9iqyn96Fuv4ps7zbpaaMJrd0r9Zctydr9CHVXqXsZxccIpxsxqbMg4a1ep/X7MTo2vhJuL2PocRO/LZM+WV/u39PfXmk/ja7nrW8tb6vsk4UfGlVHf9uxxxD3HHt6mepmc5zmb71mTp/4+g33d8f4McKtMX6sWLw5xs8f+703xu34EtXdMX78IGNtu8m8faCS2xdiCN4sETnEOL6Itb2qZ7R/TeVD19jpJah7TjmHuOUUO27/937i+LU5tqnXj83xybM13sEWPMfxxxLu2zH8/Rj7RpUfY5xq2gz7U9m2Xd5zLvR+DK+ddp4o34zhFWNsI+y3GOc8WFWtzv27MTpiyPsx2uNljNP2C6I1kfycohsvYxxfJbnZt8cYN/v2HONe357qN1t8dmqOdZbxfozNL1+LUU/FjU2+F6M1bNbVH9+L0SuRtV92If/ScWjdX7f96fzbMfSbMQauLuOb46Mz3vNv3+xb7Pv7RPtmDML+C/LdvtV6Rb+rfdNziu1YT317jDFwH7R9VOGL3seC2IPfj0HfPg5DDP1ejIHq/tHt/eM45cL2A3m9/UBebz+Q1/kH8jr/QF7nH8jr/AN5nd/P66edNZ45o759qN6/df/RBz7COPxwH3S8P932GfLX96d22ujv5nqayfFB/4FNgva3Ln47kFP1qVgGMdk3lvYPMc5XB2T2fSM5+xDjNKP1wIPUY1/a/xjjk9cu8MrU/lLNb2dzbFbZrv12aNZjkLFt4HQaJKeEGB+OWhlxX2b87Sn3GEUeiCLb9m2/RTm+WmPYX37v4g8Lr8c3L7YPEOw3Ir8dx6lOCRsPSxuvW+S4EZTVvodPlO/FGHUzI2MrMvpaz1glgefFb9+p80tRvOPh3+V1m4y3p4PH29PBdNoNhp73MHi/5zlf9Wo65fTG02Cq5Rt+PSNzDlEDdbC+mnk8doobzsR/eT34K13ro+qdnnyYEDazt6e57O31BrPx7jTXF5qj+7cb1RBF+nejyEAUO8xAenu7a44h7nXNaUXqR7pmbw4f3+4aPN6N8c2EOB64Vg3i1wmeTrsm3MuI5xC3UuL5XPCNKhraDy1y2urv3lLKMcTzYvVADbpR/14QzGU+meWbQfDCsu1vPX9hvA5DLck45WeSY5hRo+TJYt8Lw4z92NtWo8vNvhmE+JtBpN6gZtlqBb8U5HkKldQe+wNS+/hdh8OBUF3Fmdtu4V8rKPz40vHN5Xp//MQeO8enPUyd//LNnN/O5t13UX7iK3OnGIJ89OHe+f5xCPaWE9suNx9jOL1dl3IOcevK6fR2Xcq5MaoOTLyNQ2P004WmllW079/J+C2InI6kLnj0ePXkfD4Mqfsz3T8K8bVzkZr2ei4WybeDbJ9AGN8OUtv96y+Lqh/G+qlRvVwr4xTj7TKG8XYZw/iBMobxA2UMzvJ+GQOdcnrvNYvQ92/u0ccLA7/9WHUOcS8D8duPVefWkBqjXcxft8apwvdmaxxD3GuN1v7Y1tCOz2Tur0v81hryfmvI+63x9lYnp3vtNurq1PdPWXy8cTnHqHqO/vhlEvPDzc+x+PvurdzpvaK7N0B0GmJK2L9CDsfxE/elvf/Eychxxq0epfbtEonHhyM5Tf/jWwXbTLf5Fw5Da0Nc2gvIPx4GHStB714ZTkEGcuH1MXO0an98IYg+aiur/cbhq0HqJQNtdAhy/Brr9qqj7m87fGiTfnz3q25Ank8v7XWQ4+lYy3vDYXsFwZfaxNGwfthl1E+rVT8S5JcXc/d9oD+0yTnIvlnp3ia/BTlOmqOMgAZ/MwiWq55DoX8zSN926d83kv0Y5LRSfHNHu3O7tvqOMe9fPvltwNr7m8jQaZrp5hziMcS9ZZXjmdy8d/+kOW7evOv4gRQ93v8Kg//A16j8/a9R+ftfo/If+BqVv/81Kv+Jr1H5D3yN6jw67m2G4aelqpuvxNL4ga8wnIPc/AoDjR/4CsP5SG5+hYHGj3yF4ZMwdz+N91mYmx9zOLfMzY85nIPc/JgDjeP7fnc22Di65+aeJecY9/Ys8fMz4509S/w0sXp3z5Ljcdxt0h/4mMMnY/Xuxxw+CXP3Yw6fhbn5MYfzrc02R9u+e3dUe41sSeljiE9ufesw6Jdy8a/d+taLUbRP1nz/JvwQ5JPnLMMeyP76aw7j8fb01TnEremr2Db6Dwxxcz7w3KBV6fVs2/66QU9LTTdn4uj4JTWUR+vj9Tg9B1EUWGgb3wzi9ZFM2h/RvhZkGJZEH/S9IHdnJs5HgoXVqybhEMTefwo/B7n5FH4OcvMpfJx26bv5FP5Juw5UaxF9t0nuZedPmuRedr7fOafsTG9PHo/jR6puTh6P48LT3cnj4+aYo6avbP/Q7cePMR2DuFUe8LEXA3wlyKB6ZWPsn/79GGS8v4L1yXEIPoMg45snw5XoB49xOJn+x55Mw53Evg/K78ehf+xxxNeF15T843Qc/vYdzTHEvduR/vZtAJ12thu63Y7sbzj8NsTG2/OSxxD35iWP+4XenZc8Brk5Lzm6/sC85PH2/d685Oj+9rxkrKi+Ny95DHFvXnKcNvu7OS85Tm9a3ZuXHKf3rO7OS97vlcO85HF03JuXHD+wVR8p/cC85DHI3XlJpR+Ylzweyd15ydOa0xfmJc9hbs9LfhLm7rzksWXuzkseg9ydlzx9A/zmJNrJPXfnJY8x7s1LDn17e+phj/fnJY/HcbNJz117c17yPFZvz0uew9yel/wkzN15yeOtzb15yfPd0Z15SXrQ24+KNn7gUfG4e9/dR8VzEX29mNv2RqWvBHkO+ipGayTfDNLrRaX+6xZrH4OcNjcz9poeedAhiL19E34McfOdS/2Bm/BjkLs34f4TxQGnrYhJHS/k+ON1zxw/VINtlZ/3avtXpu0rQUbtH/5g+mYQr9eUfn1x5EOQMX5g18oxfmDXSjrvcGioR1OT1118uvZZvb/ZfXfwb23iP9Em4wfa5DRiGQ8G7bG9t0VfCuL1hNIefBj2j+MWgTcbhR6PH3jNiI6fehR8RuDJ/dVHJ8nbT9yQH3eOlfowaZftfD7uHHt9BOL0yNQEj0wvn/+eQd6fHngGeXt+4Bzj3gTB8/7m/RmCZ5C3pwieMX5gjuALfWOnvjmOkhprbK+fUc5BGhk2UBz27SCP94NYrRQ208Ogp7vVWPLNhm1bkfo+mf3FIDXa2l5X+luQ09erbn6z4bMg92aCHp+sr4//3wnt345E/vAjgQOfy5c/EOS7Bmw8sOGeH4b98a5Nte4fjY9pafzAQLltnm93j2F/p2NWasfv6WKPWtqf3n6/8BwPpV5YaX4aKcdXq27N4tCj6fvTOOcjuTmP88mdkuGubfjLNbZHG8coW9nAGPytKDfXt/zx9irK3Onr7fuk01tad++TTjHu3icd90G/e590WuG6e5/U7Sfuk273zSFNHwfJvcUUepw+aXU3NZ6+S3F7NeUY5O5qyinI7dWU45HcXU05P3XdXk355OHt7jLI8ZTuLoMcg9xdBnF6O9f74/1lkGOMe8sgz0zD719Btf3EFVTfr9A+9+7NlZDzcL29EnIOc3sl5JMwd1dCPpmvq4H/5CEv7wqOK17PKLxFeTmX039k/lFv+odeF0fT6TJoo/Y69sfh/dFnoxyaVrSmpkT3ItoPC5onJ++vj24vb193XveDWFUEP6eoHq+DPMz+6CjP56YHxol/N4oZ6nnHoVkepzRptWBl+9LKl2KMjsI1/2aMOQ8wz2bf0fb/J8ppX4x79bykp2RAhg/e0i97pj1+O5bTjsPVsEhuvX2lWR8osvx219Q82zB5v3tPMY7ua7X69jQzfTMIe30gpD1OA/70Day7Q+QYhPDJOaLu3zwUIsU2zi7fjdJqKof27y98MYpgd3zZdsf/ahTFQ8/2nPDVM6oJO2p8PCN/P7OdYtzNbMcluLuZ7Vgm8TPDtmFHySb23Ua5mZeOMW7mpZudc4xxKiy4VwJzrk24UwJz3LXs1kGc9z27VYZz3hETT/i/OPdL22oq9ubU0b4ZxJHm92+zf3FvTnxQ5sGvT8dP68R3N/g8Brn3qflziFufmv8kxK1PzR/7xWoe6ZrJ+Wbn/hKkfzcII0g7DDPiH3gPht/eyu0Zo/2xMW5OSJ8bFZvJ2P5Q8rWeqQlL3h+AvxhkO5JvB/FaVXrit4PUPcQ5yHF37HvXmPMG23fy+yd7/VeM51X7m58LqOW+wfaqpun47YR7Vzp/tyXOX8WoDbrEftn38Asx8CkKcXl8L8aowtcnfvPrHG44ju9+JcSrV5/hvvuVkG2JoX+7PRwxXvfL8csreHe8y+AfiPG9r7d0TOL1fRLvSzGwD3230xij4xReLYc9HocpPDq9FtS13jrtOuTlFOsnR3JvMvE4A3BvMvH0ZfO7c4nHGHcnAen4ZawfiXJ7KvEc5e5UIp1e27r5wH2McfOB+xjj/gP36TWauw/c54YdmMkYfGhY/hEXHxeQbrr4s0O5aWN9f02Af8DH5yC3Laj2R0e5b2T9iTUBsvfXBI4x7hrZfmJNgOwH1gTODXvTyMdvuj3qbRr59esYH9+4Ou1AKOx138j7Pd/H9+JPh6JWLau2f2DKv3A2tV2B0INPZzN+4GxOCxQ/cTYoA37i9+4cpVVVibSu34vBOA62H4jhj2+eSxWlSKPxzePAJz/a49ttOtCm8s0YHTG0nUbq+6tx5xj3Zr3vJtZTjON17+5q3PkKfHM17riJ4u3kfHzx6+5q3CdRbq7GnaPcXY07R7m7GvdJlJurcZ+c0c3VOD6tX928pzjGuHlPcYxx+56CH3/4sL27GndulHt56RzjXl662znH3HZ8+ruZY48xbubYm0+hhxj+AynWfyLDMv3AUD0GuZ1hP4lyM8Oeo9zNsOcodzPsJ1FuZthPzuhuhuUfyLD8AxmWfyTD8h8+bG9nWP6BDMs/kGH57Qx7LGduun3yfZt4GfzNGPrNGANLr5uFvxSjY4W/b4vAX4vR8Crd9qX2r8UgvF24f9zkSzFqs7snHo7jNNXoim8Kn/r2GGNgZ4p9s9ovxcAOsePB78egbx+HIYZ+L8bARWJ0e/84+uuxfpzRvtm35xj3+vYc417f3o5B3z6OW317jHGzb28fx6FvT6trz6tg3Smy7KviH/cKkfeLWc4x7hWisLQ/Nsa9YpZjmzZ83rnZ49SmeqwUyFnF1x+KPR5GRzVM3+9Ufz8Mf3+KlE+rWTenSI9nI9iEXFhens05Rm2U8Gz61y1ij/PHu+vtFpHH94LcK8s7h7hVlvdJiDtlef3t4tH+dvFoe7usp71d1nPcd/SxfwLwsV8kPyxwfhIF7348o7SXUdSOK9AxvbDCkOn3wtwbo+cQt8boJyHujNHTjuOjVQb7ZYftJu0LMepJ+xmDXsY4flz19hj5JMrdMaI/M0b0/TGi748R/d4Y+e/P//jzv/71H//yt3/71z//+1//7e//9/l3/3WF+sdf//w//vaX9Z//6z/+/q/b//vv/+//yf/nf/zjr3/721//97/8n3/827/+5X/+xz/+ckW6/r8/Pdb//Lfnk7H+0/MmTv77P/2pxX/b9d+uz/+m+QvPW4rn/9j1DxT/8Lxze/7P+O//dR3i/wc=","expression_width":{"Bounded":{"width":4}}},{"name":"__aztec_nr_internals__transfer","hash":"6121433451104304666","is_unconstrained":true,"custom_attributes":["abi_public"],"abi":{"parameters":[{"name":"from","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"to","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"token_id","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"private"}],"return_type":null,"error_types":{"459713770342432051":{"error_kind":"string","string":"Not initialized"},"792767957093445390":{"error_kind":"string","string":"Only owner can transfer"},"3056898550702170717":{"error_kind":"string","string":"Cannot transfer to zero address"},"10826617868182774729":{"error_kind":"string","string":"Token does not exist"},"10837321964194770293":{"error_kind":"fmtstring","length":22,"item_types":[]},"13455385521185560676":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"13807813574466708314":{"error_kind":"string","string":"From address is not the owner"},"15764276373176857197":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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","expression_width":{"Bounded":{"width":4}}},{"name":"process_message","hash":"11648002555408292521","is_unconstrained":true,"custom_attributes":["abi_utility"],"abi":{"parameters":[{"name":"message_ciphertext","type":{"kind":"struct","path":"std::collections::bounded_vec::BoundedVec","fields":[{"name":"storage","type":{"kind":"array","length":17,"type":{"kind":"field"}}},{"name":"len","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"private"},{"name":"message_context","type":{"kind":"struct","path":"aztec::messages::processing::message_context::MessageContext","fields":[{"name":"tx_hash","type":{"kind":"field"}},{"name":"unique_note_hashes_in_tx","type":{"kind":"struct","path":"std::collections::bounded_vec::BoundedVec","fields":[{"name":"storage","type":{"kind":"array","length":64,"type":{"kind":"field"}}},{"name":"len","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"first_nullifier_in_tx","type":{"kind":"field"}},{"name":"recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]},"visibility":"private"}],"return_type":null,"error_types":{"361444214588792908":{"error_kind":"string","string":"attempt to multiply with overflow"},"992401946138144806":{"error_kind":"string","string":"Attempted to read past end of BoundedVec"},"1998584279744703196":{"error_kind":"string","string":"attempt to subtract with overflow"},"3080037330898348111":{"error_kind":"fmtstring","length":132,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"4261968856572588300":{"error_kind":"string","string":"Value does not fit in field"},"4440399188109668273":{"error_kind":"string","string":"Input length must be a multiple of 32"},"6504742485148360234":{"error_kind":"fmtstring","length":40,"item_types":[]},"7564993426627941149":{"error_kind":"fmtstring","length":48,"item_types":[{"kind":"field"},{"kind":"field"}]},"7995966536718645961":{"error_kind":"fmtstring","length":61,"item_types":[{"kind":"field"},{"kind":"field"}]},"9791669845391776238":{"error_kind":"string","string":"0 has a square root; you cannot claim it is not square"},"9885968605480832328":{"error_kind":"string","string":"Attempted to read past the length of a CapsuleArray"},"10791800398362570014":{"error_kind":"string","string":"extend_from_bounded_vec out of bounds"},"11021520179822076911":{"error_kind":"string","string":"Attempted to delete past the length of a CapsuleArray"},"12469291177396340830":{"error_kind":"string","string":"call to assert_max_bit_size"},"12913276134398371456":{"error_kind":"string","string":"push out of bounds"},"13060541637244024094":{"error_kind":"fmtstring","length":98,"item_types":[]},"13450089406971132036":{"error_kind":"fmtstring","length":144,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"14990209321349310352":{"error_kind":"string","string":"attempt to add with overflow"},"15764276373176857197":{"error_kind":"string","string":"Stack too deep"},"16431471497789672479":{"error_kind":"string","string":"Index out of bounds"},"16792019527863081935":{"error_kind":"fmtstring","length":77,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"17154023812102399658":{"error_kind":"fmtstring","length":128,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"17803644318014042523":{"error_kind":"fmtstring","length":58,"item_types":[{"kind":"field"}]}}},"bytecode":"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","debug_symbols":"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","expression_width":{"Bounded":{"width":4}}},{"name":"public_dispatch","hash":"3007754719373226082","is_unconstrained":true,"custom_attributes":["abi_public"],"abi":{"parameters":[{"name":"selector","type":{"kind":"field"},"visibility":"private"}],"return_type":null,"error_types":{"459713770342432051":{"error_kind":"string","string":"Not initialized"},"772947778646992575":{"error_kind":"string","string":"Minter cannot be zero address"},"792767957093445390":{"error_kind":"string","string":"Only owner can transfer"},"1998584279744703196":{"error_kind":"string","string":"attempt to subtract with overflow"},"3056898550702170717":{"error_kind":"string","string":"Cannot transfer to zero address"},"5197614757850103533":{"error_kind":"string","string":"Only minter can mint"},"9967937311635654895":{"error_kind":"string","string":"Initialization hash does not match"},"10826617868182774729":{"error_kind":"string","string":"Token does not exist"},"10837321964194770293":{"error_kind":"fmtstring","length":22,"item_types":[]},"13455385521185560676":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"13807813574466708314":{"error_kind":"string","string":"From address is not the owner"},"14415304921900233953":{"error_kind":"string","string":"Initializer address is not the contract deployer"},"14990209321349310352":{"error_kind":"string","string":"attempt to add with overflow"},"15764276373176857197":{"error_kind":"string","string":"Stack too deep"},"15978124792480278163":{"error_kind":"string","string":"Cannot mint to zero address"},"16431471497789672479":{"error_kind":"string","string":"Index out of bounds"},"16810041750452690220":{"error_kind":"fmtstring","length":27,"item_types":[{"kind":"field"}]}}},"bytecode":"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","debug_symbols":"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","expression_width":{"Bounded":{"width":4}}},{"name":"sync_private_state","hash":"3251773961400550375","is_unconstrained":true,"custom_attributes":["abi_utility"],"abi":{"parameters":[],"return_type":null,"error_types":{"361444214588792908":{"error_kind":"string","string":"attempt to multiply with overflow"},"992401946138144806":{"error_kind":"string","string":"Attempted to read past end of BoundedVec"},"1998584279744703196":{"error_kind":"string","string":"attempt to subtract with overflow"},"3080037330898348111":{"error_kind":"fmtstring","length":132,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"4261968856572588300":{"error_kind":"string","string":"Value does not fit in field"},"4440399188109668273":{"error_kind":"string","string":"Input length must be a multiple of 32"},"6504742485148360234":{"error_kind":"fmtstring","length":40,"item_types":[]},"7564993426627941149":{"error_kind":"fmtstring","length":48,"item_types":[{"kind":"field"},{"kind":"field"}]},"7995966536718645961":{"error_kind":"fmtstring","length":61,"item_types":[{"kind":"field"},{"kind":"field"}]},"9791669845391776238":{"error_kind":"string","string":"0 has a square root; you cannot claim it is not square"},"9885968605480832328":{"error_kind":"string","string":"Attempted to read past the length of a CapsuleArray"},"10791800398362570014":{"error_kind":"string","string":"extend_from_bounded_vec out of bounds"},"11021520179822076911":{"error_kind":"string","string":"Attempted to delete past the length of a CapsuleArray"},"12469291177396340830":{"error_kind":"string","string":"call to assert_max_bit_size"},"12913276134398371456":{"error_kind":"string","string":"push out of bounds"},"13060541637244024094":{"error_kind":"fmtstring","length":98,"item_types":[]},"13450089406971132036":{"error_kind":"fmtstring","length":144,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"14990209321349310352":{"error_kind":"string","string":"attempt to add with overflow"},"15764276373176857197":{"error_kind":"string","string":"Stack too deep"},"16431471497789672479":{"error_kind":"string","string":"Index out of bounds"},"16792019527863081935":{"error_kind":"fmtstring","length":77,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"17154023812102399658":{"error_kind":"fmtstring","length":128,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"17803644318014042523":{"error_kind":"fmtstring","length":58,"item_types":[{"kind":"field"}]}}},"bytecode":"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","debug_symbols":"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1FqoUSABGdiAeR2S2MwuUYEGdOAojFxyIQEZGGfBgX5d6iQK32TW70hsUJdIQAY2YAcKMNqhT1S0r+KMFWesHSjAaF8JNKADR6GhNw1qht409KahNw29aehNszoGc+AodPSmUx2DM7ABoeZQc6g5xo5j7DjGzsC5DYydgZYcaMmBllyej2MYaMmBlhxQg+cJnid4nuB5gucJnqdH9Rstzy80oAOr32h5fiEBoQbPEzxP8DzB8wTPEzxP8Dxx9RsxARnYgB0YahqowFCzQAeOwuX5hVON4hjC8xc2YAcKUIEGdOBUozjI6fnEuH+Iluw9XRjby8l8y0Fie7lEAzoQPSToIUEPCQMbsAMFiB4S9JCghwQ9pBh9yBqkGA+K8aAYD5EfZs2eRNVf4iiM/EDRDpEfKI4s8sOFDdiBAlSgAR04CiMTUIySyAQXdqAAFWhAB47CyAQXEhBqA2oDagNqA2oDagNqo9Si6i+RgAxswA4UoAIN6ECoEdQIagQ1ghpBjaBGUCOoEdQIagw1hhpDjaHGUGOoMdQYagw1hlqDWoNag1qDWoNag1qDWoNag1qDWodah1qHWodah1qHWodah1qHWoeaQE2gJlATqAnUBGoCNYGaQE2gplBTqCnUFGoKNYWaQk2hplBTqBnUDGoGNYOaQc2gZlAzqBnUDGoONYcacgkjlzByCSOXMHIJI5cwcgkjlzByCSOXMHIJI5cwcgkjlzByCSOXMHIJI5c05JKGXNKQSxpySUMuacglDbmkIZc05JKGXNKQSxpySUMuacglDbmkIZc05JKGXNKQSxpySUMuacglDbmkIZc05JKGXNKQSxpySUMuacglDbmkIZc05JKGXNKQSxpySUMuacglDbmkIZc05JKGXNKQSxpySUMuacglDbmkIZc05JKGXNKQSxpySUMuacglDbmkIZc05JKGXNKQSxpySUMuacglDbmkIZc05JKGXNKQSxpySUMuacglDbmkIZc05JKGXNKQSxpySUMuacglDbmkIZc05JKGXNKQSxpySUMuacglbeUSCzSgA0fhyiULCcjABuxAAUJtQG1AbZRafzyABGRgA3agAGPtVgMN6MBRSA8gAUNtBDZgB061+a6GRIFlogEdOAojl1w4z22+4iFRYCnzQ2QSBZaJHShABRrQgaMwcsmFBIRay3VpiQLLRAHmurREgWWi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","expression_width":{"Bounded":{"width":4}}}],"outputs":{"structs":{"events":[{"kind":"struct","path":"HatNFT::HatMinted","fields":[{"name":"token_id","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"owner","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"game_id","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"hat_type","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"hat_quality","type":{"kind":"integer","sign":"unsigned","width":8}}]},{"kind":"struct","path":"HatNFT::HatTransferred","fields":[{"name":"token_id","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"from","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"to","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}],"functions":[{"kind":"struct","path":"HatNFT::constructor_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"HatNFT::constructor_parameters","fields":[{"name":"_chess_contract","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]},{"kind":"struct","path":"HatNFT::exists_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"HatNFT::exists_parameters","fields":[{"name":"_token_id","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"return_type","type":{"kind":"boolean"}}]},{"kind":"struct","path":"HatNFT::get_hat_metadata_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"HatNFT::get_hat_metadata_parameters","fields":[{"name":"_token_id","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"return_type","type":{"kind":"tuple","fields":[{"kind":"integer","sign":"unsigned","width":32},{"kind":"integer","sign":"unsigned","width":8},{"kind":"integer","sign":"unsigned","width":8}]}}]},{"kind":"struct","path":"HatNFT::get_minter_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"HatNFT::get_minter_parameters","fields":[]}},{"name":"return_type","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]},{"kind":"struct","path":"HatNFT::mint_hat_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"HatNFT::mint_hat_parameters","fields":[{"name":"_to","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"_game_id","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"_winner_elo","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"_loser_elo","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]},{"kind":"struct","path":"HatNFT::owner_of_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"HatNFT::owner_of_parameters","fields":[{"name":"_token_id","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"return_type","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]},{"kind":"struct","path":"HatNFT::process_message_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"HatNFT::process_message_parameters","fields":[{"name":"message_ciphertext","type":{"kind":"struct","path":"std::collections::bounded_vec::BoundedVec","fields":[{"name":"storage","type":{"kind":"array","length":17,"type":{"kind":"field"}}},{"name":"len","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"message_context","type":{"kind":"struct","path":"aztec::messages::processing::message_context::MessageContext","fields":[{"name":"tx_hash","type":{"kind":"field"}},{"name":"unique_note_hashes_in_tx","type":{"kind":"struct","path":"std::collections::bounded_vec::BoundedVec","fields":[{"name":"storage","type":{"kind":"array","length":64,"type":{"kind":"field"}}},{"name":"len","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"first_nullifier_in_tx","type":{"kind":"field"}},{"name":"recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]}}]},{"kind":"struct","path":"HatNFT::sync_private_state_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"HatNFT::sync_private_state_parameters","fields":[]}}]},{"kind":"struct","path":"HatNFT::total_supply_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"HatNFT::total_supply_parameters","fields":[]}},{"name":"return_type","type":{"kind":"integer","sign":"unsigned","width":32}}]},{"kind":"struct","path":"HatNFT::transfer_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"HatNFT::transfer_parameters","fields":[{"name":"_from","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"_to","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"_token_id","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}]},"globals":{"storage":[{"kind":"struct","fields":[{"name":"contract_name","value":{"kind":"string","value":"HatNFT"}},{"name":"fields","value":{"kind":"struct","fields":[{"name":"token_counter","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}]}},{"name":"public_owners","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}}]}},{"name":"nft_exists","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000003"}}]}},{"name":"hat_game_ids","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000004"}}]}},{"name":"hat_types","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000005"}}]}},{"name":"hat_qualities","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000006"}}]}},{"name":"minter","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000007"}}]}}]}}]}]}},"file_map":{"3":{"source":"use crate::cmp::{Eq, Ord};\nuse crate::convert::From;\nuse crate::runtime::is_unconstrained;\n\nmod check_shuffle;\nmod quicksort;\n\nimpl<T, let N: u32> [T; N] {\n    /// Returns the length of this array.\n    ///\n    /// ```noir\n    /// fn len(self) -> Field\n    /// ```\n    ///\n    /// example\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let array = [42, 42];\n    ///     assert(array.len() == 2);\n    /// }\n    /// ```\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Returns this array as a slice.\n    ///\n    /// ```noir\n    /// let array = [1, 2];\n    /// let slice = array.as_slice();\n    /// assert_eq(slice, &[1, 2]);\n    /// ```\n    #[builtin(as_slice)]\n    pub fn as_slice(self) -> [T] {}\n\n    /// Applies a function to each element of this array, returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.map(|a| a * 2);\n    /// assert_eq(b, [2, 4, 6]);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array along with its index,\n    /// returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.mapi(|i, a| i + a * 2);\n    /// assert_eq(b, [2, 5, 8]);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(i, self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// let mut i = 0;\n    /// a.for_each(|x| {\n    ///     b[i] = x;\n    ///     i += 1;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for i in 0..self.len() {\n            f(self[i]);\n        }\n    }\n\n    /// Applies a function to each element of this array along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// a.for_eachi(|i, x| {\n    ///     b[i] = x;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        for i in 0..self.len() {\n            f(i, self[i]);\n        }\n    }\n\n    /// Applies a function to each element of the array, returning the final accumulated value. The first\n    /// parameter is the initial value.\n    ///\n    /// This is a left fold, so the given function will be applied to the accumulator and first element of\n    /// the array, then the second, and so on. For a given call the expected result would be equivalent to:\n    ///\n    /// ```rust\n    /// let a1 = [1];\n    /// let a2 = [1, 2];\n    /// let a3 = [1, 2, 3];\n    ///\n    /// let f = |a, b| a - b;\n    /// a1.fold(10, f); //=> f(10, 1)\n    /// a2.fold(10, f); //=> f(f(10, 1), 2)\n    /// a3.fold(10, f); //=> f(f(f(10, 1), 2), 3)\n    ///\n    /// assert_eq(a3.fold(10, f), 10 - 1 - 2 - 3);\n    /// ```\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    /// Same as fold, but uses the first element as the starting element.\n    ///\n    /// Requires the input array to be non-empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [1, 2, 3, 4];\n    ///     let reduced = arr.reduce(|a, b| a + b);\n    ///     assert(reduced == 10);\n    /// }\n    /// ```\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    /// Returns true if all the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 2];\n    ///     let all = arr.all(|a| a == 2);\n    ///     assert(all);\n    /// }\n    /// ```\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    /// Returns true if any of the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 5];\n    ///     let any = arr.any(|a| a == 5);\n    ///     assert(any);\n    /// }\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n\n    /// Concatenates this array with another array.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr1 = [1, 2, 3, 4];\n    ///     let arr2 = [6, 7, 8, 9, 10, 11];\n    ///     let concatenated_arr = arr1.concat(arr2);\n    ///     assert(concatenated_arr == [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    /// }\n    /// ```\n    pub fn concat<let M: u32>(self, array2: [T; M]) -> [T; N + M] {\n        let mut result = [crate::mem::zeroed(); N + M];\n        for i in 0..N {\n            result[i] = self[i];\n        }\n        for i in 0..M {\n            result[i + N] = array2[i];\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Ord + Eq,\n{\n    /// Returns a new sorted array. The original array remains untouched. Notice that this function will\n    /// only work for arrays of fields or integers, not for any arbitrary type. This is because the sorting\n    /// logic it uses internally is optimized specifically for these values. If you need a sort function to\n    /// sort any type, you should use the [`Self::sort_via`] function.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32];\n    ///     let sorted = arr.sort();\n    ///     assert(sorted == [32, 42]);\n    /// }\n    /// ```\n    pub fn sort(self) -> Self {\n        self.sort_via(|a, b| a <= b)\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Eq,\n{\n    /// Returns a new sorted array by sorting it with a custom comparison function.\n    /// The original array remains untouched.\n    /// The ordering function must return true if the first argument should be sorted to be before the second argument or is equal to the second argument.\n    ///\n    /// Using this method with an operator like `<` that does not return `true` for equal values will result in an assertion failure for arrays with equal elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32]\n    ///     let sorted_ascending = arr.sort_via(|a, b| a <= b);\n    ///     assert(sorted_ascending == [32, 42]); // verifies\n    ///\n    ///     let sorted_descending = arr.sort_via(|a, b| a >= b);\n    ///     assert(sorted_descending == [32, 42]); // does not verify\n    /// }\n    /// ```\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        // Safety: `sorted` array is checked to be:\n        // a. a permutation of `input`'s elements\n        // b. satisfying the predicate `ordering`\n        let sorted = unsafe { quicksort::quicksort(self, ordering) };\n\n        if !is_unconstrained() {\n            for i in 0..N - 1 {\n                assert(\n                    ordering(sorted[i], sorted[i + 1]),\n                    \"Array has not been sorted correctly according to `ordering`.\",\n                );\n            }\n            check_shuffle::check_shuffle(self, sorted);\n        }\n        sorted\n    }\n}\n\nimpl<let N: u32> [u8; N] {\n    /// Converts a byte array of type `[u8; N]` to a string. Note that this performs no UTF-8 validation -\n    /// the given array is interpreted as-is as a string.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let hi = [104, 105].as_str_unchecked();\n    ///     assert_eq(hi, \"hi\");\n    /// }\n    /// ```\n    #[builtin(array_as_str_unchecked)]\n    pub fn as_str_unchecked(self) -> str<N> {}\n}\n\nimpl<let N: u32> From<str<N>> for [u8; N] {\n    /// Returns an array of the string bytes.\n    fn from(s: str<N>) -> Self {\n        s.as_bytes()\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq([].map(|x| x + 1), []);\n    }\n\n    global arr_with_100_values: [u32; 100] = [\n        42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2, 54,\n        89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41, 19, 98,\n        53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21, 43, 86, 35,\n        21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15, 127, 81, 30, 8,\n        125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n    ];\n    global expected_with_100_values: [u32; 100] = [\n        0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30, 32,\n        32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58, 61, 62,\n        62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82, 84, 84, 86,\n        86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114, 114, 116, 118,\n        119, 120, 121, 123, 123, 123, 125, 126, 127,\n    ];\n    fn sort_u32(a: u32, b: u32) -> bool {\n        a <= b\n    }\n\n    #[test]\n    fn test_sort() {\n        let mut arr: [u32; 7] = [3, 6, 8, 10, 1, 2, 1];\n\n        let sorted = arr.sort();\n\n        let expected: [u32; 7] = [1, 1, 2, 3, 6, 8, 10];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_100_values() {\n        let mut arr: [u32; 100] = [\n            42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2,\n            54, 89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41,\n            19, 98, 53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21,\n            43, 86, 35, 21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15,\n            127, 81, 30, 8, 125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n        ];\n\n        let sorted = arr.sort();\n\n        let expected: [u32; 100] = [\n            0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30,\n            32, 32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58,\n            61, 62, 62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82,\n            84, 84, 86, 86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114,\n            114, 116, 118, 119, 120, 121, 123, 123, 123, 125, 126, 127,\n        ];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_100_values_comptime() {\n        let sorted = arr_with_100_values.sort();\n        assert(sorted == expected_with_100_values);\n    }\n\n    #[test]\n    fn test_sort_via() {\n        let mut arr: [u32; 7] = [3, 6, 8, 10, 1, 2, 1];\n\n        let sorted = arr.sort_via(sort_u32);\n\n        let expected: [u32; 7] = [1, 1, 2, 3, 6, 8, 10];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_via_100_values() {\n        let mut arr: [u32; 100] = [\n            42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2,\n            54, 89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41,\n            19, 98, 53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21,\n            43, 86, 35, 21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15,\n            127, 81, 30, 8, 125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n        ];\n\n        let sorted = arr.sort_via(sort_u32);\n\n        let expected: [u32; 100] = [\n            0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30,\n            32, 32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58,\n            61, 62, 62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82,\n            84, 84, 86, 86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114,\n            114, 116, 118, 119, 120, 121, 123, 123, 123, 125, 126, 127,\n        ];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq([].mapi(|i, x| i * x + 1), []);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_each(|_x| assert(false));\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_eachi(|_i, _x| assert(false));\n    }\n\n    #[test]\n    fn map_example() {\n        let a = [1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, [2, 4, 6]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = [1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        let mut i = 0;\n        let i_ref = &mut i;\n        a.for_each(|x| {\n            b_ref[*i_ref] = x * 2;\n            *i_ref += 1;\n        });\n        assert_eq(b, [2, 4, 6]);\n        assert_eq(i, 3);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { b_ref[i] = i + a * 2; });\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn concat() {\n        let arr1 = [1, 2, 3, 4];\n        let arr2 = [6, 7, 8, 9, 10, 11];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    }\n\n    #[test]\n    fn concat_zero_length_with_something() {\n        let arr1 = [];\n        let arr2 = [1];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_something_with_zero_length() {\n        let arr1 = [1];\n        let arr2 = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_zero_lengths() {\n        let arr1: [Field; 0] = [];\n        let arr2: [Field; 0] = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, []);\n    }\n}\n","path":"std/array/mod.nr"},"5":{"source":"use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { $crate::cmp::Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        if result {\n            for i in 0..self.len() {\n                result &= self[i].eq(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let name = quote { $crate::cmp::Ord };\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> $crate::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == $crate::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = $crate::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, name, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let self_len = self.len();\n        let other_len = other.len();\n        let min_len = if self_len < other_len {\n            self_len\n        } else {\n            other_len\n        };\n\n        let mut result = Ordering::equal();\n        for i in 0..min_len {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self_len.cmp(other_len)\n        }\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use super::{Eq, max, min, Ord};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0_u64, 1), 0);\n        assert_eq(min(0_u64, 0), 0);\n        assert_eq(min(1_u64, 1), 1);\n        assert_eq(min(255_u8, 0), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0_u64, 1), 1);\n        assert_eq(max(0_u64, 0), 0);\n        assert_eq(max(1_u64, 1), 1);\n        assert_eq(max(255_u8, 0), 255);\n    }\n\n    #[test]\n    fn correctly_handles_unequal_length_slices() {\n        let slice_1 = &[0, 1, 2, 3];\n        let slice_2 = &[0, 1, 2];\n        assert(!slice_1.eq(slice_2));\n    }\n\n    #[test]\n    fn lexicographic_ordering_for_slices() {\n        assert(&[2_u32].cmp(&[1_u32, 1_u32, 1_u32]) == super::Ordering::greater());\n        assert(&[1_u32, 2_u32].cmp(&[1_u32, 2_u32, 3_u32]) == super::Ordering::less());\n    }\n}\n","path":"std/cmp.nr"},"6":{"source":"use crate::{cmp::Eq, convert::From, runtime::is_unconstrained, static_assert};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a [`Vec`][crate::collections::vec::Vec]`<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        if is_unconstrained() {\n            for i in 0..append_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..Len {\n                exceeded_len |= i == append_len;\n                if !exceeded_len {\n                    self.storage[self.len + i] = vec.get_unchecked(i);\n                }\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        static_assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0, \"cannot pop from an empty vector\");\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        if is_unconstrained() {\n            for i in 0..self.len {\n                ret |= predicate(self.storage[i]);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..MaxLen {\n                exceeded_len |= i == self.len;\n                if !exceeded_len {\n                    ret |= predicate(self.storage[i]);\n                }\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element\n    /// in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.mapi(|i, value| i + value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(i, self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Calls a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_each(|value| result.push(value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Calls a closure on each element in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_eachi(|i, value| result.push(i + value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(i, self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use [`from_parts_unchecked`][Self::from_parts_unchecked] to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n\n        if is_unconstrained() {\n            for i in len..MaxLen {\n                array[i] = zeroed;\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i >= len {\n                    array[i] = zeroed;\n                }\n            }\n        }\n\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            let _ = vec.get(0);\n        }\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_beyond_length() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            let _ = vec.get(3);\n        }\n\n        #[test]\n        fn get_works_within_bounds() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(2), 3);\n            assert_eq(vec.get(4), 5);\n        }\n\n        #[test]\n        fn get_unchecked_works() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            assert_eq(vec.get_unchecked(0), 1);\n            assert_eq(vec.get_unchecked(2), 3);\n        }\n\n        #[test]\n        fn get_unchecked_works_past_len() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            assert_eq(vec.get_unchecked(4), 0);\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_setting_beyond_length() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            vec.set(3, 4);\n        }\n\n        #[test]\n        fn set_unchecked_operations() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n\n            vec.set_unchecked(0, 10);\n            assert_eq(vec.get(0), 10);\n        }\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn set_unchecked_operations_past_len() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n\n            vec.set_unchecked(3, 40);\n            assert_eq(vec.get(3), 40);\n        }\n\n        #[test]\n        fn set_preserves_other_elements() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n\n            vec.set(2, 30);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 30);\n            assert_eq(vec.get(3), 4);\n            assert_eq(vec.get(4), 5);\n        }\n    }\n\n    mod any {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn returns_false_if_predicate_not_satisfied() {\n            let vec: BoundedVec<bool, 4> = BoundedVec::from_array([false, false, false, false]);\n            let result = vec.any(|value| value);\n\n            assert(!result);\n        }\n\n        #[test]\n        fn returns_true_if_predicate_satisfied() {\n            let vec: BoundedVec<bool, 4> = BoundedVec::from_array([false, false, true, true]);\n            let result = vec.any(|value| value);\n\n            assert(result);\n        }\n\n        #[test]\n        fn returns_false_on_empty_boundedvec() {\n            let vec: BoundedVec<bool, 0> = BoundedVec::new();\n            let result = vec.any(|value| value);\n\n            assert(!result);\n        }\n\n        #[test]\n        fn any_with_complex_predicates() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n\n            assert(vec.any(|x| x > 3));\n            assert(!vec.any(|x| x > 10));\n            assert(vec.any(|x| x % 2 == 0)); // has a even number\n            assert(vec.any(|x| x == 3)); // has a specific value\n        }\n\n        #[test]\n        fn any_with_partial_vector() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n\n            assert(vec.any(|x| x == 1));\n            assert(vec.any(|x| x == 2));\n            assert(!vec.any(|x| x == 3));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn map_with_conditional_logic() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n\n            let result = vec.map(|x| if x % 2 == 0 { x * 2 } else { x });\n            let expected = BoundedVec::from_array([1, 4, 3, 8]);\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn map_preserves_length() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|x| x * 2);\n\n            assert_eq(result.len(), vec.len());\n            assert_eq(result.max_len(), vec.max_len());\n        }\n\n        #[test]\n        fn map_on_empty_vector() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let result = vec.map(|x| x * 2);\n            assert_eq(result, vec);\n            assert_eq(result.len(), 0);\n            assert_eq(result.max_len(), 5);\n        }\n    }\n\n    mod mapi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-mapi-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| i + value * 2);\n            // docs:end:bounded-vec-mapi-example\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.mapi(|_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn mapi_with_index_branching_logic() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n\n            let result = vec.mapi(|i, x| if i % 2 == 0 { x * 2 } else { x });\n            let expected = BoundedVec::from_array([2, 2, 6, 4]);\n            assert_eq(result, expected);\n        }\n    }\n\n    mod for_each {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // map in terms of for_each\n        fn for_each_map<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_each(|x| output_ref.push(f(x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-each-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_each(|value| { *acc_ref += value; });\n            // docs:end:bounded-vec-for-each-example\n            assert_eq(acc, 6);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| value * 2);\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_each_map(vec, |value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn for_each_on_empty_vector() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let mut count = 0;\n            let count_ref = &mut count;\n            vec.for_each(|_| { *count_ref += 1; });\n            assert_eq(count, 0);\n        }\n\n        #[test]\n        fn for_each_with_side_effects() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            let mut seen = BoundedVec::<u32, 3>::new();\n            let seen_ref = &mut seen;\n            vec.for_each(|x| seen_ref.push(x));\n            assert_eq(seen, vec);\n        }\n    }\n\n    mod for_eachi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // mapi in terms of for_eachi\n        fn for_eachi_mapi<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](u32, T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_eachi(|i, x| output_ref.push(f(i, x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-eachi-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_eachi(|i, value| { *acc_ref += i * value; });\n            // docs:end:bounded-vec-for-eachi-example\n\n            // 0 * 1 + 1 * 2 + 2 * 3\n            assert_eq(acc, 8);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| i + value * 2);\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_eachi_mapi(vec, |_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn for_eachi_on_empty_vector() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let mut count = 0;\n            let count_ref = &mut count;\n            vec.for_eachi(|_, _| { *count_ref += 1; });\n            assert_eq(count, 0);\n        }\n\n        #[test]\n        fn for_eachi_with_index_tracking() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([10, 20, 30]);\n            let mut indices = BoundedVec::<u32, 3>::new();\n            let indices_ref = &mut indices;\n            vec.for_eachi(|i, _| indices_ref.push(i));\n\n            let expected = BoundedVec::from_array([0, 1, 2]);\n            assert_eq(indices, expected);\n        }\n\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n\n        #[test]\n        fn from_array_preserves_order() {\n            let array = [5, 3, 1, 4, 2];\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array(array);\n            for i in 0..array.len() {\n                assert_eq(vec.get(i), array[i]);\n            }\n        }\n\n        #[test]\n        fn from_array_with_different_types() {\n            let bool_array = [true, false, true];\n            let bool_vec: BoundedVec<bool, 3> = BoundedVec::from_array(bool_array);\n            assert_eq(bool_vec.len(), 3);\n            assert_eq(bool_vec.get(0), true);\n            assert_eq(bool_vec.get(1), false);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n        use crate::convert::From;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n\n    mod push_pop {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn push_and_pop_operations() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n\n            assert_eq(vec.len(), 0);\n\n            vec.push(1);\n            assert_eq(vec.len(), 1);\n            assert_eq(vec.get(0), 1);\n\n            vec.push(2);\n            assert_eq(vec.len(), 2);\n            assert_eq(vec.get(1), 2);\n\n            let popped = vec.pop();\n            assert_eq(popped, 2);\n            assert_eq(vec.len(), 1);\n\n            let popped2 = vec.pop();\n            assert_eq(popped2, 1);\n            assert_eq(vec.len(), 0);\n        }\n\n        #[test(should_fail_with = \"push out of bounds\")]\n        fn push_to_full_vector() {\n            let mut vec: BoundedVec<u32, 2> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n            vec.push(3); // should panic\n        }\n\n        #[test(should_fail_with = \"cannot pop from an empty vector\")]\n        fn pop_from_empty_vector() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let _ = vec.pop(); // should panic\n        }\n\n        #[test]\n        fn push_pop_cycle() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n\n            // push to full\n            vec.push(1);\n            vec.push(2);\n            vec.push(3);\n            assert_eq(vec.len(), 3);\n\n            // pop all\n            assert_eq(vec.pop(), 3);\n            assert_eq(vec.pop(), 2);\n            assert_eq(vec.pop(), 1);\n            assert_eq(vec.len(), 0);\n\n            // push again\n            vec.push(4);\n            assert_eq(vec.len(), 1);\n            assert_eq(vec.get(0), 4);\n        }\n    }\n\n    mod extend {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn extend_from_array() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_array([2, 3]);\n\n            assert_eq(vec.len(), 3);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 3);\n        }\n\n        #[test]\n        fn extend_from_slice() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_slice(&[2, 3]);\n\n            assert_eq(vec.len(), 3);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 3);\n        }\n\n        #[test]\n        fn extend_from_bounded_vec() {\n            let mut vec1: BoundedVec<u32, 5> = BoundedVec::new();\n            let mut vec2: BoundedVec<u32, 3> = BoundedVec::new();\n\n            vec1.push(1);\n            vec2.push(2);\n            vec2.push(3);\n\n            vec1.extend_from_bounded_vec(vec2);\n\n            assert_eq(vec1.len(), 3);\n            assert_eq(vec1.get(0), 1);\n            assert_eq(vec1.get(1), 2);\n            assert_eq(vec1.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"extend_from_array out of bounds\")]\n        fn extend_array_beyond_max_len() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_array([2, 3, 4]); // should panic\n        }\n\n        #[test(should_fail_with = \"extend_from_slice out of bounds\")]\n        fn extend_slice_beyond_max_len() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_slice(&[2, 3, 4]); // S]should panic\n        }\n\n        #[test(should_fail_with = \"extend_from_bounded_vec out of bounds\")]\n        fn extend_bounded_vec_beyond_max_len() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n            let other: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n            vec.extend_from_bounded_vec(other); // should panic\n        }\n\n        #[test]\n        fn extend_with_empty_collections() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let original_len = vec.len();\n\n            vec.extend_from_array([]);\n            assert_eq(vec.len(), original_len);\n\n            vec.extend_from_slice(&[]);\n            assert_eq(vec.len(), original_len);\n\n            let empty: BoundedVec<u32, 3> = BoundedVec::new();\n            vec.extend_from_bounded_vec(empty);\n            assert_eq(vec.len(), original_len);\n        }\n    }\n\n    mod storage {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn storage_consistency() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n\n            // test initial storage state\n            assert_eq(vec.storage(), [0, 0, 0, 0, 0]);\n\n            vec.push(1);\n            vec.push(2);\n\n            // test storage after modifications\n            assert_eq(vec.storage(), [1, 2, 0, 0, 0]);\n\n            // storage doesn't change length\n            assert_eq(vec.len(), 2);\n            assert_eq(vec.max_len(), 5);\n        }\n\n        #[test]\n        fn storage_after_pop() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n\n            let _ = vec.pop();\n            // after pop, the last element should be zeroed\n            assert_eq(vec.storage(), [1, 2, 0]);\n            assert_eq(vec.len(), 2);\n        }\n\n        #[test]\n        fn vector_immutable() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            let storage = vec.storage();\n\n            assert_eq(storage, [1, 2, 3]);\n\n            // Verify that the original vector is unchanged\n            assert_eq(vec.len(), 3);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 3);\n        }\n    }\n}\n","path":"std/collections/bounded_vec.nr"},"17":{"source":"use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\npub(crate) global PLO: Field = 53438638232309528389504892708671455233;\npub(crate) global PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n\n    #[test]\n    fn check_decompose_edge_cases() {\n        assert_eq(decompose(0), (0, 0));\n        assert_eq(decompose(TWO_POW_128 - 1), (TWO_POW_128 - 1, 0));\n        assert_eq(decompose(TWO_POW_128 + 1), (1, 1));\n        assert_eq(decompose(TWO_POW_128 * 2), (0, 2));\n        assert_eq(decompose(TWO_POW_128 * 2 + 0x1234567890), (0x1234567890, 2));\n    }\n\n    #[test]\n    fn check_decompose_large_values() {\n        let large_field = 0xffffffffffffffff;\n        let (lo, hi) = decompose(large_field);\n        assert_eq(large_field, lo + TWO_POW_128 * hi);\n\n        let large_value = large_field - TWO_POW_128;\n        let (lo2, hi2) = decompose(large_value);\n        assert_eq(large_value, lo2 + TWO_POW_128 * hi2);\n    }\n\n    #[test]\n    fn check_lt_comprehensive() {\n        assert(lt(0, 1));\n        assert(!lt(1, 0));\n        assert(!lt(0, 0));\n        assert(!lt(42, 42));\n\n        assert(lt(TWO_POW_128 - 1, TWO_POW_128));\n        assert(!lt(TWO_POW_128, TWO_POW_128 - 1));\n    }\n}\n","path":"std/field/bn254.nr"},"18":{"source":"pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        __assert_max_bit_size(self, BIT_SIZE);\n    }\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = __to_le_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = __to_be_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_le_radix(self, radix)\n    }\n\n    fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_be_radix(self, radix)\n    }\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(apply_range_constraint)]\nfn __assert_max_bit_size(value: Field, bit_size: u32) {}\n\n// `_radix` must be less than 256\n#[builtin(to_le_radix)]\nfn __to_le_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n// `_radix` must be less than 256\n#[builtin(to_be_radix)]\nfn __to_be_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n/// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n/// This slice will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_le_bits)]\nfn __to_le_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n/// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n/// This array will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_be_bits)]\nfn __to_be_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime, static_assert};\n    use super::{\n        field_less_than, modulus_be_bits, modulus_be_bytes, modulus_le_bits, modulus_le_bytes,\n    };\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // Updated test to account for Brillig restriction that radix must be greater than 2\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_brillig_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 1;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    unconstrained fn not_enough_limbs_brillig() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    fn not_enough_limbs() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n\n    #[test]\n    unconstrained fn test_large_field_values_unconstrained() {\n        let large_field = 0xffffffffffffffff;\n\n        let bits: [u1; 64] = large_field.to_le_bits();\n        assert_eq(bits[0], 1);\n\n        let bytes: [u8; 8] = large_field.to_le_bytes();\n        assert_eq(Field::from_le_bytes::<8>(bytes), large_field);\n\n        let radix_bytes: [u8; 8] = large_field.to_le_radix(256);\n        assert_eq(Field::from_le_bytes::<8>(radix_bytes), large_field);\n    }\n\n    #[test]\n    fn test_large_field_values() {\n        let large_val = 0xffffffffffffffff;\n\n        let bits: [u1; 64] = large_val.to_le_bits();\n        assert_eq(bits[0], 1);\n\n        let bytes: [u8; 8] = large_val.to_le_bytes();\n        assert_eq(Field::from_le_bytes::<8>(bytes), large_val);\n\n        let radix_bytes: [u8; 8] = large_val.to_le_radix(256);\n        assert_eq(Field::from_le_bytes::<8>(radix_bytes), large_val);\n    }\n\n    #[test]\n    fn test_decomposition_edge_cases() {\n        let zero_bits: [u1; 8] = 0.to_le_bits();\n        assert_eq(zero_bits, [0; 8]);\n\n        let zero_bytes: [u8; 8] = 0.to_le_bytes();\n        assert_eq(zero_bytes, [0; 8]);\n\n        let one_bits: [u1; 8] = 1.to_le_bits();\n        let expected: [u1; 8] = [1, 0, 0, 0, 0, 0, 0, 0];\n        assert_eq(one_bits, expected);\n\n        let pow2_bits: [u1; 8] = 4.to_le_bits();\n        let expected: [u1; 8] = [0, 0, 1, 0, 0, 0, 0, 0];\n        assert_eq(pow2_bits, expected);\n    }\n\n    #[test]\n    fn test_pow_32() {\n        assert_eq(2.pow_32(3), 8);\n        assert_eq(3.pow_32(2), 9);\n        assert_eq(5.pow_32(0), 1);\n        assert_eq(7.pow_32(1), 7);\n\n        assert_eq(2.pow_32(10), 1024);\n\n        assert_eq(0.pow_32(5), 0);\n        assert_eq(0.pow_32(0), 1);\n\n        assert_eq(1.pow_32(100), 1);\n    }\n\n    #[test]\n    fn test_sgn0() {\n        assert_eq(0.sgn0(), 0);\n        assert_eq(2.sgn0(), 0);\n        assert_eq(4.sgn0(), 0);\n        assert_eq(100.sgn0(), 0);\n\n        assert_eq(1.sgn0(), 1);\n        assert_eq(3.sgn0(), 1);\n        assert_eq(5.sgn0(), 1);\n        assert_eq(101.sgn0(), 1);\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 8 limbs\")]\n    fn test_bit_decomposition_overflow() {\n        // 8 bits can't represent large field values\n        let large_val = 0x1000000000000000;\n        let _: [u1; 8] = large_val.to_le_bits();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 4 limbs\")]\n    fn test_byte_decomposition_overflow() {\n        // 4 bytes can't represent large field values\n        let large_val = 0x1000000000000000;\n        let _: [u8; 4] = large_val.to_le_bytes();\n    }\n\n    #[test]\n    fn test_to_from_be_bytes_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this byte produces the expected 32 BE bytes for (modulus - 1)\n            let mut p_minus_1_bytes: [u8; 32] = modulus_be_bytes().as_array();\n            assert(p_minus_1_bytes[32 - 1] > 0);\n            p_minus_1_bytes[32 - 1] -= 1;\n\n            let p_minus_1 = Field::from_be_bytes::<32>(p_minus_1_bytes);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 32 BE bytes produces the same bytes\n            let p_minus_1_converted_bytes: [u8; 32] = p_minus_1.to_be_bytes();\n            assert_eq(p_minus_1_converted_bytes, p_minus_1_bytes);\n\n            // checking that incrementing this byte produces 32 BE bytes for (modulus + 1)\n            let mut p_plus_1_bytes: [u8; 32] = modulus_be_bytes().as_array();\n            assert(p_plus_1_bytes[32 - 1] < 255);\n            p_plus_1_bytes[32 - 1] += 1;\n\n            let p_plus_1 = Field::from_be_bytes::<32>(p_plus_1_bytes);\n            assert_eq(p_plus_1, 1);\n\n            // checking that converting p_plus_1 to 32 BE bytes produces the same\n            // byte set to 1 as p_plus_1_bytes and otherwise zeroes\n            let mut p_plus_1_converted_bytes: [u8; 32] = p_plus_1.to_be_bytes();\n            assert_eq(p_plus_1_converted_bytes[32 - 1], 1);\n            p_plus_1_converted_bytes[32 - 1] = 0;\n            assert_eq(p_plus_1_converted_bytes, [0; 32]);\n\n            // checking that Field::from_be_bytes::<32> on the Field modulus produces 0\n            assert_eq(modulus_be_bytes().len(), 32);\n            let p = Field::from_be_bytes::<32>(modulus_be_bytes().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 32 BE bytes produces 32 zeroes\n            let p_bytes: [u8; 32] = 0.to_be_bytes();\n            assert_eq(p_bytes, [0; 32]);\n        }\n    }\n\n    #[test]\n    fn test_to_from_le_bytes_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this byte produces the expected 32 LE bytes for (modulus - 1)\n            let mut p_minus_1_bytes: [u8; 32] = modulus_le_bytes().as_array();\n            assert(p_minus_1_bytes[0] > 0);\n            p_minus_1_bytes[0] -= 1;\n\n            let p_minus_1 = Field::from_le_bytes::<32>(p_minus_1_bytes);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 32 BE bytes produces the same bytes\n            let p_minus_1_converted_bytes: [u8; 32] = p_minus_1.to_le_bytes();\n            assert_eq(p_minus_1_converted_bytes, p_minus_1_bytes);\n\n            // checking that incrementing this byte produces 32 LE bytes for (modulus + 1)\n            let mut p_plus_1_bytes: [u8; 32] = modulus_le_bytes().as_array();\n            assert(p_plus_1_bytes[0] < 255);\n            p_plus_1_bytes[0] += 1;\n\n            let p_plus_1 = Field::from_le_bytes::<32>(p_plus_1_bytes);\n            assert_eq(p_plus_1, 1);\n\n            // checking that converting p_plus_1 to 32 LE bytes produces the same\n            // byte set to 1 as p_plus_1_bytes and otherwise zeroes\n            let mut p_plus_1_converted_bytes: [u8; 32] = p_plus_1.to_le_bytes();\n            assert_eq(p_plus_1_converted_bytes[0], 1);\n            p_plus_1_converted_bytes[0] = 0;\n            assert_eq(p_plus_1_converted_bytes, [0; 32]);\n\n            // checking that Field::from_le_bytes::<32> on the Field modulus produces 0\n            assert_eq(modulus_le_bytes().len(), 32);\n            let p = Field::from_le_bytes::<32>(modulus_le_bytes().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 32 LE bytes produces 32 zeroes\n            let p_bytes: [u8; 32] = 0.to_le_bytes();\n            assert_eq(p_bytes, [0; 32]);\n        }\n    }\n\n    /// Convert a little endian bit array to a field element.\n    /// If the provided bit array overflows the field modulus then the Field will silently wrap around.\n    fn from_le_bits<let N: u32>(bits: [u1; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bits().len(),\n            \"N must be less than or equal to modulus_le_bits().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bits[i] as Field) * v;\n            v = v * 2;\n        }\n        result\n    }\n\n    /// Convert a big endian bit array to a field element.\n    /// If the provided bit array overflows the field modulus then the Field will silently wrap around.\n    fn from_be_bits<let N: u32>(bits: [u1; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bits[N - 1 - i] as Field) * v;\n            v = v * 2;\n        }\n        result\n    }\n\n    #[test]\n    fn test_to_from_be_bits_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this bit produces the expected 254 BE bits for (modulus - 1)\n            let mut p_minus_1_bits: [u1; 254] = modulus_be_bits().as_array();\n            assert(p_minus_1_bits[254 - 1] > 0);\n            p_minus_1_bits[254 - 1] -= 1;\n\n            let p_minus_1 = from_be_bits::<254>(p_minus_1_bits);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 254 BE bits produces the same bits\n            let p_minus_1_converted_bits: [u1; 254] = p_minus_1.to_be_bits();\n            assert_eq(p_minus_1_converted_bits, p_minus_1_bits);\n\n            // checking that incrementing this bit produces 254 BE bits for (modulus + 4)\n            let mut p_plus_4_bits: [u1; 254] = modulus_be_bits().as_array();\n            assert(p_plus_4_bits[254 - 3] < 1);\n            p_plus_4_bits[254 - 3] += 1;\n\n            let p_plus_4 = from_be_bits::<254>(p_plus_4_bits);\n            assert_eq(p_plus_4, 4);\n\n            // checking that converting p_plus_4 to 254 BE bits produces the same\n            // bit set to 1 as p_plus_4_bits and otherwise zeroes\n            let mut p_plus_4_converted_bits: [u1; 254] = p_plus_4.to_be_bits();\n            assert_eq(p_plus_4_converted_bits[254 - 3], 1);\n            p_plus_4_converted_bits[254 - 3] = 0;\n            assert_eq(p_plus_4_converted_bits, [0; 254]);\n\n            // checking that Field::from_be_bits::<254> on the Field modulus produces 0\n            assert_eq(modulus_be_bits().len(), 254);\n            let p = from_be_bits::<254>(modulus_be_bits().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 254 BE bytes produces 254 zeroes\n            let p_bits: [u1; 254] = 0.to_be_bits();\n            assert_eq(p_bits, [0; 254]);\n        }\n    }\n\n    #[test]\n    fn test_to_from_le_bits_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this bit produces the expected 254 LE bits for (modulus - 1)\n            let mut p_minus_1_bits: [u1; 254] = modulus_le_bits().as_array();\n            assert(p_minus_1_bits[0] > 0);\n            p_minus_1_bits[0] -= 1;\n\n            let p_minus_1 = from_le_bits::<254>(p_minus_1_bits);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 254 BE bits produces the same bits\n            let p_minus_1_converted_bits: [u1; 254] = p_minus_1.to_le_bits();\n            assert_eq(p_minus_1_converted_bits, p_minus_1_bits);\n\n            // checking that incrementing this bit produces 254 LE bits for (modulus + 4)\n            let mut p_plus_4_bits: [u1; 254] = modulus_le_bits().as_array();\n            assert(p_plus_4_bits[2] < 1);\n            p_plus_4_bits[2] += 1;\n\n            let p_plus_4 = from_le_bits::<254>(p_plus_4_bits);\n            assert_eq(p_plus_4, 4);\n\n            // checking that converting p_plus_4 to 254 LE bits produces the same\n            // bit set to 1 as p_plus_4_bits and otherwise zeroes\n            let mut p_plus_4_converted_bits: [u1; 254] = p_plus_4.to_le_bits();\n            assert_eq(p_plus_4_converted_bits[2], 1);\n            p_plus_4_converted_bits[2] = 0;\n            assert_eq(p_plus_4_converted_bits, [0; 254]);\n\n            // checking that Field::from_le_bits::<254> on the Field modulus produces 0\n            assert_eq(modulus_le_bits().len(), 254);\n            let p = from_le_bits::<254>(modulus_le_bits().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 254 LE bytes produces 254 zeroes\n            let p_bits: [u1; 254] = 0.to_le_bits();\n            assert_eq(p_bits, [0; 254]);\n        }\n    }\n}\n","path":"std/field/mod.nr"},"19":{"source":"// Exposed only for usage in `std::meta`\npub(crate) mod poseidon2;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\n\n#[foreign(sha256_compression)]\n// docs:start:sha256_compression\npub fn sha256_compression(input: [u32; 16], state: [u32; 8]) -> [u32; 8] {}\n// docs:end:sha256_compression\n\n#[foreign(keccakf1600)]\n// docs:start:keccakf1600\npub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {}\n// docs:end:keccakf1600\n\npub mod keccak {\n    #[deprecated(\"This function has been moved to std::hash::keccakf1600\")]\n    pub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {\n        super::keccakf1600(input)\n    }\n}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{\n    if crate::runtime::is_unconstrained() {\n        // Temporary measure while Barretenberg is main proving system.\n        // Please open an issue if you're working on another proving system and running into problems due to this.\n        crate::static_assert(\n            N <= 1024,\n            \"Barretenberg cannot prove blake3 hashes with inputs larger than 1024 bytes\",\n        );\n    }\n    __blake3(input)\n}\n\n#[foreign(blake3)]\nfn __blake3<let N: u32>(input: [u8; N]) -> [u8; 32] {}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars, true)[0].x\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Decompose the input 'bn254 scalar' into two 128 bits limbs.\n// It is called 'unsafe' because it does not assert the limbs are 128 bits\n// Assuming the limbs are 128 bits:\n// Assert the decomposition does not overflow the field size.\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    // Safety: xlo and xhi decomposition is checked below\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    // Check that the decomposition does not overflow the field size\n    let (a, b) = if xhi == crate::field::bn254::PHI {\n        (xlo, crate::field::bn254::PLO)\n    } else {\n        (xhi, crate::field::bn254::PHI)\n    };\n    crate::field::bn254::assert_lt(a, b);\n\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn poseidon2_permutation<let N: u32>(input: [Field; N], state_len: u32) -> [Field; N] {\n    assert_eq(input.len(), state_len);\n    poseidon2_permutation_internal(input)\n}\n\n#[foreign(poseidon2_permutation)]\nfn poseidon2_permutation_internal<let N: u32>(input: [Field; N]) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: TypeDefinition) -> Quoted {\n    let name = quote { $crate::hash::Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: $crate::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher {\n    type H: Hasher;\n\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    type H = H;\n\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u8 as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u16 as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u32 as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u64 as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n","path":"std/hash/mod.nr"},"42":{"source":"use crate::cmp::{Eq, Ord, Ordering};\nuse crate::default::Default;\nuse crate::hash::{Hash, Hasher};\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n","path":"std/option.nr"},"43":{"source":"pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n","path":"std/panic.nr"},"61":{"source":"use crate::oracle::capsules;\nuse protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// A dynamically sized array backed by PXE's non-volatile database (called capsules). Values are persisted until\n/// deleted, so they can be e.g. stored during simulation of a transaction and later retrieved during witness\n/// generation. All values are scoped per contract address, so external contracts cannot access them.\npub struct CapsuleArray<T> {\n    contract_address: AztecAddress,\n    /// The base slot is where the array length is stored in capsules. Array elements are stored in consecutive slots\n    /// after the base slot. For example, with base slot 5: the length is at slot 5, the first element (index 0) is at\n    /// slot 6, the second element (index 1) is at slot 7, and so on.\n    base_slot: Field,\n}\n\nimpl<T> CapsuleArray<T> {\n    /// Returns a CapsuleArray connected to a contract's capsules at a base slot. Array elements are stored in\n    /// contiguous slots following the base slot, so there should be sufficient space between array base slots to\n    /// accommodate elements. A reasonable strategy is to make the base slot a hash of a unique value.\n    pub unconstrained fn at(contract_address: AztecAddress, base_slot: Field) -> Self {\n        Self { contract_address, base_slot }\n    }\n\n    /// Returns the number of elements stored in the array.\n    pub unconstrained fn len(self) -> u32 {\n        // An uninitialized array defaults to a length of 0.\n        capsules::load(self.contract_address, self.base_slot).unwrap_or(0) as u32\n    }\n\n    /// Stores a value at the end of the array.\n    pub unconstrained fn push(self, value: T)\n    where\n        T: Serialize,\n    {\n        let current_length = self.len();\n\n        // The slot corresponding to the index `current_length` is the first slot immediately after the end of the\n        // array, which is where we want to place the new value.\n        capsules::store(self.contract_address, self.slot_at(current_length), value);\n\n        // Then we simply update the length.\n        let new_length = current_length + 1;\n        capsules::store(self.contract_address, self.base_slot, new_length);\n    }\n\n    /// Retrieves the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn get(self, index: u32) -> T\n    where\n        T: Deserialize,\n    {\n        assert(index < self.len(), \"Attempted to read past the length of a CapsuleArray\");\n\n        capsules::load(self.contract_address, self.slot_at(index)).unwrap()\n    }\n\n    /// Deletes the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn remove(self, index: u32) {\n        let current_length = self.len();\n        assert(index < current_length, \"Attempted to delete past the length of a CapsuleArray\");\n\n        // In order to be able to remove elements at arbitrary indices, we need to shift the entire contents of the\n        // array past the removed element one slot backward so that we don't end up with a gap and preserve the\n        // contiguous slots. We can skip this when deleting the last element however.\n        if index != current_length - 1 {\n            // The source and destination regions overlap, but `copy` supports this.\n            capsules::copy(\n                self.contract_address,\n                self.slot_at(index + 1),\n                self.slot_at(index),\n                current_length - index - 1,\n            );\n        }\n\n        // We can now delete the last element (which has either been copied to the slot immediately before it, or was\n        // the element we meant to delete in the first place) and update the length.\n        capsules::delete(self.contract_address, self.slot_at(current_length - 1));\n        capsules::store(self.contract_address, self.base_slot, current_length - 1);\n    }\n\n    /// Iterates over the entire array, calling the callback with all values and their array index. The order in which\n    /// values are processed is arbitrary.\n    ///\n    /// It is safe to delete the current element (and only the current element) from inside the callback via `remove`:\n    /// ```noir\n    /// array.for_each(|index, value| {\n    ///   if some_condition(value) {\n    ///     array.remove(index); // safe only for this index\n    ///   }\n    /// }\n    /// ```\n    ///\n    /// If all elements in the array need to iterated over and then removed, then using `for_each` results in optimal\n    /// efficiency.\n    ///\n    /// It is **not** safe to push new elements into the array from inside the callback.\n    pub unconstrained fn for_each<Env>(self, f: unconstrained fn[Env](u32, T) -> ())\n    where\n        T: Deserialize,\n    {\n        // Iterating over all elements is simple, but we want to do it in such a way that a) deleting the current\n        // element is safe to do, and b) deleting *all* elements is optimally efficient. This is because CapsuleArrays\n        // are typically used to hold pending tasks, so iterating them while clearing completed tasks (sometimes\n        // unconditionally, resulting in a full clear) is a very common access pattern.\n        //\n        // The way we achieve this is by iterating backwards: each element can always be deleted since it won't change\n        // any preceding (lower) indices, and if every element is deleted then every element will (in turn) be the last\n        // element. This results in an optimal full clear since `remove` will be able to skip the `capsules::copy` call\n        // to shift any elements past the deleted one (because there will be none).\n        let mut i = self.len();\n        while i > 0 {\n            i -= 1;\n            f(i, self.get(i));\n        }\n    }\n\n    unconstrained fn slot_at(self, index: u32) -> Field {\n        // Elements are stored immediately after the base slot, so we add 1 to it to compute the slot for the first\n        // element.\n        self.base_slot + 1 + index as Field\n    }\n}\n\nmod test {\n    use crate::test::helpers::test_environment::TestEnvironment;\n    use super::CapsuleArray;\n\n    global SLOT: Field = 1230;\n\n    #[test]\n    unconstrained fn empty_array() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array: CapsuleArray<Field> = CapsuleArray::at(contract_address, SLOT);\n            assert_eq(array.len(), 0);\n        });\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn empty_array_read() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n            let _: Field = array.get(0);\n        });\n    }\n\n    #[test]\n    unconstrained fn array_push() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n            array.push(5);\n\n            assert_eq(array.len(), 1);\n            assert_eq(array.get(0), 5);\n        });\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn read_past_len() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n            array.push(5);\n\n            let _ = array.get(1);\n        });\n    }\n\n    #[test]\n    unconstrained fn array_remove_last() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(5);\n            array.remove(0);\n\n            assert_eq(array.len(), 0);\n        });\n    }\n\n    #[test]\n    unconstrained fn array_remove_some() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(7);\n            array.push(8);\n            array.push(9);\n\n            assert_eq(array.len(), 3);\n            assert_eq(array.get(0), 7);\n            assert_eq(array.get(1), 8);\n            assert_eq(array.get(2), 9);\n\n            array.remove(1);\n\n            assert_eq(array.len(), 2);\n            assert_eq(array.get(0), 7);\n            assert_eq(array.get(1), 9);\n        });\n    }\n\n    #[test]\n    unconstrained fn array_remove_all() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(7);\n            array.push(8);\n            array.push(9);\n\n            array.remove(1);\n            array.remove(1);\n            array.remove(0);\n\n            assert_eq(array.len(), 0);\n        });\n    }\n\n    #[test]\n    unconstrained fn for_each_called_with_all_elements() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(4);\n            array.push(5);\n            array.push(6);\n\n            // We store all values that we were called with and check that all (value, index) tuples are present. Note that\n            // we do not care about the order in which each tuple was passed to the closure.\n            let called_with = &mut BoundedVec::<(u32, Field), 3>::new();\n            array.for_each(|index, value| { called_with.push((index, value)); });\n\n            assert_eq(called_with.len(), 3);\n            assert(called_with.any(|(index, value)| (index == 0) & (value == 4)));\n            assert(called_with.any(|(index, value)| (index == 1) & (value == 5)));\n            assert(called_with.any(|(index, value)| (index == 2) & (value == 6)));\n        });\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_some() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(4);\n            array.push(5);\n            array.push(6);\n\n            array.for_each(|index, _| {\n                if index == 1 {\n                    array.remove(index);\n                }\n            });\n\n            assert_eq(array.len(), 2);\n            assert_eq(array.get(0), 4);\n            assert_eq(array.get(1), 6);\n        });\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_all() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(4);\n            array.push(5);\n            array.push(6);\n\n            array.for_each(|index, _| { array.remove(index); });\n\n            assert_eq(array.len(), 0);\n        });\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_all_no_copy() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(4);\n            array.push(5);\n            array.push(6);\n\n            // We test that the utilityCopyCapsule was never called, which is the expensive operation we want to avoid.\n            let mock = std::test::OracleMock::mock(\"utilityCopyCapsule\");\n\n            array.for_each(|index, _| { array.remove(index); });\n\n            assert_eq(mock.times_called(), 0);\n        });\n    }\n}\n","path":"/Users/zac/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/capsules/mod.nr"},"71":{"source":"use crate::context::gas::GasOpts;\nuse crate::hash::{\n    compute_l1_to_l2_message_hash, compute_l1_to_l2_message_nullifier, compute_secret_hash,\n};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::constants::{MAX_U32_VALUE, NULL_MSG_SENDER_CONTRACT_ADDRESS};\nuse dep::protocol_types::traits::{Empty, FromField, Packable, Serialize, ToField};\n\n/// # PublicContext\n///\n/// The **main interface** between an #[external(\"public\")] function and the Aztec blockchain.\n///\n/// An instance of the PublicContext is initialized automatically at the outset\n/// of every public function, within the #[external(\"public\")] macro, so you'll never\n/// need to consciously instantiate this yourself.\n///\n/// The instance is always named `context`, and it will always be available\n/// within the body of every #[external(\"public\")] function in your smart contract.\n///\n/// Typical usage for a smart contract developer will be to call getter\n/// methods of the PublicContext.\n///\n/// _Pushing_ data and requests to the context is mostly handled within\n/// aztec-nr's own functions, so typically a smart contract developer won't\n/// need to call any setter methods directly.\n///\n/// ## Responsibilities\n/// - Exposes contextual data to a public function:\n///   - Data relating to how this public function was called:\n///     - msg_sender, this_address\n///   - Data relating to the current blockchain state:\n///     - timestamp, block_number, chain_id, version\n///   - Gas and fee information\n/// - Provides state access:\n///   - Read/write public storage (key-value mapping)\n///   - Check existence of notes and nullifiers\n///     (Some patterns use notes & nullifiers to store public (not private)\n///     information)\n///   - Enables consumption of L1->L2 messages.\n/// - Enables calls to other public smart contract functions:\n/// - Writes data to the blockchain:\n///   - Updates to public state variables\n///   - New public logs (for events)\n///   - New L2->L1 messages\n///   - New notes & nullifiers\n///     (E.g. pushing public info to notes/nullifiers, or for completing\n///     \"partial notes\")\n///\n/// ## Key Differences from Private Execution\n///\n/// Unlike private functions -- which are executed on the user's device and which\n/// can only reference historic state -- public functions are executed by a block\n/// proposer and are executed \"live\" on the _current_ tip of the chain.\n/// This means public functions can:\n/// - Read and write _current_ public state\n/// - Immediately see the effects of earlier transactions in the same block\n///\n/// Also, public functions are executed within a zkVM (the \"AVM\"), so that they\n/// can _revert_ whilst still ensuring payment to the proposer and prover.\n/// (Private functions cannot revert: they either succeed, or they cannot be\n/// included).\n///\n/// ## Optimising Public Functions\n///\n/// Using the AVM to execute public functions means they compile down to \"AVM\n/// bytecode\" instead of the ACIR that private functions (standalone circuits)\n/// compile to. Therefore the approach to optimising a public function is\n/// fundamentally different from optimising a public function.\n///\npub struct PublicContext {\n    pub args_hash: Option<Field>,\n    pub compute_args_hash: fn() -> Field,\n}\n\nimpl Eq for PublicContext {\n    fn eq(self, other: Self) -> bool {\n        (self.args_hash == other.args_hash)\n        // Can't compare the function compute_args_hash\n    }\n}\n\nimpl PublicContext {\n    /// Creates a new PublicContext instance.\n    ///\n    /// Low-level function: This is called automatically by the #[external(\"public\")]\n    /// macro, so you shouldn't need to be called directly by smart contract\n    /// developers.\n    ///\n    /// # Arguments\n    /// * `compute_args_hash` - Function to compute the args_hash\n    ///\n    /// # Returns\n    /// * A new PublicContext instance\n    ///\n    pub fn new(compute_args_hash: fn() -> Field) -> Self {\n        PublicContext { args_hash: Option::none(), compute_args_hash }\n    }\n\n    /// Emits a _public_ log that will be visible onchain to everyone.\n    ///\n    /// # Arguments\n    /// * `log` - The data to log, must implement Serialize trait\n    ///\n    pub fn emit_public_log<T>(_self: Self, log: T)\n    where\n        T: Serialize,\n    {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_public_log(Serialize::serialize(log).as_slice()) };\n    }\n\n    /// Checks if a given note hash exists in the note hash tree at a particular\n    /// leaf_index.\n    ///\n    /// # Arguments\n    /// * `note_hash` - The note hash to check for existence\n    /// * `leaf_index` - The index where the note hash should be located\n    ///\n    /// # Returns\n    /// * `bool` - True if the note hash exists at the specified index\n    ///\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: u64) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { note_hash_exists(note_hash, leaf_index) } == 1\n    }\n\n    /// Checks if a specific L1-to-L2 message exists in the L1-to-L2 message\n    /// tree at a particular leaf index.\n    ///\n    /// Common use cases include token bridging, cross-chain governance, and\n    /// triggering L2 actions based on L1 events.\n    ///\n    /// This function should be called before attempting to consume an L1-to-L2\n    /// message.\n    ///\n    /// # Arguments\n    /// * `msg_hash` - Hash of the L1-to-L2 message to check\n    /// * `msg_leaf_index` - The index where the message should be located\n    ///\n    /// # Returns\n    /// * `bool` - True if the message exists at the specified index\n    ///\n    /// # Advanced\n    /// * Uses the AVM l1_to_l2_msg_exists opcode for tree lookup\n    /// * Messages are copied from L1 Inbox to L2 by block proposers\n    ///\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        // TODO(alvaro): Make l1l2msg leaf index a u64 upstream\n        unsafe { l1_to_l2_msg_exists(msg_hash, msg_leaf_index as u64) } == 1\n    }\n\n    /// Checks if a specific nullifier has been emitted by a given contract.\n    ///\n    /// Whilst nullifiers are primarily intended as a _privacy-preserving_\n    /// record of a one-time action, they can also be used to efficiently\n    /// record _public_ one-time actions too. An example is to check\n    /// whether a contract has been published: we emit a nullifier that is\n    /// deterministic, but whose preimage is _not_ private. This is more\n    /// efficient than using mutable storage, and can be done directly\n    /// from a private function.\n    ///\n    /// Nullifiers can be tested for non-existence in public, which is not the\n    /// case in private. Because private functions do not have access to\n    /// the tip of the blockchain (but only the anchor block they are built\n    /// at) they can only prove nullifier non-existence in the past. But between\n    /// an anchor block and the block in which a tx is included, the nullifier\n    /// might have been inserted into the nullifier tree by some other\n    /// transaction.\n    /// Public functions _do_ have access to the tip of the state, and so\n    /// this pattern is safe.\n    ///\n    /// # Arguments\n    /// * `unsiloed_nullifier` - The raw nullifier value (before siloing with\n    ///                          the contract address that emitted it).\n    /// * `address` - The claimed contract address that emitted the nullifier\n    ///\n    /// # Returns\n    /// * `bool` - True if the nullifier has been emitted by the specified contract\n    ///\n    pub fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { nullifier_exists(unsiloed_nullifier, address.to_field()) } == 1\n    }\n\n    /// Consumes a message sent from Ethereum (L1) to Aztec (L2) -- effectively\n    /// marking it as \"read\".\n    ///\n    /// Use this function if you only want the message to ever be \"referred to\"\n    /// once. Once consumed using this method, the message cannot be consumed\n    /// again, because a nullifier is emitted.\n    /// If your use case wants for the message to be read unlimited times, then\n    /// you can always read any historic message from the L1-to-L2 messages tree,\n    /// using the `l1_to_l2_msg_exists` method. Messages never technically get\n    /// deleted from that tree.\n    ///\n    /// The message will first be inserted into an Aztec \"Inbox\" smart contract\n    /// on L1. It will not be available for consumption immediately. Messages\n    /// get copied-over from the L1 Inbox to L2 by the next Proposer in batches.\n    /// So you will need to wait until the messages are copied before you can\n    /// consume them.\n    ///\n    /// # Arguments\n    /// * `content` - The message content that was sent from L1\n    /// * `secret` - Secret value used for message privacy (if needed)\n    /// * `sender` - Ethereum address that sent the message\n    /// * `leaf_index` - Index of the message in the L1-to-L2 message tree\n    ///\n    /// # Advanced\n    /// * Validates message existence in the L1-to-L2 message tree\n    /// * Prevents double-consumption by emitting a nullifier\n    /// * Message hash is computed from all parameters + chain context\n    /// * Will revert if message doesn't exist or was already consumed\n    ///\n    pub fn consume_l1_to_l2_message(\n        self: Self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_l1_to_l2_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/\n            self.this_address(),\n            self.version(),\n            content,\n            secret_hash,\n            leaf_index,\n        );\n        let nullifier = compute_l1_to_l2_message_nullifier(message_hash, secret);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()),\n            \"L1-to-L2 message is already nullified\",\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index),\n            \"Tried to consume nonexistent L1-to-L2 message\",\n        );\n\n        self.push_nullifier(nullifier);\n    }\n\n    /// Sends an \"L2 -> L1 message\" from this function (Aztec, L2) to a smart\n    /// contract on Ethereum (L1). L1 contracts which are designed to\n    /// send/receive messages to/from Aztec are called \"Portal Contracts\".\n    ///\n    /// Common use cases include withdrawals, cross-chain asset transfers, and\n    /// triggering L1 actions based on L2 state changes.\n    ///\n    /// The message will be inserted into an Aztec \"Outbox\" contract on L1,\n    /// when this transaction's block is proposed to L1.\n    /// Sending the message will not result in any immediate state changes in\n    /// the target portal contract. The message will need to be manually\n    /// consumed from the Outbox through a separate Ethereum transaction: a user\n    /// will need to call a function of the portal contract -- a function\n    /// specifically designed to make a call to the Outbox to consume the\n    /// message.\n    /// The message will only be available for consumption once the _epoch_\n    /// proof has been submitted. Given that there are multiple Aztec blocks\n    /// within an epoch, it might take some time for this epoch proof to be\n    /// submitted -- especially if the block was near the start of an epoch.\n    ///\n    /// # Arguments\n    /// * `recipient` - Ethereum address that will receive the message\n    /// * `content` - Message content (32 bytes as a Field element)\n    ///\n    pub fn message_portal(_self: Self, recipient: EthAddress, content: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { send_l2_to_l1_msg(recipient, content) };\n    }\n\n    /// Calls a public function on another contract.\n    ///\n    /// Will revert if the called function reverts or runs out of gas.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract to call\n    /// * `function_selector` - Function to call on the target contract\n    /// * `args` - Arguments to pass to the function\n    /// * `gas_opts` - An optional allocation of gas to the called function.\n    ///\n    /// # Returns\n    /// * `[Field]` - Return data from the called function\n    ///\n    pub unconstrained fn call_public_function<let N: u32>(\n        _self: Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; N],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = [function_selector.to_field()].concat(args);\n\n        call(\n            gas_opts.l2_gas.unwrap_or(MAX_U32_VALUE),\n            gas_opts.da_gas.unwrap_or(MAX_U32_VALUE),\n            contract_address,\n            calldata,\n        );\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    /// Makes a read-only call to a public function on another contract.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state or emit events. Any nested calls are constrained to\n    /// also be staticcalls.\n    ///\n    /// Useful for querying data from other contracts safely.\n    ///\n    /// Will revert if the called function reverts or runs out of gas.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract to call\n    /// * `function_selector` - Function to call on the target contract\n    /// * `args` - Array of arguments to pass to the called function\n    /// * `gas_opts` - An optional allocation of gas to the called function.\n    ///\n    /// # Returns\n    /// * `[Field]` - Return data from the called function\n    ///\n    pub unconstrained fn static_call_public_function<let N: u32>(\n        _self: Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; N],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = [function_selector.to_field()].concat(args);\n\n        call_static(\n            gas_opts.l2_gas.unwrap_or(MAX_U32_VALUE),\n            gas_opts.da_gas.unwrap_or(MAX_U32_VALUE),\n            contract_address,\n            calldata,\n        );\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    /// Adds a new note hash to the Aztec blockchain's global Note Hash Tree.\n    ///\n    /// Notes are ordinarily constructed and emitted by _private_ functions, to\n    /// ensure that both the content of the note, and the contract that emitted\n    /// the note, stay private.\n    ///\n    /// There are however some useful patterns whereby a note needs to contain\n    /// _public_ data. The ability to push a new note_hash from a _public_\n    /// function means that notes can be injected with public data immediately\n    /// -- as soon as the public value is known. The slower alternative would\n    /// be to submit a follow-up transaction so that a private function can\n    /// inject the data. Both are possible on Aztec.\n    ///\n    /// Search \"Partial Note\" for a very common pattern which enables a note\n    /// to be \"partially\" populated with some data in a _private_ function, and\n    /// then later \"completed\" with some data in a public function.\n    ///\n    /// # Arguments\n    /// * `note_hash` - The hash of the note to add to the tree\n    ///\n    /// # Advanced\n    /// * The note hash will be siloed with the contract address by the protocol\n    ///\n    pub fn push_note_hash(_self: Self, note_hash: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_note_hash(note_hash) };\n    }\n\n    /// Adds a new nullifier to the Aztec blockchain's global Nullifier Tree.\n    ///\n    /// Whilst nullifiers are primarily intended as a _privacy-preserving_\n    /// record of a one-time action, they can also be used to efficiently\n    /// record _public_ one-time actions too. Hence why you're seeing this\n    /// function within the PublicContext.\n    /// An example is to check whether a contract has been published: we emit\n    /// a nullifier that is deterministic, but whose preimage is _not_ private.\n    ///\n    /// # Arguments\n    /// * `nullifier` - A unique field element that represents the consumed\n    ///   state\n    ///\n    /// # Advanced\n    /// * Nullifier is immediately added to the global nullifier tree\n    /// * Emitted nullifiers are immediately visible to all\n    ///   subsequent transactions in the same block\n    /// * Automatically siloed with the contract address by the protocol\n    /// * Used for preventing double-spending and ensuring one-time actions\n    ///\n    pub fn push_nullifier(_self: Self, nullifier: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_nullifier(nullifier) };\n    }\n\n    /// Returns the address of the current contract being executed.\n    ///\n    /// This is equivalent to `address(this)` in Solidity (hence the name).\n    /// Use this to identify the current contract's address, commonly needed for\n    /// access control or when interacting with other contracts.\n    ///\n    /// # Returns\n    /// * `AztecAddress` - The contract address of the current function being\n    ///                    executed.\n    ///\n    pub fn this_address(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            address()\n        }\n    }\n\n    /// Returns the contract address that initiated this function call.\n    ///\n    /// This is similar to `msg.sender` in Solidity (hence the name).\n    ///\n    /// Important Note: If the calling function is a _private_ function, then\n    /// it had the option of hiding its address when enqueuing this public\n    /// function call. In such cases, this `context.msg_sender()` method will\n    /// return `Option<AztecAddress>::none`.\n    /// If the calling function is a _public_ function, it will always return\n    /// an `Option<AztecAddress>::some` (i.e. a non-null value).\n    ///\n    /// # Returns\n    /// * `Option<AztecAddress>` - The address of the smart contract that called\n    ///   this function (be it an app contract or a user's account contract).\n    ///\n    /// # Advanced\n    /// * Value is provided by the AVM sender opcode\n    /// * In nested calls, this is the immediate caller, not the original\n    ///   transaction sender\n    ///\n    pub fn msg_sender(_self: Self) -> Option<AztecAddress> {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        let maybe_msg_sender = unsafe { sender() };\n        if maybe_msg_sender == NULL_MSG_SENDER_CONTRACT_ADDRESS {\n            Option::none()\n        } else {\n            Option::some(maybe_msg_sender)\n        }\n    }\n\n    /// \"Unsafe\" versus calling `context.msg_sender()`, because it doesn't\n    /// translate `NULL_MSG_SENDER_CONTRACT_ADDRESS` as\n    /// `Option<AztecAddress>::none`.\n    /// Used by some internal aztecnr functions.\n    pub fn msg_sender_unsafe(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            sender()\n        }\n    }\n\n    /// Returns the function selector of the currently-executing function.\n    ///\n    /// This is similar to `msg.sig` in Solidity, returning the first 4\n    /// bytes of the function signature.\n    ///\n    /// # Returns\n    /// * `FunctionSelector` - The 4-byte function identifier\n    ///\n    /// # Advanced\n    /// * Extracted from the first element of calldata\n    /// * Used internally for function dispatch in the AVM\n    ///\n    pub fn selector(_self: Self) -> FunctionSelector {\n        // The selector is the first element of the calldata when calling a public function through dispatch.\n        // Safety: AVM opcodes are constrained by the AVM itself\n        let raw_selector: [Field; 1] = unsafe { calldata_copy(0, 1) };\n        FunctionSelector::from_field(raw_selector[0])\n    }\n\n    /// Returns the hash of the arguments passed to the current function.\n    ///\n    /// Very low-level function: The #[external(\"public\")] macro uses this internally.\n    /// Smart contract developers typically won't need to access this\n    /// directly as arguments are automatically made available.\n    ///\n    /// # Returns\n    /// * `Field` - Hash of the function arguments\n    ///\n    pub fn get_args_hash(mut self) -> Field {\n        if !self.args_hash.is_some() {\n            self.args_hash = Option::some((self.compute_args_hash)());\n        }\n\n        self.args_hash.unwrap_unchecked()\n    }\n\n    /// Returns the \"transaction fee\" for the current transaction.\n    /// This is the final tx fee that will be deducted from the fee_payer's\n    /// \"fee-juice\" balance (in the protocol's Base Rollup circuit).\n    ///\n    /// # Returns\n    /// * `Field` - The actual, final cost of the transaction, taking into account:\n    ///             the actual gas used during the setup and app-logic phases,\n    ///             and the fixed amount of gas that's been allocated by the user\n    ///             for the teardown phase.\n    ///             I.e. effectiveL2FeePerGas * l2GasUsed + effectiveDAFeePerGas * daGasUsed\n    ///\n    /// This will return `0` during the \"setup\" and \"app-logic\" phases of\n    /// tx execution (because the final tx fee is not known at that time).\n    /// This will only return a nonzero value during the \"teardown\" phase of\n    /// execution, where the final tx fee can actually be computed.\n    ///\n    /// Regardless of _when_ this function is called during the teardown phase,\n    /// it will always return the same final tx fee value. The teardown phase\n    /// does not consume a variable amount of gas: it always consumes a\n    /// pre-allocated amount of gas, as specified by the user when they generate\n    /// their tx.\n    ///\n    pub fn transaction_fee(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            transaction_fee()\n        }\n    }\n\n    /// Returns the chain ID of the current network.\n    ///\n    /// This is similar to `block.chainid` in Solidity. Returns the unique\n    /// identifier for the blockchain network this transaction is executing on.\n    ///\n    /// Helps prevent cross-chain replay attacks. Useful if implementing\n    /// multi-chain contract logic.\n    ///\n    /// # Returns\n    /// * `Field` - The chain ID as a field element\n    ///\n    pub fn chain_id(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            chain_id()\n        }\n    }\n\n    /// Returns the Aztec protocol version that this transaction is executing\n    /// under. Different versions may have different rules, opcodes, or\n    /// cryptographic primitives.\n    ///\n    /// This is similar to how Ethereum has different EVM versions.\n    ///\n    /// Useful for forward/backward compatibility checks\n    ///\n    /// Not to be confused with contract versions; this is the protocol version.\n    ///\n    /// # Returns\n    /// * `Field` - The protocol version as a field element\n    ///\n    pub fn version(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            version()\n        }\n    }\n    /// Returns the current block number.\n    ///\n    /// This is similar to `block.number` in Solidity.\n    ///\n    /// Note: the current block number is only available within a public function\n    /// (as opposed to a private function).\n    ///\n    /// Note: the time intervals between blocks should not be relied upon as\n    /// being consistent:\n    /// - Timestamps of blocks fall within a range, rather than at exact regular\n    ///   intervals.\n    /// - Slots can be missed.\n    /// - Protocol upgrades can completely change the intervals between blocks\n    ///   (and indeed the current roadmap plans to reduce the time between\n    ///   blocks, eventually).\n    /// Use `context.timestamp()` for more-reliable time-based logic.\n    ///\n    /// # Returns\n    /// * `u32` - The current block number\n    ///\n    pub fn block_number(_self: Self) -> u32 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            block_number()\n        }\n    }\n\n    /// Returns the timestamp of the current block.\n    ///\n    /// This is similar to `block.timestamp` in Solidity.\n    ///\n    /// All functions of all transactions in a block share the exact same\n    /// timestamp (even though technically each transaction is executed\n    /// one-after-the-other).\n    ///\n    /// Important note: Timestamps of Aztec blocks are not at reliably-fixed\n    /// intervals. The proposer of the block has some flexibility to choose a\n    /// timestamp which is in a valid _range_: Obviously the timestamp of this\n    /// block must be strictly greater than that of the previous block, and must\n    /// must be less than the timestamp of whichever ethereum block the aztec\n    /// block is proposed to. Furthermore, if the timestamp is not deemed close\n    /// enough to the actual current time, the committee of validators will not\n    /// attest to the block.\n    ///\n    /// # Returns\n    /// * `u64` - Unix timestamp in seconds\n    ///\n    pub fn timestamp(_self: Self) -> u64 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            timestamp()\n        }\n    }\n\n    /// Returns the fee per unit of L2 gas for this transaction (aka the \"L2 gas\n    /// price\"), as chosen by the user.\n    ///\n    /// L2 gas covers the cost of executing public functions and handling\n    /// side-effects within the AVM.\n    ///\n    /// # Returns\n    /// * `u128` - Fee per unit of L2 gas\n    ///\n    /// Wallet developers should be mindful that the choice of gas price (which\n    /// is publicly visible) can leak information about the user, e.g.:\n    /// - which wallet software the user is using;\n    /// - the amount of time which has elapsed from the time the user's wallet\n    ///   chose a gas price (at the going rate), to the time of tx submission.\n    ///   This can give clues about the proving time, and hence the nature of\n    ///   the tx.\n    /// - the urgency of the transaction (which is kind of unavoidable, if the\n    ///   tx is indeed urgent).\n    /// - the wealth of the user.\n    /// - the exact user (if the gas price is explicitly chosen by the user to\n    ///   be some unique number like 0.123456789, or their favorite number).\n    /// Wallet devs might wish to consider fuzzing the choice of gas price.\n    ///\n    pub fn base_fee_per_l2_gas(_self: Self) -> u128 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            base_fee_per_l2_gas()\n        }\n    }\n\n    /// Returns the fee per unit of DA (Data Availability) gas (aka the \"DA gas\n    /// price\").\n    ///\n    /// DA gas covers the cost of making transaction data available on L1.\n    ///\n    /// See the warning in `fee_pre_l2_gas` for how gas prices can be leaky.\n    ///\n    /// # Returns\n    /// * `u128` - Fee per unit of DA gas\n    ///\n    pub fn base_fee_per_da_gas(_self: Self) -> u128 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            base_fee_per_da_gas()\n        }\n    }\n\n    /// Returns the remaining L2 gas available for this transaction.\n    ///\n    /// Different AVM opcodes consume different amounts of gas.\n    ///\n    /// # Returns\n    /// * `u32` - Remaining L2 gas units\n    ///\n    pub fn l2_gas_left(_self: Self) -> u32 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            l2_gas_left()\n        }\n    }\n\n    /// Returns the remaining DA (Data Availability) gas available for this\n    /// transaction.\n    ///\n    /// DA gas is consumed when emitting data that needs to be made available\n    /// on L1, such as public logs or state updates.\n    /// All of the side-effects from the private part of the tx also consume\n    /// DA gas before execution of any public functions even begins.\n    ///\n    /// # Returns\n    /// * `u32` - Remaining DA gas units\n    ///\n    pub fn da_gas_left(_self: Self) -> u32 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            da_gas_left()\n        }\n    }\n\n    /// Checks if the current execution is within a staticcall context, where\n    /// no state changes or logs are allowed to be emitted (by this function\n    /// or any nested function calls).\n    ///\n    /// # Returns\n    /// * `bool` - True if in staticcall context, false otherwise\n    ///\n    pub fn is_static_call(_self: Self) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { is_static_call() } == 1\n    }\n\n    /// Reads raw field values from public storage.\n    /// Reads N consecutive storage slots starting from the given slot.\n    ///\n    /// Very low-level function. Users should typically use the public state\n    /// variable abstractions to perform reads: PublicMutable & PublicImmutable.\n    ///\n    /// # Arguments\n    /// * `storage_slot` - The starting storage slot to read from\n    ///\n    /// # Returns\n    /// * `[Field; N]` - Array of N field values from consecutive storage slots\n    ///\n    /// # Generic Parameters\n    /// * `N` - the number of consecutive slots to return, starting from the\n    ///         `storage_slot`.\n    ///\n    pub fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\n        let mut out = [0; N];\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            out[i] = unsafe { storage_read(storage_slot + i as Field) };\n        }\n        out\n    }\n\n    /// Reads a typed value from public storage.\n    ///\n    /// Low-level function. Users should typically use the public state\n    /// variable abstractions to perform reads: PublicMutable & PublicImmutable.\n    ///\n    /// # Arguments\n    /// * `storage_slot` - The storage slot to read from\n    ///\n    /// # Returns\n    /// * `T` - The deserialized value from storage\n    ///\n    /// # Generic Parameters\n    /// * `T` - The type that the caller expects to read from the `storage_slot`.\n    ///\n    pub fn storage_read<T>(self, storage_slot: Field) -> T\n    where\n        T: Packable,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n\n    /// Writes raw field values to public storage.\n    /// Writes to N consecutive storage slots starting from the given slot.\n    ///\n    /// Very low-level function. Users should typically use the public state\n    /// variable abstractions to perform writes: PublicMutable & PublicImmutable.\n    ///\n    /// Public storage writes take effect immediately.\n    ///\n    /// # Arguments\n    /// * `storage_slot` - The starting storage slot to write to\n    /// * `values` - Array of N Fields to write to storage\n    ///\n    pub fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            unsafe { storage_write(storage_slot + i as Field, values[i]) };\n        }\n    }\n\n    /// Writes a typed value to public storage.\n    ///\n    /// Low-level function. Users should typically use the public state\n    /// variable abstractions to perform writes: PublicMutable & PublicImmutable.\n    ///\n    /// # Arguments\n    /// * `storage_slot` - The storage slot to write to\n    /// * `value` - The typed value to write to storage\n    ///\n    /// # Generic Parameters\n    /// * `T` - The type to write to storage.\n    ///\n    pub fn storage_write<T>(self, storage_slot: Field, value: T)\n    where\n        T: Packable,\n    {\n        self.raw_storage_write(storage_slot, value.pack());\n    }\n}\n\n// TODO: consider putting this oracle code in its own file.\n// Unconstrained opcode wrappers (do not use directly).\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> u32 {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn base_fee_per_l2_gas() -> u128 {\n    base_fee_per_l2_gas_opcode()\n}\nunconstrained fn base_fee_per_da_gas() -> u128 {\n    base_fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> u32 {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> u32 {\n    da_gas_left_opcode()\n}\nunconstrained fn is_static_call() -> u1 {\n    is_static_call_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: u64) -> u1 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u1 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_public_log(message: [Field]) {\n    emit_public_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: u64) -> u1 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\n\nunconstrained fn call<let N: u32>(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    args: [Field; N],\n) {\n    call_opcode(l2_gas_allocation, da_gas_allocation, address, N, args)\n}\n\nunconstrained fn call_static<let N: u32>(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    args: [Field; N],\n) {\n    call_static_opcode(l2_gas_allocation, da_gas_allocation, address, N, args)\n}\n\npub unconstrained fn calldata_copy<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {\n    calldata_copy_opcode(cdoffset, copy_size)\n}\n\n// `success_copy` is placed immediately after the CALL opcode to get the success value\nunconstrained fn success_copy() -> bool {\n    success_copy_opcode()\n}\n\nunconstrained fn returndata_size() -> u32 {\n    returndata_size_opcode()\n}\n\nunconstrained fn returndata_copy(rdoffset: u32, copy_size: u32) -> [Field] {\n    returndata_copy_opcode(rdoffset, copy_size)\n}\n\npub unconstrained fn avm_return(returndata: [Field]) {\n    return_opcode(returndata)\n}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\nunconstrained fn avm_revert(revertdata: [Field]) {\n    revert_opcode(revertdata)\n}\n\nunconstrained fn storage_read(storage_slot: Field) -> Field {\n    storage_read_opcode(storage_slot)\n}\n\nunconstrained fn storage_write(storage_slot: Field, value: Field) {\n    storage_write_opcode(storage_slot, value);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(|| 0)\n    }\n}\n\n// TODO: consider putting this oracle code in its own file.\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> u32 {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeBaseFeePerL2Gas)]\nunconstrained fn base_fee_per_l2_gas_opcode() -> u128 {}\n\n#[oracle(avmOpcodeBaseFeePerDaGas)]\nunconstrained fn base_fee_per_da_gas_opcode() -> u128 {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> u32 {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> u32 {}\n\n#[oracle(avmOpcodeIsStaticCall)]\nunconstrained fn is_static_call_opcode() -> u1 {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: u64) -> u1 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n// TODO(#11124): rename unencrypted to public in avm\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_public_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: u64) -> u1 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCalldataCopy)]\nunconstrained fn calldata_copy_opcode<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {}\n\n#[oracle(avmOpcodeReturndataSize)]\nunconstrained fn returndata_size_opcode() -> u32 {}\n\n#[oracle(avmOpcodeReturndataCopy)]\nunconstrained fn returndata_copy_opcode(rdoffset: u32, copy_size: u32) -> [Field] {}\n\n#[oracle(avmOpcodeReturn)]\nunconstrained fn return_opcode(returndata: [Field]) {}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\n#[oracle(avmOpcodeRevert)]\nunconstrained fn revert_opcode(revertdata: [Field]) {}\n\n// While the length parameter might seem unnecessary given that we have N we keep it around because at the AVM bytecode\n// level, we want to support non-comptime-known lengths for such opcodes, even if Noir code will not generally take that\n// route.\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode<let N: u32>(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    length: u32,\n    args: [Field; N],\n) {}\n\n// While the length parameter might seem unnecessary given that we have N we keep it around because at the AVM bytecode\n// level, we want to support non-comptime-known lengths for such opcodes, even if Noir code will not generally take that\n// route.\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode<let N: u32>(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    length: u32,\n    args: [Field; N],\n) {}\n\n#[oracle(avmOpcodeSuccessCopy)]\nunconstrained fn success_copy_opcode() -> bool {}\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode(storage_slot: Field) -> Field {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode(storage_slot: Field, value: Field) {}\n","path":"/Users/zac/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/context/public_context.nr"},"73":{"source":"use crate::oracle::{execution::get_utility_context, storage::storage_read};\nuse protocol_types::{address::AztecAddress, traits::Packable};\n\n// If you'll modify this struct don't forget to update utility_context.ts as well.\npub struct UtilityContext {\n    block_number: u32,\n    timestamp: u64,\n    contract_address: AztecAddress,\n    version: Field,\n    chain_id: Field,\n}\n\nimpl UtilityContext {\n    pub unconstrained fn new() -> Self {\n        get_utility_context()\n    }\n\n    pub unconstrained fn at(contract_address: AztecAddress) -> Self {\n        // We get a context with default contract address, and then we construct the final context with the provided\n        // contract address.\n        let default_context = get_utility_context();\n\n        Self {\n            block_number: default_context.block_number,\n            timestamp: default_context.timestamp,\n            contract_address,\n            version: default_context.version,\n            chain_id: default_context.chain_id,\n        }\n    }\n\n    pub unconstrained fn at_historical(contract_address: AztecAddress, block_number: u32) -> Self {\n        // We get a context with default contract address and block number, and then we construct the final context\n        // with the provided contract address and block number.\n        let default_context = get_utility_context();\n\n        Self {\n            block_number,\n            timestamp: default_context.timestamp,\n            contract_address,\n            version: default_context.version,\n            chain_id: default_context.chain_id,\n        }\n    }\n\n    pub fn block_number(self) -> u32 {\n        self.block_number\n    }\n\n    pub fn timestamp(self) -> u64 {\n        self.timestamp\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.contract_address\n    }\n\n    pub fn version(self) -> Field {\n        self.version\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.chain_id\n    }\n\n    pub unconstrained fn raw_storage_read<let N: u32>(\n        self: Self,\n        storage_slot: Field,\n    ) -> [Field; N] {\n        storage_read(self.this_address(), storage_slot, self.block_number())\n    }\n\n    pub unconstrained fn storage_read<T>(self, storage_slot: Field) -> T\n    where\n        T: Packable,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n}\n","path":"/Users/zac/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/context/utility_context.nr"},"74":{"source":"use crate::{\n    context::{\n        calls::{PrivateCall, PrivateStaticCall, PublicCall, PublicStaticCall},\n        private_context::PrivateContext,\n        public_context::PublicContext,\n        utility_context::UtilityContext,\n    },\n    event::{\n        event_emission::{emit_event_in_private, emit_event_in_public},\n        event_interface::EventInterface,\n        event_message::EventMessage,\n    },\n};\nuse protocol_types::{\n    address::AztecAddress,\n    constants::NULL_MSG_SENDER_CONTRACT_ADDRESS,\n    traits::{Deserialize, Serialize},\n};\n\n/// `ContractSelf` is the core interface for interacting with an Aztec contract's own state and context.\n///\n/// This struct is automatically injected into every #[external(...)] contract function by the Aztec macro system and is\n/// accessible through the `self` variable.\n///\n/// # Usage in Contract Functions\n///\n/// Once injected, you can use `self` to:\n/// - Access storage: `self.storage.balances.at(owner).read()`\n/// - Call contracts: `self.call(Token::at(address).transfer(recipient, amount))`\n/// - Emit events: `self.emit(event).deliver_to(recipient, delivery_mode)` (private) or `self.emit(event)` (public)\n/// - Get the contract address: `self.address`\n/// - Get the caller: `self.msg_sender()`\n/// - Access low-level Aztec.nr APIs through the context: `self.context`\n///\n/// # Example\n///\n/// ```noir\n/// #[external(\"private\")]\n/// fn withdraw(amount: u128, recipient: AztecAddress) {\n///     // Get the caller of this function\n///     let sender = self.msg_sender().unwrap();\n///\n///     // Access storage\n///     let token = self.storage.donation_token.get_note().get_address();\n///\n///     // Call contracts\n///     self.call(Token::at(token).transfer(recipient, amount));\n/// }\n/// ```\n///\n/// # Type Parameters\n///\n/// - `Context`: The execution context type - either `&mut PrivateContext`, `PublicContext`, or `UtilityContext`\n/// - `Storage`: The contract's storage struct (defined with `#[storage]`), or `()` if the contract has no storage\n/// - `CallSelf`: Macro-generated type for calling contract's own non-view functions\n/// - `EnqueueSelf`: Macro-generated type for enqueuing calls to the contract's own non-view functions\n/// - `CallSelfStatic`: Macro-generated type for calling contract's own view functions\n/// - `EnqueueSelfStatic`: Macro-generated type for enqueuing calls to the contract's own view functions\npub struct ContractSelf<Context, Storage, CallSelf, EnqueueSelf, CallSelfStatic, EnqueueSelfStatic, CallInternal> {\n    /// The address of this contract\n    pub address: AztecAddress,\n    /// The contract's storage instance, representing the struct to which the `#[storage]` macro was applied in your\n    /// contract. If the contract has no storage, the type of this will be `()`.\n    ///\n    /// This storage instance is specialized for the current execution context (private, public, or utility) and\n    /// provides access to the contract's state variables. Each state variable accepts the context as a generic\n    /// parameter, which determines its available functionality. For example, a PublicImmutable variable can be read\n    /// from any context (public, private, or utility) but can only be written to from public contexts.\n    ///\n    /// # Developer Note\n    /// If you've arrived here while trying to access your contract's storage while the `Storage` generic type is set to\n    /// unit type `()`, it means you haven't yet defined a Storage struct using the #[storage] macro in your contract.\n    /// For guidance on setting this up, please refer to our docs:\n    /// https://docs.aztec.network/developers/docs/guides/smart_contracts/storage\n    pub storage: Storage,\n    /// The execution context whose type is determined by the #[external(...)] attribute of the contract function based\n    /// on the external function type (private, public, or utility).\n    pub context: Context,\n\n    /// Provides type-safe methods for calling this contract's own non-view functions.\n    ///\n    /// In private and public contexts this will be a struct with appropriate methods;\n    /// in utility context it will be the unit type `()`.\n    ///\n    /// Example API:\n    /// ```noir\n    /// self.call_self.some_private_function(args)\n    /// ```\n    pub call_self: CallSelf,\n    /// Provides type-safe methods for enqueuing calls to this contract's own non-view functions.\n    ///\n    /// In private context this will be a struct with appropriate methods;\n    /// in public and utility contexts it will be the unit type `()`.\n    ///\n    /// Example API:\n    /// ```noir\n    /// self.enqueue_self.some_public_function(args)\n    /// ```\n    pub enqueue_self: EnqueueSelf,\n    /// Provides type-safe methods for calling this contract's own view functions.\n    ///\n    /// In private and public contexts this will be a struct with appropriate methods;\n    /// in utility context it will be the unit type `()`.\n    ///\n    /// Example API:\n    /// ```noir\n    /// self.call_self_static.some_view_function(args)\n    /// ```\n    pub call_self_static: CallSelfStatic,\n    /// Provides type-safe methods for enqueuing calls to this contract's own view functions.\n    ///\n    /// In private context this will be a struct with appropriate methods;\n    /// in public and utility contexts it will be the unit type `()`.\n    ///\n    /// Example API:\n    /// ```noir\n    /// self.enqueue_self_static.some_public_view_function(args)\n    /// ```\n    pub enqueue_self_static: EnqueueSelfStatic,\n    /// Provides type-safe methods for calling internal functions.\n    ///\n    /// In private and public contexts this will be a struct with appropriate methods;\n    /// in utility context it will be the unit type `()`.\n    ///\n    /// Example API:\n    /// ```noir\n    /// self.internal.some_internal_function(args)\n    /// ```\n    pub internal: CallInternal,\n}\n\n/// Implementation for `ContractSelf` in private execution contexts.\n///\n/// This implementation is used when a contract function is marked with `#[external(\"private\")]`.\n/// Private functions execute client-side and generate zero-knowledge proofs of their execution.\nimpl<Storage, CallSelf, EnqueueSelf, CallSelfStatic, EnqueueSelfStatic, CallInternal> ContractSelf<&mut PrivateContext, Storage, CallSelf, EnqueueSelf, CallSelfStatic, EnqueueSelfStatic, CallInternal> {\n    /// Creates a new `ContractSelf` instance for a private function.\n    ///\n    /// This constructor is called automatically by the macro system and should not be called directly.\n    pub fn new_private(\n        context: &mut PrivateContext,\n        storage: Storage,\n        call_self: CallSelf,\n        enqueue_self: EnqueueSelf,\n        call_self_static: CallSelfStatic,\n        enqueue_self_static: EnqueueSelfStatic,\n        internal: CallInternal,\n    ) -> Self {\n        Self {\n            context,\n            storage,\n            address: context.this_address(),\n            call_self,\n            enqueue_self,\n            call_self_static,\n            enqueue_self_static,\n            internal,\n        }\n    }\n\n    /// Returns the contract address that initiated this function call. This is similar to `msg.sender` in Solidity.\n    ///\n    /// Important Note: Since Aztec doesn't have a concept of an EoA ( Externally-owned Account), the msg_sender is\n    /// \"null\" for the first function call of every transaction. The first function call of a tx is likely to be a call\n    /// to the user's account contract, so this quirk will most often be handled by account contract developers.\n    ///\n    /// # Returns\n    /// * `Option<AztecAddress>` - The address of the smart contract that called this function (be it an app contract or\n    ///   a user's account contract). Returns `Option<AztecAddress>::none` for the first function call of the tx. No\n    ///   other _private_ function calls in the tx will have a `none` msg_sender, but _public_ function calls might (see\n    ///   the PublicContext).\n    ///\n    pub fn msg_sender(self) -> Option<AztecAddress> {\n        let maybe_msg_sender = self.context.msg_sender_unsafe();\n        if maybe_msg_sender == NULL_MSG_SENDER_CONTRACT_ADDRESS {\n            Option::none()\n        } else {\n            Option::some(maybe_msg_sender)\n        }\n    }\n\n    /// Emits an event privately.\n    ///\n    /// Unlike public events, private events do not reveal their contents publicly. They instead create an\n    /// [EventMessage] containing the private event information, which **MUST** be delivered to a recipient via\n    /// [EventMessage::deliver_to] in order for them to learn about the event. Multiple recipients can have the same\n    /// message be delivered to them.\n    ///\n    /// # Example\n    /// ```noir\n    /// #[event]\n    /// struct Transfer { from: AztecAddress, to: AztecAddress, amount: u128 }\n    ///\n    /// #[external(\"private\")]\n    /// fn transfer(to: AztecAddress, amount: u128) {\n    ///     let from = self.msg_sender().unwrap();\n    ///\n    ///     let message: EventMessage = self.emit(Transfer { from, to, amount });\n    ///     message.deliver_to(from, MessageDelivery.UNCONSTRAINED_OFFCHAIN);\n    ///     message.deliver_to(to, MessageDelivery.CONSTRAINED_ONCHAIN);\n    /// }\n    /// ```\n    ///\n    /// # Cost\n    ///\n    /// Private event emission always results in the creation of a nullifer, which acts as a commitment to the event and\n    /// is used by third parties to verify its authenticity. See [EventMessage::deliver_to] for the costs associated to\n    /// delivery.\n    ///\n    /// # Privacy\n    ///\n    /// The nullifier created when emitting a private event leaks nothing about the content of the event - it's a\n    /// commitment that includes a random value, so even with full knowledge of the event preimage determining if an\n    /// event was emitted or not requires brute-forcing the entire `Field` space.\n    pub fn emit<Event>(&mut self, event: Event) -> EventMessage<Event>\n    where\n        Event: EventInterface + Serialize,\n    {\n        emit_event_in_private(self.context, event)\n    }\n\n    /// Makes a call to the private function defined by the `call` parameter.\n    ///\n    /// # Arguments\n    /// * `call` - The object representing the private function to invoke.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    /// # Example\n    /// ```noir\n    /// self.call(Token::at(address).transfer_in_private(recipient, amount));\n    /// ```\n    ///\n    /// This enables contracts to interact with each other while maintaining\n    /// privacy. This \"composability\" of private contract functions is a key\n    /// feature of the Aztec network.\n    ///\n    /// If a user's transaction includes multiple private function calls, then\n    /// by the design of Aztec, the following information will remain private[1]:\n    /// - The function selectors and contract addresses of all private function\n    ///   calls will remain private, so an observer of the public mempool will\n    ///   not be able to look at a tx and deduce which private functions have\n    ///   been executed.\n    /// - The arguments and return values of all private function calls will\n    ///   remain private.\n    /// - The person who initiated the tx will remain private.\n    /// - The notes and nullifiers and private logs that are emitted by all\n    ///   private function calls will (if designed well) not leak any user\n    ///   secrets, nor leak which functions have been executed.\n    ///\n    /// [1] Caveats: Some of these privacy guarantees depend on how app\n    /// developers design their smart contracts. Some actions _can_ leak\n    /// information, such as:\n    /// - Calling an internal public function.\n    /// - Calling a public function and not setting msg_sender to Option::none\n    ///   (see https://github.com/AztecProtocol/aztec-packages/pull/16433)\n    /// - Calling any public function will always leak details about the nature\n    ///   of the transaction, so devs should be careful in their contract\n    ///   designs. If it can be done in a private function, then that will give\n    ///   the best privacy.\n    /// - Not padding the side-effects of a tx to some standardized, uniform\n    ///   size. The kernel circuits can take hints to pad side-effects, so a\n    ///   wallet should be able to request for a particular amount of padding.\n    ///   Wallets should ideally agree on some standard.\n    ///   - Padding should include:\n    ///     - Padding the lengths of note & nullifier arrays\n    ///     - Padding private logs with random fields, up to some standardized\n    ///       size.\n    /// See also: https://docs.aztec.network/developers/resources/considerations/privacy_considerations\n    ///\n    /// # Advanced\n    /// * The call is added to the private call stack and executed by kernel\n    ///   circuits after this function completes\n    /// * The called function can modify its own contract's private state\n    /// * Side effects from the called function are included in this transaction\n    /// * The call inherits the current transaction's context and gas limits\n    ///\n    pub fn call<let M: u32, let N: u32, T>(&mut self, call: PrivateCall<M, N, T>) -> T\n    where\n        T: Deserialize,\n    {\n        call.call(self.context)\n    }\n\n    /// Makes a read-only call to the private function defined by the `call` parameter.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state, emit L2->L1 messages, nor emit events. Any nested\n    /// calls are constrained to also be static calls.\n    ///\n    /// # Arguments\n    /// * `call` - The object representing the read-only private function to invoke.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    /// # Example\n    /// ```noir\n    /// self.view(Token::at(address).balance_of_private(recipient));\n    /// ```\n    pub fn view<let M: u32, let N: u32, T>(&mut self, call: PrivateStaticCall<M, N, T>) -> T\n    where\n        T: Deserialize,\n    {\n        call.view(self.context)\n    }\n\n    /// Enqueues a call to the public function defined by the `call` parameter,\n    /// to be executed later.\n    ///\n    /// Unlike private functions which execute immediately on the user's device,\n    /// public function calls are \"enqueued\" and executed some time later by a\n    /// block proposer.\n    ///\n    /// This means a public function cannot return any values back to a private\n    /// function, because by the time the public function is being executed,\n    /// the private function which called it has already completed execution.\n    /// (In fact, the private function has been executed and proven, along with\n    /// all other private function calls of the user's tx. A single proof of the\n    /// tx has been submitted to the Aztec network, and some time later a\n    /// proposer has picked the tx up from the mempool and begun executing all\n    /// of the enqueued public functions).\n    ///\n    /// # Privacy warning\n    /// Enqueueing a public function call is an inherently leaky action.\n    /// Many interesting applications will require some interaction with public\n    /// state, but smart contract developers should try to use public function\n    /// calls sparingly, and carefully.\n    /// _Internal_ public function calls are especially leaky, because they\n    /// completely leak which private contract made the call.\n    /// See also: https://docs.aztec.network/developers/resources/considerations/privacy_considerations\n    ///\n    /// # Arguments\n    /// * `call` - The interface representing the public function to enqueue.\n    ///\n    /// TODO(F-131): We should drop T from here because it is strange as there\n    /// is no return value. The PublicCall type seems to be defined\n    /// incorrectly.\n    pub fn enqueue<let M: u32, let N: u32, T>(&mut self, call: PublicCall<M, N, T>)\n    where\n        T: Deserialize,\n    {\n        call.enqueue(self.context)\n    }\n\n    /// Enqueues a read-only call to the public function defined by the `call` parameter.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state, emit L2->L1 messages, nor emit events. Any nested\n    /// calls are constrained to also be static calls.\n    ///\n    /// # Arguments\n    /// * `call` - The object representing the read-only public function to enqueue.\n    ///\n    /// # Example\n    /// ```noir\n    /// self.enqueue_view(MyContract::at(address).assert_timestamp_less_than(timestamp));\n    /// ```\n    ///\n    /// TODO(F-131): We should drop T from here because it is strange as there\n    /// is no return value. The PublicCall type seems to be defined\n    /// incorrectly.\n    pub fn enqueue_view<let M: u32, let N: u32, T>(&mut self, call: PublicStaticCall<M, N, T>)\n    where\n        T: Deserialize,\n    {\n        call.enqueue_view(self.context)\n    }\n\n    /// Enqueues a call to the public function defined by the `call` parameter,\n    /// to be executed later.\n    ///\n    /// As per `enqueue`, but hides this calling contract's address from the\n    /// target public function.\n    /// This means the origin of the call (msg_sender) will not be publicly\n    /// visible to any blockchain observers, nor to the target public function.\n    /// When the target public function reads `context.msg_sender()` it will\n    /// receive an `Option<AztecAddress>::none`.\n    ///\n    /// NOTES:\n    /// - Not all public functions will accept a msg_sender of \"none\". Many\n    ///   public functions will require that msg_sender is \"some\" and will\n    ///   revert otherwise. Therefore, if using `enqueue_incognito`, you must\n    ///   understand whether the function you're calling will accept a\n    ///   msg_sender of \"none\".\n    ///   Lots of public bookkeeping patterns rely on knowing which address made\n    ///   the call, so as to ascribe state against the caller's address.\n    ///   (There are patterns whereby bookkeeping could instead be done in\n    ///   private-land).\n    /// - If you are enqueueing a call to an _internal_ public function (i.e.\n    ///   a public function that will only accept calls from other functions\n    ///   of its own contract), then by definition a call to it cannot possibly\n    ///   be \"incognito\": the msg_sender must be its own address, and indeed the\n    ///   called public function will assert this. Tl;dr this is not usable for\n    ///   enqueued internal public calls.\n    ///\n    /// # Arguments\n    /// * `call` - The object representing the public function to enqueue.\n    ///\n    /// # Example\n    /// ```noir\n    /// self.enqueue_incognito(Token::at(address).increase_total_supply_by(amount));\n    /// ```\n    ///\n    /// Advanced:\n    /// - The kernel circuits will permit _any_ private function to set the\n    ///   msg_sender field of any enqueued public function call to\n    ///   NULL_MSG_SENDER_CONTRACT_ADDRESS.\n    /// - When the called public function calls `PublicContext::msg_sender()`,\n    ///   aztec-nr will translate NULL_MSG_SENDER_CONTRACT_ADDRESS into\n    ///   `Option<AztecAddress>::none` for familiarity to devs.\n    ///\n    /// TODO(F-131): We should drop T from here because it is strange as there\n    /// is no return value. The PublicCall type seems to be defined\n    /// incorrectly.\n    pub fn enqueue_incognito<let M: u32, let N: u32, T>(&mut self, call: PublicCall<M, N, T>)\n    where\n        T: Deserialize,\n    {\n        call.enqueue_incognito(self.context)\n    }\n\n    /// Enqueues a read-only call to the public function defined by the `call` parameter.\n    ///\n    /// As per `enqueue_view`, but hides this calling contract's address from\n    /// the target public function.\n    ///\n    /// See `enqueue_incognito` for more details relating to hiding msg_sender.\n    ///\n    /// # Arguments\n    /// * `call` - The object representing the read-only public function to enqueue.\n    ///\n    /// # Example\n    /// ```noir\n    /// self.enqueue_view_incognito(MyContract::at(address).assert_timestamp_less_than(timestamp));\n    /// ```\n    ///\n    /// TODO(F-131): We should drop T from here because it is strange as there\n    /// is no return value. The PublicCall type seems to be defined\n    /// incorrectly.\n    pub fn enqueue_view_incognito<let M: u32, let N: u32, T>(\n        &mut self,\n        call: PublicStaticCall<M, N, T>,\n    )\n    where\n        T: Deserialize,\n    {\n        call.enqueue_view_incognito(self.context)\n    }\n\n    /// Enqueues a call to the public function defined by the `call` parameter,\n    /// and designates it to be the teardown function for this tx. Only one teardown\n    /// function call can be made by a tx.\n    ///\n    /// Niche function: Only wallet developers and paymaster contract developers\n    /// (aka Fee-payment contracts) will need to make use of this function.\n    ///\n    /// Aztec supports a three-phase execution model: setup, app logic, teardown.\n    /// The phases exist to enable a fee payer to take on the risk of paying\n    /// a transaction fee, safe in the knowledge that their payment (in whatever\n    /// token or method the user chooses) will succeed, regardless of whether\n    /// the app logic will succeed. The \"setup\" phase ensures the fee payer\n    /// has sufficient balance to pay the proposer their fees.\n    /// The teardown phase is primarily intended to: calculate exactly\n    /// how much the user owes, based on gas consumption, and refund the user\n    /// any change.\n    ///\n    /// Note: in some cases, the cost of refunding the user (i.e. DA costs of\n    /// tx side-effects) might exceed the refund amount. For app logic with\n    /// fairly stable and predictable gas consumption, a material refund amount\n    /// is unlikely. For app logic with unpredictable gas consumption, a\n    /// refund might be important to the user (e.g. if a hefty function reverts\n    /// very early). Wallet/FPC/Paymaster developers should be mindful of this.\n    ///\n    /// See `enqueue` for more information about enqueuing public function calls.\n    ///\n    /// # Arguments\n    /// * `call` - The object representing the public function to designate as teardown.\n    ///\n    /// TODO(F-131): We should drop T from here because it is strange as there\n    /// is no return value. The PublicCall type seems to be defined\n    /// incorrectly.\n    pub fn set_as_teardown<let M: u32, let N: u32, T>(&mut self, call: PublicCall<M, N, T>)\n    where\n        T: Deserialize,\n    {\n        call.set_as_teardown(self.context)\n    }\n\n    /// Enqueues a call to the public function defined by the `call` parameter,\n    /// and designates it to be the teardown function for this tx. Only one teardown\n    /// function call can be made by a tx.\n    ///\n    /// As per `set_as_teardown`, but hides this calling contract's address from\n    /// the target public function.\n    ///\n    /// See `enqueue_incognito` for more details relating to hiding msg_sender.\n    ///\n    /// TODO(F-131): We should drop T from here because it is strange as there\n    /// is no return value. The PublicCall type seems to be defined\n    /// incorrectly.\n    pub fn set_as_teardown_incognito<let M: u32, let N: u32, T>(\n        &mut self,\n        call: PublicCall<M, N, T>,\n    )\n    where\n        T: Deserialize,\n    {\n        call.set_as_teardown_incognito(self.context)\n    }\n}\n\n/// Implementation for `ContractSelf` in public execution contexts.\n///\n/// This implementation is used when a contract function is marked with `#[external(\"public\")]`.\n/// Public functions are executed by the sequencer in the Aztec Virtual Machine (AVM) and can work only with public\n/// state.\nimpl<Storage, CallSelf, CallSelfStatic, CallInternal> ContractSelf<PublicContext, Storage, CallSelf, (), CallSelfStatic, (), CallInternal> {\n    /// Creates a new `ContractSelf` instance for a public function.\n    ///\n    /// This constructor is called automatically by the macro system and should not be called directly.\n    pub fn new_public(\n        context: PublicContext,\n        storage: Storage,\n        call_self: CallSelf,\n        call_self_static: CallSelfStatic,\n        internal: CallInternal,\n    ) -> Self {\n        Self {\n            context,\n            storage,\n            address: context.this_address(),\n            call_self,\n            enqueue_self: (),\n            call_self_static,\n            enqueue_self_static: (),\n            internal,\n        }\n    }\n\n    /// Returns the contract address that initiated this function call.\n    ///\n    /// This is similar to `msg.sender` in Solidity (hence the name).\n    ///\n    /// Important Note: If the calling function is a _private_ function, then it had the option of hiding its address\n    /// when enqueuing this public function call. In such cases, this `context.msg_sender()` method will return\n    /// `Option<AztecAddress>::none`. If the calling function is a _public_ function, it will always return an\n    /// `Option<AztecAddress>::some` (i.e. a non-null value).\n    ///\n    /// # Returns\n    /// * `Option<AztecAddress>` - The address of the smart contract that called this function (be it an app contract or\n    ///   a user's account contract).\n    ///\n    /// # Advanced\n    /// * Value is provided by the AVM sender opcode\n    /// * In nested calls, this is the immediate caller, not the original transaction sender\n    ///\n    pub fn msg_sender(self: Self) -> Option<AztecAddress> {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        let maybe_msg_sender = self.context.msg_sender_unsafe();\n        if maybe_msg_sender == NULL_MSG_SENDER_CONTRACT_ADDRESS {\n            Option::none()\n        } else {\n            Option::some(maybe_msg_sender)\n        }\n    }\n\n    /// Emits an event publicly.\n    ///\n    /// Public events are emitted as plaintext and are therefore visible to everyone. This is is the same as Solidity\n    /// events on EVM chains.\n    ///\n    /// Unlike private events, they don't require delivery of an event message.\n    ///\n    /// # Example\n    /// ```noir\n    /// #[event]\n    /// struct Update { value: Field }\n    ///\n    /// #[external(\"public\")]\n    /// fn publish_update(value: Field) {\n    ///     self.emit(Update { value });\n    /// }\n    /// ```\n    ///\n    /// # Cost\n    ///\n    /// Public event emission is achieved by emitting public transaction logs. A total of `N+1` fields are emitted,\n    /// where `N` is the serialization length of the event.\n    pub fn emit<Event>(&mut self, event: Event)\n    where\n        Event: EventInterface + Serialize,\n    {\n        emit_event_in_public(self.context, event);\n    }\n\n    /// Makes the call to the public function defined by the `call` parameter.\n    ///\n    /// Will revert if the called function reverts or runs out of gas.\n    ///\n    /// # Arguments\n    /// * `call` - The object representing the public function to invoke.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    /// # Example\n    /// ```noir\n    /// self.call(Token::at(address).transfer_in_public(recipient, amount));\n    /// ```\n    ///\n    pub unconstrained fn call<let M: u32, let N: u32, T>(self, call: PublicCall<M, N, T>) -> T\n    where\n        T: Deserialize,\n    {\n        call.call(self.context)\n    }\n\n    /// Makes the read-only call to the public function defined by the `call` parameter.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state or emit events. Any nested calls are constrained to\n    /// also be static calls.\n    ///\n    /// Will revert if the called function reverts or runs out of gas.\n    ///\n    /// # Arguments\n    /// * `call` - The object representing the read-only public function to invoke.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    /// # Example\n    /// ```noir\n    /// self.view(Token::at(address).balance_of_public(recipient));\n    /// ```\n    ///\n    pub unconstrained fn view<let M: u32, let N: u32, T>(self, call: PublicStaticCall<M, N, T>) -> T\n    where\n        T: Deserialize,\n    {\n        call.view(self.context)\n    }\n}\n\n/// Implementation for `ContractSelf` in utility execution contexts.\n///\n/// This implementation is used when a contract function is marked with `#[external(\"utility\")]`.\n/// Utility functions are unconstrained functions that can read private state for offchain queries.\n/// They are typically used for view functions that need to access private notes (e.g. a Token's balance_of function).\nimpl<Storage> ContractSelf<UtilityContext, Storage, (), (), (), (), ()> {\n    /// Creates a new `ContractSelf` instance for a utility function.\n    ///\n    /// This constructor is called automatically by the macro system and should not be called directly.\n    pub fn new_utility(context: UtilityContext, storage: Storage) -> Self {\n        Self {\n            context,\n            storage,\n            address: context.this_address(),\n            call_self: (),\n            enqueue_self: (),\n            call_self_static: (),\n            enqueue_self_static: (),\n            internal: (),\n        }\n    }\n}\n","path":"/Users/zac/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/contract_self.nr"},"75":{"source":"use crate::{\n    context::{PrivateContext, PublicContext},\n    event::{\n        event_interface::{compute_private_event_commitment, EventInterface},\n        event_message::EventMessage,\n    },\n    oracle::random::random,\n};\nuse protocol_types::traits::{Serialize, ToField};\n\n/// An event that was emitted in the current contract call.\npub struct NewEvent<Event> {\n    pub(crate) event: Event,\n    pub(crate) randomness: Field,\n    pub(crate) commitment: Field,\n}\n\n/// Equivalent to `self.emit(event)`: see [crate::contract_self::ContractSelf::emit].\npub fn emit_event_in_private<Event>(\n    context: &mut PrivateContext,\n    event: Event,\n) -> EventMessage<Event>\nwhere\n    Event: EventInterface + Serialize,\n{\n    // In private events, we automatically inject randomness to prevent event commitment preimage attacks and event\n    // commitment collisions (the commitments are included in the nullifier tree and duplicate nullifiers are by\n    // definition not allowed).\n\n    // Safety: We use the randomness to preserve the privacy of the event recipient by preventing brute-forcing,\n    // so a malicious sender could use non-random values to make the event less private. But they already know\n    // the full event pre-image anyway, and so the recipient already trusts them to not disclose this information.\n    // We can therefore assume that the sender will cooperate in the random value generation.\n    let randomness = unsafe { random() };\n\n    // The event commitment is emitted as a nullifier instead of as a note because these are simpler: nullifiers cannot\n    // be squashed, making kernel processing simpler, and they have no nonce that recipients need to discover.\n    let commitment = compute_private_event_commitment(event, randomness);\n    context.push_nullifier(commitment);\n\n    EventMessage::new(NewEvent { event, randomness, commitment }, context)\n}\n\n/// Equivalent to `self.emit(event)`: see [crate::contract_self::ContractSelf::emit].\npub fn emit_event_in_public<Event>(context: PublicContext, event: Event)\nwhere\n    Event: EventInterface + Serialize,\n{\n    let mut log_content = [0; <Event as Serialize>::N + 1];\n\n    let serialized_event = event.serialize();\n    for i in 0..serialized_event.len() {\n        log_content[i] = serialized_event[i];\n    }\n\n    // We put the selector in the \"last\" place, to avoid reading or assigning to an expression in an index\n    // TODO(F-224): change this order.\n    log_content[serialized_event.len()] = Event::get_event_type_id().to_field();\n\n    context.emit_public_log(log_content);\n}\n","path":"/Users/zac/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/event/event_emission.nr"},"78":{"source":"use dep::protocol_types::{\n    hash::poseidon2_hash_bytes,\n    traits::{Deserialize, Empty, FromField, Serialize, ToField},\n};\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct EventSelector {\n    // 1st 4-bytes (big-endian leftmost) of abi-encoding of an event.\n    inner: u32,\n}\n\nimpl FromField for EventSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for EventSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for EventSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl EventSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        EventSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n","path":"/Users/zac/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/event/event_selector.nr"},"80":{"source":"use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n        GENERATOR_INDEX__FUNCTION_ARGS, GENERATOR_INDEX__MESSAGE_NULLIFIER,\n        GENERATOR_INDEX__PUBLIC_BYTECODE, GENERATOR_INDEX__PUBLIC_CALLDATA,\n        GENERATOR_INDEX__SECRET_HASH, MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS,\n    },\n    hash::{poseidon2_hash_subarray, poseidon2_hash_with_separator, sha256_to_field},\n    point::Point,\n    traits::ToField,\n};\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_l1_to_l2_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field,\n    leaf_index: Field,\n) -> Field {\n    let mut hash_bytes = [0 as u8; 224];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n    let leaf_index_bytes: [u8; 32] = leaf_index.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n        hash_bytes[i + 192] = leaf_index_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret\npub fn compute_l1_to_l2_message_nullifier(message_hash: Field, secret: Field) -> Field {\n    poseidon2_hash_with_separator([message_hash, secret], GENERATOR_INDEX__MESSAGE_NULLIFIER)\n}\n\n// Computes the hash of input arguments or return values for private functions, or for authwit creation.\npub fn hash_args<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Computes the hash of calldata for public functions.\npub fn hash_calldata_array<let N: u32>(calldata: [Field; N]) -> Field {\n    poseidon2_hash_with_separator(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n}\n\n/**\n * Computes the public bytecode commitment for a contract class.\n * The commitment is `hash([separator, ...bytecode])` where bytecode omits the length prefix present\n * in `packed_bytecode`.\n *\n * @param packed_bytecode - The packed bytecode of the contract class. 0th word is the length in bytes.\n *    packed_bytecode is mutable so that we can avoid copying the array to construct one starting with\n *    separator instead of length.\n * @returns The public bytecode commitment.\n */\npub fn compute_public_bytecode_commitment(\n    mut packed_public_bytecode: [Field; MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS],\n) -> Field {\n    // First field element contains the length of the bytecode\n    let bytecode_length_in_bytes: u32 = packed_public_bytecode[0] as u32;\n    let bytecode_length_in_fields: u32 =\n        (bytecode_length_in_bytes / 31) + (bytecode_length_in_bytes % 31 != 0) as u32;\n    // Don't allow empty public bytecode.\n    // AVM doesn't handle execution of contracts that exist with empty bytecode.\n    assert(bytecode_length_in_fields != 0);\n    assert(bytecode_length_in_fields < MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS);\n\n    // Packed_bytecode's 0th entry is the length. Replace it with separator before hashing.\n    let separator = GENERATOR_INDEX__PUBLIC_BYTECODE.to_field();\n    packed_public_bytecode[0] = separator;\n\n    // `fields_to_hash` is the number of fields from the start of `packed_public_bytecode` that should be included in\n    // the hash. Fields after this length are ignored.\n    // +1 to account for the separator.\n    let num_fields_to_hash = bytecode_length_in_fields + 1;\n\n    poseidon2_hash_subarray(packed_public_bytecode, num_fields_to_hash)\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = [0; 100];\n    for i in 0..100 {\n        input[i] = i as Field;\n    }\n    let hash = hash_args(input);\n    dep::std::println(hash);\n    // Used in yarn-project/stdlib test snapshots:\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n\n#[test]\nunconstrained fn compute_calldata_hash() {\n    let mut input = [0; 100];\n    for i in 0..input.len() {\n        input[i] = i as Field;\n    }\n    let hash = hash_calldata_array(input);\n    // Used in cpp vm2 tests:\n    assert(hash == 0x191383c9f8964afd3ea8879a03b7dda65d6724773966d18dcf80e452736fc1f3);\n}\n\n#[test]\nunconstrained fn public_bytecode_commitment() {\n    let mut input = [0; MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS];\n    let len = 99;\n    for i in 1..len + 1 {\n        input[i] = i as Field;\n    }\n    input[0] = (len as Field) * 31;\n    let hash = compute_public_bytecode_commitment(input);\n    dep::std::println(hash);\n    // Used in cpp vm2 tests:\n    assert(hash == 0x16d621c3387156ef53754679e7b2c9be8f0bceeb44aa59a74991df3b0b42a0bf);\n}\n","path":"/Users/zac/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/hash.nr"},"101":{"source":"use crate::macros::{\n    calls_generation::{\n        external_functions::{\n            generate_external_function_calls, generate_external_function_self_calls_structs,\n        },\n        internal_functions::generate_call_internal_struct,\n    },\n    dispatch::generate_public_dispatch,\n    internals_functions_generation::{create_fn_abi_exports, process_functions},\n    notes::NOTES,\n    storage::STORAGE_LAYOUT_NAME,\n    utils::{\n        get_trait_impl_method, is_fn_contract_library_method, is_fn_external, is_fn_internal,\n        is_fn_test, module_has_storage,\n    },\n};\n\n/// Marks a contract as an Aztec contract, generating the interfaces for its functions and notes, as well as injecting\n/// the `sync_private_state` utility function.\n/// Note: This is a module annotation, so the returned quote gets injected inside the module (contract) itself.\npub comptime fn aztec(m: Module) -> Quoted {\n    // Functions that don't have #[external(...)], #[contract_library_method], or #[test] are not allowed in contracts.\n    check_each_fn_macroified(m);\n\n    // We generate new functions prefixed with `__aztec_nr_internals__` and we replace the original functions' bodies\n    // with `static_assert(false, ...)` to prevent them from being called directly from within the contract.\n    let functions = process_functions(m);\n\n    // We generate structs and their implementations necessary for convenient functions calls.\n    let interface = generate_contract_interface(m);\n    let self_call_structs = generate_external_function_self_calls_structs(m);\n    let call_internal_struct = generate_call_internal_struct(m);\n\n    // We generate ABI exports for all the external functions in the contract.\n    let fn_abi_exports = create_fn_abi_exports(m);\n\n    // We generate `_compute_note_hash_and_nullifier`, `sync_private_state` and `process_message`\n    // functions only if they are not already implemented. If they are implemented we just insert empty\n    // quotes.\n    let contract_library_method_compute_note_hash_and_nullifier = if !m.functions().any(|f| {\n        f.name() == quote { _compute_note_hash_and_nullifier }\n    }) {\n        generate_contract_library_method_compute_note_hash_and_nullifier()\n    } else {\n        quote {}\n    };\n    let sync_private_state_fn_and_abi_export = if !m.functions().any(|f| {\n        f.name() == quote { sync_private_state }\n    }) {\n        generate_sync_private_state()\n    } else {\n        quote {}\n    };\n\n    let process_message_fn_and_abi_export = if !m.functions().any(|f| {\n        f.name() == quote { process_message }\n    }) {\n        generate_process_message()\n    } else {\n        quote {}\n    };\n    let public_dispatch = generate_public_dispatch(m);\n\n    quote {\n        $interface\n        $self_call_structs\n        $call_internal_struct\n        $functions\n        $fn_abi_exports\n        $contract_library_method_compute_note_hash_and_nullifier\n        $public_dispatch\n        $sync_private_state_fn_and_abi_export\n        $process_message_fn_and_abi_export\n    }\n}\n\ncomptime fn generate_contract_interface(m: Module) -> Quoted {\n    let calls = generate_external_function_calls(m);\n\n    let module_name = m.name();\n\n    let has_storage_layout = module_has_storage(m) & STORAGE_LAYOUT_NAME.get(m).is_some();\n    let storage_layout_getter = if has_storage_layout {\n        let storage_layout_name = STORAGE_LAYOUT_NAME.get(m).unwrap();\n        quote {\n            pub fn storage_layout() -> StorageLayoutFields {\n                $storage_layout_name.fields\n            }\n        }\n    } else {\n        quote {}\n    };\n\n    let library_storage_layout_getter = if has_storage_layout {\n        quote {\n            #[contract_library_method]\n            $storage_layout_getter\n        }\n    } else {\n        quote {}\n    };\n\n    quote {\n        pub struct $module_name {\n            pub target_contract: dep::aztec::protocol_types::address::AztecAddress\n        }\n\n        impl $module_name {\n            $calls\n\n            pub fn at(\n                addr: aztec::protocol_types::address::AztecAddress\n            ) -> Self {\n                Self { target_contract: addr }\n            }\n\n            pub fn interface() -> Self {\n                Self { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n            }\n\n            $storage_layout_getter\n        }\n\n        #[contract_library_method]\n        pub fn at(\n            addr: aztec::protocol_types::address::AztecAddress\n        ) -> $module_name {\n            $module_name { target_contract: addr }\n        }\n\n        #[contract_library_method]\n        pub fn interface() -> $module_name {\n            $module_name { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n        }\n\n        $library_storage_layout_getter\n\n    }\n}\n\n/// Generates a contract library method called `_compute_note_hash_and_nullifier` which is used for note\n/// discovery (to create the `aztec::messages::discovery::ComputeNoteHashAndNullifier` function) and to implement the\n/// `compute_note_hash_and_nullifier` unconstrained contract function.\ncomptime fn generate_contract_library_method_compute_note_hash_and_nullifier() -> Quoted {\n    if NOTES.len() > 0 {\n        // Contracts that do define notes produce an if-else chain where `note_type_id` is matched against the\n        // `get_note_type_id()` function of each note type that we know of, in order to identify the note type. Once we\n        // know it we call we correct `unpack` method from the `Packable` trait to obtain the underlying note type, and\n        // compute the note hash (non-siloed) and inner nullifier (also non-siloed).\n\n        let mut if_note_type_id_match_statements_list = &[];\n        for i in 0..NOTES.len() {\n            let typ = NOTES.get(i);\n\n            let get_note_type_id = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteType },\n                quote { get_id },\n            );\n            let unpack = get_trait_impl_method(\n                typ,\n                quote { crate::protocol_types::traits::Packable },\n                quote { unpack },\n            );\n\n            let compute_note_hash = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_note_hash },\n            );\n\n            let compute_nullifier_unconstrained = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_nullifier_unconstrained },\n            );\n\n            let if_or_else_if = if i == 0 {\n                quote { if }\n            } else {\n                quote { else if }\n            };\n\n            if_note_type_id_match_statements_list = if_note_type_id_match_statements_list.push_back(\n                quote {\n                    $if_or_else_if note_type_id == $get_note_type_id() {\n                        // As an extra safety check we make sure that the packed_note BoundedVec has the expected\n                        // length, since we're about to interpret its raw storage as a fixed-size array by calling the\n                        // unpack function on it.\n                        let expected_len = <$typ as $crate::protocol_types::traits::Packable>::N;\n                        let actual_len = packed_note.len();\n                        assert(\n                            actual_len == expected_len,\n                            f\"Expected packed note of length {expected_len} but got {actual_len} for note type id {note_type_id}\"\n                        );\n\n                        let note = $unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n\n                        let note_hash = $compute_note_hash(note, owner, storage_slot, randomness);\n    \n                        // The message discovery process finds settled notes, that is, notes that were created in prior\n                        // transactions and are therefore already part of the note hash tree. We therefore compute the\n                        // nullification note hash by treating the note as a settled note with the provided note nonce.\n                        let note_hash_for_nullification = aztec::note::utils::compute_note_hash_for_nullification(\n                            aztec::note::retrieved_note::RetrievedNote{ \n                                note,\n                                contract_address,\n                                owner,\n                                randomness,\n                                storage_slot,\n                                metadata: aztec::note::note_metadata::SettledNoteMetadata::new(note_nonce).into()\n                            }\n                        );\n\n                        let inner_nullifier = $compute_nullifier_unconstrained(note, owner, note_hash_for_nullification);\n\n                        Option::some(\n                            aztec::messages::discovery::NoteHashAndNullifier {\n                                note_hash, inner_nullifier\n                            }\n                        )\n                    }\n                },\n            );\n        }\n\n        let if_note_type_id_match_statements = if_note_type_id_match_statements_list.join(quote {});\n\n        quote {\n            /// Unpacks an array into a note corresponding to `note_type_id` and then computes its note hash\n            /// (non-siloed) and inner nullifier (non-siloed) assuming the note has been inserted into the note hash\n            /// tree with `note_nonce`.\n            ///\n            /// The signature of this function notably matches the `aztec::messages::discovery::ComputeNoteHashAndNullifier` type,\n            /// and so it can be used to call functions from that module such as `discover_new_messages`, \n            /// `do_process_message` and `attempt_note_discovery`.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                owner: aztec::protocol_types::address::AztecAddress,\n                storage_slot: Field,\n                note_type_id: Field,\n                contract_address: aztec::protocol_types::address::AztecAddress,\n                randomness: Field,\n                note_nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                $if_note_type_id_match_statements\n                else {\n                    Option::none()\n                }\n            }\n        }\n    } else {\n        // Contracts with no notes still implement this function to avoid having special-casing, the implementation\n        // simply throws immediately.\n        quote {\n            /// This contract does not use private notes, so this function should never be called as it will\n            /// unconditionally fail.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                _packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                _owner: aztec::protocol_types::address::AztecAddress,\n                _storage_slot: Field,\n                _note_type_id: Field,\n                _contract_address: aztec::protocol_types::address::AztecAddress,\n                _randomness: Field,\n                _nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                panic(f\"This contract does not use private notes\")\n            }\n        }\n    }\n}\n\ncomptime fn generate_sync_private_state() -> Quoted {\n    quote {\n        pub struct sync_private_state_parameters {}\n\n        #[abi(functions)]\n        pub struct sync_private_state_abi {\n            parameters: sync_private_state_parameters,\n        }\n\n        #[aztec::macros::internals_functions_generation::abi_attributes::abi_utility]\n        unconstrained fn sync_private_state() {\n            let address = aztec::context::utility_context::UtilityContext::new().this_address();\n            \n            aztec::messages::discovery::discover_new_messages(address, _compute_note_hash_and_nullifier);\n        }\n    }\n}\n\ncomptime fn generate_process_message() -> Quoted {\n    quote {\n        pub struct process_message_parameters {\n            pub message_ciphertext: BoundedVec<Field, aztec::messages::encoding::MESSAGE_CIPHERTEXT_LEN>,\n            pub message_context: aztec::messages::processing::message_context::MessageContext,\n        }\n\n        #[abi(functions)]\n        pub struct process_message_abi {\n            parameters: process_message_parameters,\n        }\n\n        #[aztec::macros::internals_functions_generation::abi_attributes::abi_utility]\n        unconstrained fn process_message(\n            message_ciphertext: BoundedVec<Field, aztec::messages::encoding::MESSAGE_CIPHERTEXT_LEN>,\n            message_context: aztec::messages::processing::message_context::MessageContext,\n        ) {\n            let address = aztec::context::utility_context::UtilityContext::new().this_address();\n\n            aztec::messages::discovery::discover_new_messages(address, _compute_note_hash_and_nullifier);     \n            aztec::messages::discovery::process_message::process_message_ciphertext(\n                address,\n                _compute_note_hash_and_nullifier,\n                message_ciphertext,\n                message_context,\n            );\n        }\n    }\n}\n\n/// Checks if each function in the module is marked with either #[external(...)], #[contract_library_method], or #[test].\n/// Non-macroified functions are not allowed in contracts.\ncomptime fn check_each_fn_macroified(m: Module) {\n    for f in m.functions() {\n        let name = f.name();\n        if !is_fn_external(f)\n            & !is_fn_contract_library_method(f)\n            & !is_fn_internal(f)\n            & !is_fn_test(f) {\n            // We  don't suggest that #[contract_library_method] is allowed because we don't want to introduce another\n            // concept\n            panic(\n                f\"Function {name} must be marked as either #[external(...)], #[internal(...)], or #[test]\",\n            );\n        }\n    }\n}\n","path":"/Users/zac/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/macros/aztec.nr"},"106":{"source":"use crate::macros::internals_functions_generation::external_functions_registry::get_public_functions;\nuse super::utils::compute_fn_selector;\nuse poseidon::poseidon2::Poseidon2Hasher;\nuse protocol_types::meta::utils::get_params_len_quote;\nuse std::{collections::umap::UHashMap, hash::BuildHasherDefault, panic};\n\n/// Returns an `fn public_dispatch(...)` function for the given module that's assumed to be an Aztec contract.\npub comptime fn generate_public_dispatch(m: Module) -> Quoted {\n    let functions = get_public_functions(m);\n\n    let unit = get_type::<()>();\n\n    let seen_selectors =\n        &mut UHashMap::<Field, Quoted, BuildHasherDefault<Poseidon2Hasher>>::default();\n\n    let ifs = functions.map(|function: FunctionDefinition| {\n        let parameters = function.parameters();\n        let return_type = function.return_type();\n\n        let selector: Field = compute_fn_selector(function);\n        let fn_name = function.name();\n\n        // Since function selectors are computed as the first 4 bytes of the hash of the function signature,\n        // it's possible to have collisions. With the following check, we ensure it doesn't happen within\n        // the same contract.\n        if seen_selectors.contains_key(selector) {\n            let existing_fn = seen_selectors.get(selector).unwrap();\n            panic(\n                f\"Public function selector collision detected between functions '{fn_name}' and '{existing_fn}'\",\n            );\n        }\n        seen_selectors.insert(selector, fn_name);\n\n        let params_len_quote = get_params_len_quote(parameters);\n\n        let initial_read = if parameters.len() == 0 {\n            quote {}\n        } else {\n            // The initial calldata_copy offset is 1 to skip the Field selector\n            // The expected calldata is the serialization of\n            // - FunctionSelector: the selector of the function intended to dispatch\n            // - Parameters: the parameters of the function intended to dispatch\n            // That is, exactly what is expected for a call to the target function,\n            // but with a selector added at the beginning.\n            quote {\n                let input_calldata: [Field; $params_len_quote] = dep::aztec::context::public_context::calldata_copy(1, $params_len_quote);\n                let mut reader = dep::aztec::protocol_types::utils::reader::Reader::new(input_calldata);\n            }\n        };\n\n        let parameter_index: &mut u32 = &mut 0;\n        let reads = parameters.map(|param: (Quoted, Type)| {\n            let parameter_index_value = *parameter_index;\n            let param_name = f\"arg{parameter_index_value}\".quoted_contents();\n            let param_type = param.1;\n            let read = quote {\n                let $param_name: $param_type = reader.read_struct(dep::aztec::protocol_types::traits::Deserialize::deserialize);\n            };\n            *parameter_index += 1;\n            quote { $read }\n        });\n        let read = reads.join(quote { });\n\n        let mut args = &[];\n        for parameter_index in 0..parameters.len() {\n            let param_name = f\"arg{parameter_index}\".quoted_contents();\n            args = args.push_back(quote { $param_name });\n        }\n\n        // We call a function whose name is prefixed with `__aztec_nr_internals__`. This is necessary because the\n        // original function is intentionally made uncallable, preventing direct invocation within the contract.\n        // Instead, a new function with the same name, but prefixed by `__aztec_nr_internals__`, has been generated to\n        // be called here. For more details see the `process_functions` function.\n        let name = f\"__aztec_nr_internals__{fn_name}\".quoted_contents();\n        let args = args.join(quote { , });\n        let call = quote { $name($args) };\n\n        let return_code = if return_type == unit {\n            quote {\n                $call;\n                // Force early return.\n                dep::aztec::context::public_context::avm_return([]);\n            }\n        } else {\n            quote {\n                let return_value = dep::aztec::protocol_types::traits::Serialize::serialize($call);\n                dep::aztec::context::public_context::avm_return(return_value.as_slice());\n            }\n        };\n\n        let if_ = quote {\n            if selector == $selector {\n                $initial_read\n                $read\n                $return_code\n            }\n        };\n        if_\n    });\n\n    if ifs.len() == 0 {\n        // No dispatch function if there are no public functions\n        quote {}\n    } else {\n        let ifs = ifs.push_back(quote { panic(f\"Unknown selector {selector}\") });\n        let dispatch = ifs.join(quote {  });\n\n        let body = quote {\n            // We mark this as public because our whole system depends on public functions having this attribute.\n            #[aztec::macros::internals_functions_generation::abi_attributes::abi_public]\n            pub unconstrained fn public_dispatch(selector: Field) {\n                $dispatch\n            }\n        };\n\n        body\n    }\n}\n\ncomptime fn get_type<T>() -> Type {\n    let t: T = std::mem::zeroed();\n    std::meta::type_of(t)\n}\n","path":"/Users/zac/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/macros/dispatch.nr"},"109":{"source":"use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress,\n    constants::GENERATOR_INDEX__CONSTRUCTOR, hash::poseidon2_hash_with_separator, traits::ToField,\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext},\n    oracle::get_contract_instance::{\n        get_contract_instance, get_contract_instance_deployer_avm,\n        get_contract_instance_initialization_hash_avm,\n    },\n};\n\n// Used by `create_mark_as_initialized` (you won't find it through searching)\npub fn mark_as_initialized_public(context: PublicContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\n// Used by `create_mark_as_initialized` (you won't find it through searching)\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\n// Used by `create_init_check` (you won't find it through searching)\npub fn assert_is_initialized_public(context: PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\n// Used by `create_init_check` (you won't find it through searching)\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    context.push_nullifier_read_request(init_nullifier, context.this_address());\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\n// Used by `create_assert_correct_initializer_args` (you won't find it through searching)\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let deployer = get_contract_instance_deployer_avm(address).unwrap();\n    let initialization_hash = get_contract_instance_initialization_hash_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (deployer.is_zero()) | (deployer == context.msg_sender().unwrap()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\n// Used by `create_assert_correct_initializer_args` (you won't find it through searching)\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender().unwrap()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\n/// This function is not only used in macros but it's also used by external people to check that an instance has been\n/// initialized with the correct constructor arguments. Don't hide this unless you implement factory functionality.\npub fn compute_initialization_hash(\n    init_selector: FunctionSelector,\n    init_args_hash: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR,\n    )\n}\n","path":"/Users/zac/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/macros/functions/initialization_utils.nr"},"113":{"source":"use crate::macros::{\n    functions::auth_registry::AUTHORIZE_ONCE_REGISTRY,\n    utils::{is_fn_initializer, is_fn_only_self, is_fn_view},\n};\nuse std::meta::ctstring::AsCtString;\n\n/// Gathers all attributes relevant to the function's ABI and returns a quote that can be applied to the newly generated\n/// function. We apply the abi marker attributes instead of the original ones (e.g. abi_view instead of view) to avoid\n/// the relevant attribute's functionality from getting triggered.\npub(crate) comptime fn get_abi_relevant_attributes(f: FunctionDefinition) -> Quoted {\n    let mut attributes = quote {};\n\n    if is_fn_view(f) {\n        attributes = quote { $attributes #[aztec::macros::internals_functions_generation::abi_attributes::abi_view] };\n    }\n\n    if is_fn_only_self(f) {\n        attributes = quote { $attributes #[aztec::macros::internals_functions_generation::abi_attributes::abi_only_self] };\n    }\n\n    if is_fn_initializer(f) {\n        attributes = quote { $attributes #[aztec::macros::internals_functions_generation::abi_attributes::abi_initializer] };\n    }\n\n    attributes\n}\n\n/// Injects a call to `aztec::messages::discovery::discover_new_messages`, causing for new notes to be added to PXE and made\n/// available for the current execution.\npub(crate) comptime fn create_message_discovery_call() -> Quoted {\n    quote {\n        /// Safety: message discovery returns nothing and is performed solely for its side-effects. It is therefore\n        /// always safe to call.\n        unsafe {\n            dep::aztec::messages::discovery::discover_new_messages(\n                self.address,\n                _compute_note_hash_and_nullifier,\n            );\n        };\n    }\n}\n\n/// Injects an authwit verification check of the form:\n/// ```\n///   if (!from.eq(context.msg_sender().unwrap())) {\n///         assert_current_call_valid_authwit::<N>(&mut context, from);\n///     } else {\n///         assert(authwit_nonce, \"Invalid authwit nonce. When 'from' and 'msg_sender' are the same, authwit_nonce must be zero\");\n///     }\n/// ```\n/// where `from` and `authwit_nonce` are the names of the parameters that are expected to be present in the function definition.\n/// This check is injected by the `#[authorize_once(\"from_arg_name\", \"nonce_arg_name\")]`, which allows the user to define\n/// which parameters to use.\n///\n/// # Arguments\n/// * `f` - The function definition to inject the authwit verification check into. The function must have parameters\n///         matching the names specified in the `#[authorize_once]` attribute.\n/// * `is_private` - Whether the function is a private function (`true`) or a public function (`false`). This determines\n///                  which authwit verification method to use: `assert_current_call_valid_authwit` for private functions\n///                  or `assert_current_call_valid_authwit_public` for public functions.\npub(crate) comptime fn create_authorize_once_check(\n    f: FunctionDefinition,\n    is_private: bool,\n) -> Quoted {\n    let maybe_authorize_once_args = AUTHORIZE_ONCE_REGISTRY.get(f);\n    let authorize_once_args = if maybe_authorize_once_args.is_some() {\n        maybe_authorize_once_args.unwrap()\n    } else {\n        // We need to for authorize_once to have already executed so that we can retrieve its params - this depends on\n        // the order in which the attributes are applied.\n        panic(\n            f\"Functions marked with #[authorize_once] must have the #[external(\\\"private\\\")] or #[external(\\\"public\\\")] attribute placed last\",\n        )\n    };\n\n    let (from_arg_name, nonce_arg_name) = authorize_once_args;\n    let name: Quoted = f.name();\n\n    let from_arg_candidates =\n        f.parameters().filter(|(name, _)| name == f\"{from_arg_name}\".quoted_contents());\n    let (from_arg_name_quoted, from_arg_type) = if from_arg_candidates.len() == 1 {\n        from_arg_candidates[0]\n    } else {\n        panic(\n            f\"Function {name} does not have a {from_arg_name} parameter. Please specify which one to use in #[authorize_once(\\\"...\\\", \\\"authwit_nonce\\\")]\",\n        )\n    };\n    if from_arg_type\n        != quote { dep::protocol_types::address::aztec_address::AztecAddress }.as_type() {\n        panic(\n            f\"Argument {from_arg_name_quoted} in function {name} must be of type AztecAddress, but is of type {from_arg_type}\",\n        )\n    }\n\n    let nonce_arg_candidates =\n        f.parameters().filter(|(name, _)| name == f\"{nonce_arg_name}\".quoted_contents());\n    let (nonce_arg_name_quoted, nonce_arg_type) = if nonce_arg_candidates.len() == 1 {\n        nonce_arg_candidates[0]\n    } else {\n        panic(\n            f\"Function {name} does not have a {nonce_arg_name}. Please specify which one to use in #[authorize_once(\\\"from\\\", \\\"...\\\")]\",\n        )\n    };\n    if nonce_arg_type != quote { Field }.as_type() {\n        panic(\n            f\"Argument {nonce_arg_name_quoted} in function {name} must be of type Field, but is of type {nonce_arg_type}\",\n        );\n    }\n\n    let nonce_check_quote = f\"{nonce_arg_name_quoted} == 0\".quoted_contents();\n\n    let fn_call = if is_private {\n        let args_len = f.parameters().len();\n        quote { dep::aztec::authwit::auth::assert_current_call_valid_authwit::<$args_len> }\n    } else {\n        quote { dep::aztec::authwit::auth::assert_current_call_valid_authwit_public }\n    };\n    let invalid_nonce_message = f\"Invalid authwit nonce. When '{from_arg_name}' and 'msg_sender' are the same, '{nonce_arg_name}' must be zero\"\n        .as_ctstring()\n        .as_quoted_str();\n    quote {         \n        if (!$from_arg_name_quoted.eq(self.msg_sender().unwrap())) {\n            $fn_call(self.context, $from_arg_name_quoted);\n        } else {\n            assert($nonce_check_quote, $invalid_nonce_message);\n        }\n    }\n}\n","path":"/Users/zac/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/macros/internals_functions_generation/external/helpers.nr"},"116":{"source":"use crate::macros::{\n    internals_functions_generation::external::helpers::{\n        create_authorize_once_check, get_abi_relevant_attributes,\n    },\n    utils::{\n        fn_has_authorize_once, fn_has_noinitcheck, is_fn_initializer, is_fn_only_self, is_fn_view,\n        module_has_initializer, module_has_storage,\n    },\n};\nuse std::meta::ctstring::AsCtString;\n\npub(crate) comptime fn generate_public_external(f: FunctionDefinition) -> Quoted {\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Public functions undergo a lot of transformations from their Aztec.nr form.\n    let original_params = f.parameters();\n\n    let args_len_quote = if original_params.len() == 0 {\n        // If the function has no parameters, we set the args_len to 0.\n        quote { 0 }\n    } else {\n        // The following will give us <type_of_struct_member_1 as Serialize>::N + <type_of_struct_member_2 as Serialize>::N + ...\n        original_params\n            .map(|(_, param_type): (Quoted, Type)| {\n                quote {\n            <$param_type as $crate::protocol_types::traits::Serialize>::N\n        }\n            })\n            .join(quote {+})\n    };\n\n    let storage_init = if module_has_storage {\n        quote {\n            let storage = Storage::init(context);\n        }\n    } else {\n        // Contract does not have Storage defined, so we set storage to the unit type `()`. ContractSelf requires a\n        // storage struct in its constructor. Using an Option type would lead to worse developer experience and higher\n        // constraint counts so we use the unit type `()` instead.\n        quote {\n            let storage = ();\n        }\n    };\n\n    // Unlike in the private case, in public the `context` does not need to receive the hash of the original params.\n    let contract_self_creation = quote {\n        #[allow(unused_variables)]\n        let mut self = {\n            let context = dep::aztec::context::public_context::PublicContext::new(|| {\n            // We start from 1 because we skip the selector for the dispatch function.\n            let serialized_args : [Field; $args_len_quote] = dep::aztec::context::public_context::calldata_copy(1, $args_len_quote);\n            dep::aztec::hash::hash_args(serialized_args)\n            });\n            $storage_init\n            let self_address = context.this_address();\n            let call_self: CallSelf<aztec::context::public_context::PublicContext> = CallSelf { address: self_address, context };\n            let call_self_static: CallSelfStatic<aztec::context::public_context::PublicContext> = CallSelfStatic { address: self_address, context };\n            let internal: CallInternal<aztec::context::public_context::PublicContext> = CallInternal { context };\n            aztec::contract_self::ContractSelf::new_public(context, storage, call_self, call_self_static, internal)\n        };\n    };\n\n    let original_function_name = f.name();\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_only_self(f) {\n        let assertion_message =\n            f\"Function {original_function_name} can only be called by the same contract\";\n        quote { assert(self.msg_sender().unwrap() == self.address, $assertion_message); }\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        let assertion_message = f\"Function {original_function_name} can only be called statically\"\n            .as_ctstring()\n            .as_quoted_str();\n        quote { assert(self.context.is_static_call(), $assertion_message); }\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (\n            quote { aztec::macros::functions::initialization_utils::assert_initialization_matches_address_preimage_public(self.context); },\n            quote { aztec::macros::functions::initialization_utils::mark_as_initialized_public(self.context); },\n        )\n    } else {\n        (quote {}, quote {})\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !fn_has_noinitcheck(f) & !is_fn_initializer(f) {\n        quote { aztec::macros::functions::initialization_utils::assert_is_initialized_public(self.context); }\n    } else {\n        quote {}\n    };\n\n    // Inject the authwit check if the function is marked with #[authorize_once].\n    let authorize_once_check = if fn_has_authorize_once(f) {\n        create_authorize_once_check(f, false)\n    } else {\n        quote {}\n    };\n\n    let to_prepend = quote {\n        $contract_self_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $authorize_once_check\n    };\n\n    let to_append = quote {\n        $mark_as_initialized\n    };\n\n    let fn_name = f\"__aztec_nr_internals__{original_function_name}\".quoted_contents();\n    let body = f.body();\n    let return_type = f.return_type();\n\n    // New function parameters are the same as the original function's ones.\n    let params = original_params\n        .map(|(param_name, param_type)| quote { $param_name: $param_type })\n        .join(quote {, });\n\n    // Preserve all attributes that are relevant to the function's ABI.\n    let abi_relevant_attributes = get_abi_relevant_attributes(f);\n\n    // All public functions are automatically made unconstrained, even if they were not marked as such. This is because\n    // instead of compiling into a circuit, they will compile to bytecode that will be later transpiled into AVM\n    // bytecode.\n    quote {\n        #[aztec::macros::internals_functions_generation::abi_attributes::abi_public]\n        $abi_relevant_attributes\n        unconstrained fn $fn_name($params) -> pub $return_type {\n            $to_prepend\n            $body\n            $to_append\n        }\n    }\n}\n","path":"/Users/zac/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/macros/internals_functions_generation/external/public.nr"},"117":{"source":"use crate::macros::{\n    internals_functions_generation::external::helpers::create_message_discovery_call,\n    utils::module_has_storage,\n};\n\npub(crate) comptime fn generate_utility_external(f: FunctionDefinition) -> Quoted {\n    // Initialize Storage if module has storage\n    let storage_init = if module_has_storage(f.module()) {\n        quote {\n            let storage = Storage::init(context);\n        }\n    } else {\n        // Contract does not have Storage defined, so we set storage to the unit type `()`. ContractSelf requires a\n        // storage struct in its constructor. Using an Option type would lead to worse developer experience and higher\n        // constraint counts so we use the unit type `()` instead.\n        quote {\n            let storage = ();\n        }\n    };\n\n    // Create utility context\n    let contract_self_creation = quote {\n        #[allow(unused_variables)]\n        let mut self = {\n            let context = dep::aztec::context::utility_context::UtilityContext::new();\n            $storage_init\n            aztec::contract_self::ContractSelf::new_utility(context, storage)\n        };\n    };\n\n    // All utility functions perform message discovery, since they may need to access private notes that would be\n    // found during this process or they may be used to sync private events from TypeScript\n    // (`sync_private_state` function gets invoked by PXE::getPrivateEvents function).\n    let message_discovery_call = create_message_discovery_call();\n\n    // A quote to be injected at the beginning of the function body.\n    let to_prepend = quote {\n        dep::aztec::oracle::version::assert_compatible_oracle_version();\n        $contract_self_creation\n        $message_discovery_call\n    };\n\n    let original_function_name = f.name();\n    let fn_name = f\"__aztec_nr_internals__{original_function_name}\".quoted_contents();\n    let body = f.body();\n    let params = f\n        .parameters()\n        .map(|(param_name, param_type)| quote { $param_name: $param_type })\n        .join(quote {, });\n    let return_type = f.return_type();\n\n    quote {\n        #[aztec::macros::internals_functions_generation::abi_attributes::abi_utility]\n        unconstrained fn $fn_name($params) -> pub $return_type {\n            $to_prepend\n            $body\n        }\n    }\n}\n","path":"/Users/zac/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/macros/internals_functions_generation/external/utility.nr"},"126":{"source":"use protocol_types::{address::AztecAddress, debug_log::{debug_log, debug_log_format}};\n\npub mod nonce_discovery;\npub mod partial_notes;\npub mod private_events;\npub mod private_notes;\npub mod process_message;\n\nuse crate::{\n    messages::{\n        discovery::{\n            private_notes::MAX_NOTE_PACKED_LEN, process_message::process_message_ciphertext,\n        },\n        processing::{\n            get_private_logs, pending_tagged_log::PendingTaggedLog,\n            validate_enqueued_notes_and_events,\n        },\n    },\n    utils::array,\n};\n\npub struct NoteHashAndNullifier {\n    /// The result of NoteHash::compute_note_hash\n    pub note_hash: Field,\n    /// The result of NoteHash::compute_nullifier_unconstrained (since all of message discovery is unconstrained)\n    pub inner_nullifier: Field,\n}\n\n/// A function which takes a note's packed content, address of the emitting contract, note nonce, storage slot and note\n/// type ID and attempts to compute its note hash (not hashed by note nonce nor siloed by address) and inner nullifier\n/// (not siloed by address).\n///\n/// This function must be user-provided as its implementation requires knowledge of how note type IDs are allocated in a\n/// contract. The `#[aztec]` macro automatically creates such a contract library method called\n/// `_compute_note_hash_and_nullifier`, which looks something like this:\n///\n/// ```\n/// |packed_note, owner, storage_slot, note_type_id, contract_address, randomness, note_nonce| {\n///     if note_type_id == MyNoteType::get_id() {\n///         assert(packed_note.len() == MY_NOTE_TYPE_SERIALIZATION_LENGTH);\n///\n///         let note = MyNoteType::unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n///\n///         let note_hash = note.compute_note_hash(owner, storage_slot, randomness);\n///         let note_hash_for_nullification = aztec::note::utils::compute_note_hash_for_nullification(\n///             RetrievedNote{ note, contract_address, metadata: SettledNoteMetadata::new(note_nonce).into() },\n///             storage_slot\n///         );\n///\n///         let inner_nullifier = note.compute_nullifier_unconstrained(owner, note_hash_for_nullification);\n///\n///         Option::some(\n///             aztec::messages::discovery::NoteHashAndNullifier {\n///                 note_hash, inner_nullifier\n///             }\n///         )\n///     } else if note_type_id == MyOtherNoteType::get_id() {\n///           ... // Similar to above but calling MyOtherNoteType::unpack_content\n///     } else {\n///         Option::none() // Unknown note type ID\n///     };\n/// }\n/// ```\npub type ComputeNoteHashAndNullifier<Env> = unconstrained fn[Env](/* packed_note */BoundedVec<Field, MAX_NOTE_PACKED_LEN>, /* owner */ AztecAddress, /* storage_slot */ Field, /* note_type_id */ Field, /* contract_address */ AztecAddress, /* randomness */ Field, /* note nonce */ Field) -> Option<NoteHashAndNullifier>;\n\n/// Performs the message discovery process, in which private logs are downloaded and inspected to find new private\n/// notes, partial notes and events, etc., and pending partial notes are processed to search for their completion logs.\n/// This is the mechanism via which a contract updates its knowledge of its private state.\n///\n/// Note that the state is synchronized up to the latest block synchronized by PXE. That should be close to the chain\n/// tip as block synchronization is performed before contract function simulation is done.\n///\n/// Receives the address of the contract on which discovery is performed along with its\n/// `compute_note_hash_and_nullifier` function.\npub unconstrained fn discover_new_messages<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    debug_log(\"Performing message discovery\");\n\n    // First we process all private logs, which can contain different kinds of messages e.g. private notes, partial\n    // notes, private events, etc.\n    let mut logs = get_private_logs(contract_address);\n    logs.for_each(|i, pending_tagged_log: PendingTaggedLog| {\n        debug_log_format(\n            \"Processing log with tag {0}\",\n            [pending_tagged_log.log.get(0)],\n        );\n\n        // We remove the tag from the pending tagged log and process the message ciphertext contained in it.\n        let message_ciphertext = array::subbvec(pending_tagged_log.log, 1);\n\n        process_message_ciphertext(\n            contract_address,\n            compute_note_hash_and_nullifier,\n            message_ciphertext,\n            pending_tagged_log.context,\n        );\n        logs.remove(i);\n    });\n\n    // Then we process all pending partial notes, regardless of whether they were found in the current or previous\n    // executions.\n    partial_notes::fetch_and_process_partial_note_completion_logs(\n        contract_address,\n        compute_note_hash_and_nullifier,\n    );\n\n    // Finally we validate all notes and events that were found as part of the previous processes, resulting in them\n    // being added to PXE's database and retrievable via oracles (get_notes) and our TS API (PXE::getPrivateEvents).\n    validate_enqueued_notes_and_events(contract_address);\n}\n","path":"/Users/zac/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/messages/discovery/mod.nr"},"127":{"source":"use crate::messages::discovery::{ComputeNoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::MAX_NOTE_HASHES_PER_TX,\n    debug_log::debug_log_format,\n    hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n    traits::ToField,\n};\n\n/// A struct with the discovered information of a complete note, required for delivery to PXE. Note that this is *not*\n/// the complete note information, since it does not include content, storage slot, etc.\npub struct DiscoveredNoteInfo {\n    pub note_nonce: Field,\n    pub note_hash: Field,\n    pub inner_nullifier: Field,\n}\n\n/// Searches for note nonces that will result in a note that was emitted in a transaction. While rare, it is possible\n/// for multiple notes to have the exact same packed content and storage slot but different nonces, resulting in\n/// different unique note hashes. Because of this this function returns a *vector* of discovered notes, though in most\n/// cases it will contain a single element.\n///\n/// Due to how nonces are computed, this function requires knowledge of the transaction in which the note was created,\n/// more specifically the list of all unique note hashes in it plus the value of its first nullifier.\npub unconstrained fn attempt_note_nonce_discovery<Env>(\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    contract_address: AztecAddress,\n    owner: AztecAddress,\n    storage_slot: Field,\n    randomness: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) -> BoundedVec<DiscoveredNoteInfo, MAX_NOTE_HASHES_PER_TX> {\n    let discovered_notes = &mut BoundedVec::new();\n\n    debug_log_format(\n        \"Attempting nonce discovery on {0} potential notes on contract {1} for storage slot {2}\",\n        [unique_note_hashes_in_tx.len() as Field, contract_address.to_field(), storage_slot],\n    );\n\n    // We need to find nonces (typically just one) that result in a note hash that, once siloed into a unique note hash,\n    // is one of the note hashes created by the transaction.\n    unique_note_hashes_in_tx.for_eachi(|i, expected_unique_note_hash| {\n        // Nonces are computed by hashing the first nullifier in the transaction with the index of the note in the\n        // new note hashes array. We therefore know for each note in every transaction what its nonce is.\n        let candidate_nonce = compute_note_hash_nonce(first_nullifier_in_tx, i);\n\n        // Given note nonce, note content and metadata, we can compute the note hash and silo it to check if it matches\n        // the note hash at the array index we're currently processing.\n        // TODO(#11157): handle failed note_hash_and_nullifier computation\n        let hashes = compute_note_hash_and_nullifier(\n            packed_note,\n            owner,\n            storage_slot,\n            note_type_id,\n            contract_address,\n            randomness,\n            candidate_nonce,\n        )\n            .expect(f\"Failed to compute a note hash for note type {note_type_id}\");\n\n        let siloed_note_hash = compute_siloed_note_hash(contract_address, hashes.note_hash);\n        let unique_note_hash = compute_unique_note_hash(candidate_nonce, siloed_note_hash);\n\n        if unique_note_hash == expected_unique_note_hash {\n            // Note that while we did check that the note hash is the preimage of the expected unique note hash, we\n            // perform no validations on the nullifier - we fundamentally cannot, since only the application knows\n            // how to compute nullifiers. We simply trust it to have provided the correct one: if it hasn't, then\n            // PXE may fail to realize that a given note has been nullified already, and calls to the application\n            // could result in invalid transactions (with duplicate nullifiers). This is not a concern because an\n            // application already has more direct means of making a call to it fail the transaction.\n            discovered_notes.push(\n                DiscoveredNoteInfo {\n                    note_nonce: candidate_nonce,\n                    note_hash: hashes.note_hash,\n                    inner_nullifier: hashes.inner_nullifier,\n                },\n            );\n\n            // We don't exit the loop - it is possible (though rare) for the exact same note content to be present\n            // multiple times in the same transaction with different nonces. This typically doesn't happen due to\n            // notes containing random values in order to hide their contents.\n        }\n    });\n\n    debug_log_format(\n        \"Found valid nonces for a total of {0} notes\",\n        [discovered_notes.len() as Field],\n    );\n\n    *discovered_notes\n}\n\nmod test {\n    use crate::{\n        messages::discovery::{NoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN},\n        note::{\n            note_interface::{NoteHash, NoteType},\n            note_metadata::SettledNoteMetadata,\n            retrieved_note::RetrievedNote,\n            utils::compute_note_hash_for_nullification,\n        },\n        oracle::random::random,\n        test::mocks::mock_note::MockNote,\n        utils::array,\n    };\n\n    use dep::protocol_types::{\n        address::AztecAddress,\n        hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n        traits::{FromField, Packable},\n    };\n\n    use super::attempt_note_nonce_discovery;\n\n    // This implementation could be simpler, but this serves as a nice example of the expected flow in a real\n    // implementation, and as a sanity check that the interface is sufficient.\n    unconstrained fn compute_note_hash_and_nullifier(\n        packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n        owner: AztecAddress,\n        storage_slot: Field,\n        note_type_id: Field,\n        contract_address: AztecAddress,\n        randomness: Field,\n        note_nonce: Field,\n    ) -> Option<NoteHashAndNullifier> {\n        if note_type_id == MockNote::get_id() {\n            let note = MockNote::unpack(array::subarray(packed_note.storage(), 0));\n            let note_hash = note.compute_note_hash(owner, storage_slot, randomness);\n\n            let note_hash_for_nullification = compute_note_hash_for_nullification(\n                RetrievedNote {\n                    note,\n                    contract_address,\n                    owner,\n                    randomness,\n                    storage_slot,\n                    metadata: SettledNoteMetadata::new(note_nonce).into(),\n                },\n            );\n\n            let inner_nullifier =\n                note.compute_nullifier_unconstrained(owner, note_hash_for_nullification);\n\n            Option::some(NoteHashAndNullifier { note_hash, inner_nullifier })\n        } else {\n            Option::none()\n        }\n    }\n\n    global VALUE: Field = 7;\n    global FIRST_NULLIFIER_IN_TX: Field = 47;\n    global CONTRACT_ADDRESS: AztecAddress = AztecAddress::from_field(13);\n    global OWNER: AztecAddress = AztecAddress::from_field(14);\n    global STORAGE_SLOT: Field = 99;\n    global RANDOMNESS: Field = 99;\n\n    #[test]\n    unconstrained fn no_note_hashes() {\n        let unique_note_hashes_in_tx = BoundedVec::new();\n        let packed_note = BoundedVec::new();\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            OWNER,\n            STORAGE_SLOT,\n            RANDOMNESS,\n            MockNote::get_id(),\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    #[test(should_fail_with = \"Failed to compute a note hash\")]\n    unconstrained fn failed_hash_computation() {\n        let unique_note_hashes_in_tx = BoundedVec::from_array([random()]);\n        let packed_note = BoundedVec::new();\n        let note_type_id = 0; // This note type id is unknown to compute_note_hash_and_nullifier\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            OWNER,\n            STORAGE_SLOT,\n            RANDOMNESS,\n            note_type_id,\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    struct NoteAndData {\n        note: MockNote,\n        note_nonce: Field,\n        note_hash: Field,\n        unique_note_hash: Field,\n        inner_nullifier: Field,\n    }\n\n    unconstrained fn construct_note(value: Field, note_index_in_tx: u32) -> NoteAndData {\n        let note_nonce = compute_note_hash_nonce(FIRST_NULLIFIER_IN_TX, note_index_in_tx);\n\n        let retrieved_note = MockNote::new(value)\n            .contract_address(CONTRACT_ADDRESS)\n            .owner(OWNER)\n            .randomness(RANDOMNESS)\n            .storage_slot(STORAGE_SLOT)\n            .note_metadata(SettledNoteMetadata::new(note_nonce).into())\n            .build_retrieved_note();\n        let note = retrieved_note.note;\n\n        let note_hash = note.compute_note_hash(OWNER, STORAGE_SLOT, RANDOMNESS);\n        let unique_note_hash = compute_unique_note_hash(\n            note_nonce,\n            compute_siloed_note_hash(CONTRACT_ADDRESS, note_hash),\n        );\n        let inner_nullifier = note.compute_nullifier_unconstrained(\n            OWNER,\n            compute_note_hash_for_nullification(retrieved_note),\n        );\n\n        NoteAndData { note, note_nonce, note_hash, unique_note_hash, inner_nullifier }\n    }\n\n    #[test]\n    unconstrained fn single_note() {\n        let note_index_in_tx = 2;\n        let note_and_data = construct_note(VALUE, note_index_in_tx);\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(note_index_in_tx, note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            OWNER,\n            STORAGE_SLOT,\n            RANDOMNESS,\n            MockNote::get_id(),\n            BoundedVec::from_array(note_and_data.note.pack()),\n        );\n\n        assert_eq(discovered_notes.len(), 1);\n        let discovered_note = discovered_notes.get(0);\n\n        assert_eq(discovered_note.note_nonce, note_and_data.note_nonce);\n        assert_eq(discovered_note.note_hash, note_and_data.note_hash);\n        assert_eq(discovered_note.inner_nullifier, note_and_data.inner_nullifier);\n    }\n\n    #[test]\n    unconstrained fn multiple_notes_same_preimage() {\n        let first_note_index_in_tx = 3;\n        let first_note_and_data = construct_note(VALUE, first_note_index_in_tx);\n\n        let second_note_index_in_tx = 5;\n        let second_note_and_data = construct_note(VALUE, second_note_index_in_tx);\n\n        // Both notes have the same preimage (and therefore packed representation), so both should be found in the same\n        // call.\n        assert_eq(first_note_and_data.note, second_note_and_data.note);\n        let packed_note = first_note_and_data.note.pack();\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(first_note_index_in_tx, first_note_and_data.unique_note_hash);\n        unique_note_hashes_in_tx.set(second_note_index_in_tx, second_note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            OWNER,\n            STORAGE_SLOT,\n            RANDOMNESS,\n            MockNote::get_id(),\n            BoundedVec::from_array(packed_note),\n        );\n\n        assert_eq(discovered_notes.len(), 2);\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.note_nonce == first_note_and_data.note_nonce)\n                & (discovered_note.note_hash == first_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == first_note_and_data.inner_nullifier)\n        }));\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.note_nonce == second_note_and_data.note_nonce)\n                & (discovered_note.note_hash == second_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == second_note_and_data.inner_nullifier)\n        }));\n    }\n}\n","path":"/Users/zac/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/messages/discovery/nonce_discovery.nr"},"128":{"source":"use crate::{\n    capsules::CapsuleArray,\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n        processing::{\n            enqueue_note_for_validation, get_pending_partial_notes_completion_logs,\n            log_retrieval_response::LogRetrievalResponse,\n        },\n    },\n    utils::array,\n};\n\nuse protocol_types::{\n    address::AztecAddress,\n    debug_log::debug_log_format,\n    hash::sha256_to_field,\n    traits::{Deserialize, FromField, Serialize},\n};\n\n/// [ owner, storage slot, randomness, note_completion_log_tag ]\nglobal PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 4;\nglobal PARTIAL_NOTE_PRIVATE_MSG_CONTENT_OWNER_INDEX: u32 = 0;\nglobal PARTIAL_NOTE_PRIVATE_MSG_CONTENT_STORAGE_SLOT_INDEX: u32 = 1;\nglobal PARTIAL_NOTE_PRIVATE_MSG_CONTENT_RANDOMNESS_INDEX: u32 = 2;\nglobal PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NOTE_COMPLETION_LOG_TAG_INDEX: u32 = 3;\n\n/// Partial notes have a maximum packed length of their private fields bound by extra content in their private message\n/// (e.g. the storage slot, note completion log tag, etc.).\npub global MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\n/// The slot in the PXE capsules where we store a `CapsuleArray` of `DeliveredPendingPartialNote`.\npub global DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT\".as_bytes(),\n);\n\n/// A partial note that was delivered but is still pending completion. Contains the information necessary to find the\n/// log that will complete it and lead to a note being discovered and delivered.\n#[derive(Serialize, Deserialize)]\npub(crate) struct DeliveredPendingPartialNote {\n    pub(crate) note_completion_log_tag: Field,\n    pub(crate) owner: AztecAddress,\n    pub(crate) storage_slot: Field,\n    pub(crate) randomness: Field,\n    pub(crate) note_type_id: Field,\n    pub(crate) packed_private_note_content: BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>,\n    pub(crate) recipient: AztecAddress,\n}\n\npub unconstrained fn process_partial_note_private_msg(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    // We store the information of the partial note we found in a persistent capsule in PXE, so that we can later search\n    // for the public log that will complete it.\n    let pending = decode_partial_note_private_msg(msg_metadata, msg_content, recipient);\n\n    CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    )\n        .push(pending);\n}\n\n/// Searches for logs that would result in the completion of pending partial notes, ultimately resulting in the notes\n/// being delivered to PXE if completed.\npub unconstrained fn fetch_and_process_partial_note_completion_logs<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    let pending_partial_notes = CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    );\n\n    debug_log_format(\n        \"{} pending partial notes\",\n        [pending_partial_notes.len() as Field],\n    );\n\n    // Each of the pending partial notes might get completed by a log containing its public values. For performance\n    // reasons, we fetch all of these logs concurrently and then process them one by one, minimizing the amount of time\n    // waiting for the node roundtrip.\n    let maybe_completion_logs =\n        get_pending_partial_notes_completion_logs(contract_address, pending_partial_notes);\n\n    // Each entry in the maybe completion logs array corresponds to the entry in the pending partial notes array at the\n    // same index. This means we can use the same index as we iterate through the responses to get both the partial note\n    // and the log that might complete it.\n    assert_eq(maybe_completion_logs.len(), pending_partial_notes.len());\n\n    maybe_completion_logs.for_each(|i, maybe_log: Option<LogRetrievalResponse>| {\n        // We clear the completion logs as we read them so that the array is empty by the time we next query it.\n        // TODO(#14943): use volatile arrays to avoid having to manually clear this.\n        maybe_completion_logs.remove(i);\n\n        let pending_partial_note = pending_partial_notes.get(i);\n\n        if maybe_log.is_none() {\n            debug_log_format(\n                \"Found no completion logs for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n\n            // Note that we're not removing the pending partial note from the capsule array, so we will continue\n            // searching for this tagged log when performing message discovery in the future until we either find it or\n            // the entry is somehow removed from the array.\n        } else {\n            debug_log_format(\n                \"Completion log found for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n            let log = maybe_log.unwrap();\n\n            // Public fields are assumed to all be placed at the end of the packed representation, so we combine the\n            // private and public packed fields (i.e. the contents of the private message and public log plaintext to get\n            // the complete packed content.\n            let complete_packed_note = array::append(\n                pending_partial_note.packed_private_note_content,\n                log.log_payload,\n            );\n\n            let discovered_notes = attempt_note_nonce_discovery(\n                log.unique_note_hashes_in_tx,\n                log.first_nullifier_in_tx,\n                compute_note_hash_and_nullifier,\n                contract_address,\n                pending_partial_note.owner,\n                pending_partial_note.storage_slot,\n                pending_partial_note.randomness,\n                pending_partial_note.note_type_id,\n                complete_packed_note,\n            );\n\n            // TODO(#11627): is there anything reasonable we can do if we get a log but it doesn't result in a note\n            // being found?\n            if discovered_notes.len() == 0 {\n                panic(\n                    f\"A partial note's completion log did not result in any notes being found - this should never happen\",\n                );\n            }\n\n            debug_log_format(\n                \"Discovered {0} notes for partial note with tag {1}\",\n                [discovered_notes.len() as Field, pending_partial_note.note_completion_log_tag],\n            );\n\n            discovered_notes.for_each(|discovered_note| {\n                enqueue_note_for_validation(\n                    contract_address,\n                    pending_partial_note.owner,\n                    pending_partial_note.storage_slot,\n                    pending_partial_note.randomness,\n                    discovered_note.note_nonce,\n                    complete_packed_note,\n                    discovered_note.note_hash,\n                    discovered_note.inner_nullifier,\n                    log.tx_hash,\n                    pending_partial_note.recipient,\n                );\n            });\n\n            // Because there is only a single log for a given tag, once we've processed the tagged log then we\n            // simply delete the pending work entry, regardless of whether it was actually completed or not.\n            pending_partial_notes.remove(i);\n        }\n    });\n}\n\nfn decode_partial_note_private_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n    recipient: AztecAddress,\n) -> DeliveredPendingPartialNote {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    // The following ensures that the message content contains at least the minimum number of fields required for a\n    // valid partial note private message. (Refer to the description of\n    // PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN for more information about these fields.)\n    assert(\n        msg_content.len() >= PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all partial note private messages must have at least {PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the partial note private message encoding below must be updated as well.\n    std::static_assert(\n        PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 4,\n        \"unexpected value for PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have four fields that are not the partial note's packed representation,\n    // which are the owner, the storage slot, the randomness, and the note completion log tag.\n    let owner = AztecAddress::from_field(msg_content.get(\n        PARTIAL_NOTE_PRIVATE_MSG_CONTENT_OWNER_INDEX,\n    ));\n    let storage_slot = msg_content.get(PARTIAL_NOTE_PRIVATE_MSG_CONTENT_STORAGE_SLOT_INDEX);\n    let randomness = msg_content.get(PARTIAL_NOTE_PRIVATE_MSG_CONTENT_RANDOMNESS_INDEX);\n    let note_completion_log_tag =\n        msg_content.get(PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NOTE_COMPLETION_LOG_TAG_INDEX);\n\n    let packed_private_note_content: BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN> = array::subbvec(\n        msg_content,\n        PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n    );\n\n    DeliveredPendingPartialNote {\n        note_completion_log_tag,\n        owner,\n        storage_slot,\n        randomness,\n        note_type_id,\n        packed_private_note_content,\n        recipient,\n    }\n}\n","path":"/Users/zac/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/messages/discovery/partial_notes.nr"},"129":{"source":"use crate::{\n    event::event_selector::EventSelector,\n    messages::{encoding::MAX_MESSAGE_CONTENT_LEN, processing::enqueue_event_for_validation},\n    utils::array,\n};\nuse protocol_types::{\n    address::AztecAddress, constants::GENERATOR_INDEX__EVENT_COMMITMENT,\n    hash::poseidon2_hash_with_separator_bounded_vec, traits::FromField,\n};\n\n/// The number of fields in a private event message content that are not the event's serialized representation\n/// (1 field for randomness).\nglobal PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN: u32 = 1;\n\n/// The maximum length of the packed representation of an event's contents. This is limited by private log size,\n/// encryption overhead and extra fields in the message (e.g. message type id, randomness, etc.).\npub global MAX_EVENT_SERIALIZED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN;\n\npub unconstrained fn process_private_event_msg(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n    tx_hash: Field,\n) {\n    // In the case of events, the msg metadata is the event selector.\n    let event_type_id = EventSelector::from_field(msg_metadata as Field);\n\n    assert(\n        msg_content.len() > PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN,\n        f\"Invalid private event message: all private event messages must have at least {PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN} fields\",\n    );\n\n    // If PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the private event message encoding below must be updated as well.\n    std::static_assert(\n        PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN == 1,\n        \"unexpected value for PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN\",\n    );\n\n    let serialized_event_with_randomness = msg_content;\n\n    let event_commitment = poseidon2_hash_with_separator_bounded_vec(\n        serialized_event_with_randomness,\n        GENERATOR_INDEX__EVENT_COMMITMENT,\n    );\n\n    // Randomness was injected into the event payload in `emit_event_in_private` but we have already used it\n    // to compute the event commitment, so we can safely discard it now.\n    let serialized_event = array::subbvec(\n        serialized_event_with_randomness,\n        PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN,\n    );\n\n    enqueue_event_for_validation(\n        contract_address,\n        event_type_id,\n        serialized_event,\n        event_commitment,\n        tx_hash,\n        recipient,\n    );\n}\n","path":"/Users/zac/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/messages/discovery/private_events.nr"},"130":{"source":"use crate::{\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n        processing::enqueue_note_for_validation,\n    },\n    utils::array,\n};\nuse protocol_types::{\n    address::AztecAddress, constants::MAX_NOTE_HASHES_PER_TX, debug_log::debug_log_format,\n    traits::FromField,\n};\n\n/// The number of fields in a private note message content that are not the note's packed representation.\n// See the call to `std::static_assert` below to see what's in these fields.\nglobal PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 3;\nglobal PRIVATE_NOTE_MSG_CONTENT_OWNER_INDEX: u32 = 0;\nglobal PRIVATE_NOTE_MSG_CONTENT_STORAGE_SLOT_INDEX: u32 = 1;\nglobal PRIVATE_NOTE_MSG_CONTENT_RANDOMNESS_INDEX: u32 = 2;\n\n/// The maximum length of the packed representation of a note's contents. This is limited by private log size,\n/// encryption overhead and extra fields in the message (e.g. message type id, storage slot, randomness, etc.).\npub global MAX_NOTE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\npub unconstrained fn process_private_note_msg<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    let (note_type_id, owner, storage_slot, randomness, packed_note) =\n        decode_private_note_msg(msg_metadata, msg_content);\n\n    attempt_note_discovery(\n        contract_address,\n        tx_hash,\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        recipient,\n        compute_note_hash_and_nullifier,\n        owner,\n        storage_slot,\n        randomness,\n        note_type_id,\n        packed_note,\n    );\n}\n\n/// Attempts discovery of a note given information about its contents and the transaction in which it is\n/// suspected the note was created.\npub unconstrained fn attempt_note_discovery<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    owner: AztecAddress,\n    storage_slot: Field,\n    randomness: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) {\n    let discovered_notes = attempt_note_nonce_discovery(\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        compute_note_hash_and_nullifier,\n        contract_address,\n        owner,\n        storage_slot,\n        randomness,\n        note_type_id,\n        packed_note,\n    );\n\n    debug_log_format(\n        \"Discovered {0} notes from a private message\",\n        [discovered_notes.len() as Field],\n    );\n\n    discovered_notes.for_each(|discovered_note| {\n        enqueue_note_for_validation(\n            contract_address,\n            owner,\n            storage_slot,\n            randomness,\n            discovered_note.note_nonce,\n            packed_note,\n            discovered_note.note_hash,\n            discovered_note.inner_nullifier,\n            tx_hash,\n            recipient,\n        );\n    });\n}\n\nfn decode_private_note_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) -> (Field, AztecAddress, Field, Field, BoundedVec<Field, MAX_NOTE_PACKED_LEN>) {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        msg_content.len() > PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all private note messages must have at least {PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the private note message encoding below must be updated as well.\n    std::static_assert(\n        PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 3,\n        \"unexpected value for PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have two fields that are not the note's packed representation, which are the owner and the storage slot.\n    let owner = AztecAddress::from_field(msg_content.get(PRIVATE_NOTE_MSG_CONTENT_OWNER_INDEX));\n    let storage_slot = msg_content.get(PRIVATE_NOTE_MSG_CONTENT_STORAGE_SLOT_INDEX);\n    let randomness = msg_content.get(PRIVATE_NOTE_MSG_CONTENT_RANDOMNESS_INDEX);\n    let packed_note = array::subbvec(msg_content, PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN);\n\n    (note_type_id, owner, storage_slot, randomness, packed_note)\n}\n","path":"/Users/zac/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/messages/discovery/private_notes.nr"},"131":{"source":"use crate::messages::{\n    discovery::{\n        ComputeNoteHashAndNullifier, partial_notes::process_partial_note_private_msg,\n        private_events::process_private_event_msg, private_notes::process_private_note_msg,\n    },\n    encoding::{decode_message, MESSAGE_CIPHERTEXT_LEN, MESSAGE_PLAINTEXT_LEN},\n    encryption::{aes128::AES128, message_encryption::MessageEncryption},\n    msg_type::{\n        PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID, PRIVATE_EVENT_MSG_TYPE_ID, PRIVATE_NOTE_MSG_TYPE_ID,\n    },\n    processing::message_context::MessageContext,\n};\n\nuse protocol_types::{address::AztecAddress, debug_log::{debug_log, debug_log_format}};\n\n/// Processes a message that can contain notes, partial notes, or events.\n///\n/// Notes result in nonce discovery being performed prior to delivery, which requires knowledge of the transaction hash\n/// in which the notes would've been created (typically the same transaction in which the log was emitted), along with\n/// the list of unique note hashes in said transaction and the `compute_note_hash_and_nullifier` function. Once\n/// discovered, the notes are enqueued for validation.\n///\n/// Partial notes result in a pending partial note entry being stored in a PXE capsule, which will later be retrieved to\n/// search for the note's completion public log.\n///\n/// Events are processed by computing an event commitment from the serialized event data and its randomness field, then\n/// enqueueing the event data and commitment for validation.\npub unconstrained fn process_message_ciphertext<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    message_ciphertext: BoundedVec<Field, MESSAGE_CIPHERTEXT_LEN>,\n    message_context: MessageContext,\n) {\n    let message_plaintext_option = AES128::decrypt(message_ciphertext, message_context.recipient);\n\n    if message_plaintext_option.is_some() {\n        process_message_plaintext(\n            contract_address,\n            compute_note_hash_and_nullifier,\n            message_plaintext_option.unwrap(),\n            message_context,\n        );\n    } else {\n        debug_log_format(\n            \"Found invalid message from tx {0}, ignoring\",\n            [message_context.tx_hash],\n        );\n    }\n}\n\npub unconstrained fn process_message_plaintext<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    message_plaintext: BoundedVec<Field, MESSAGE_PLAINTEXT_LEN>,\n    message_context: MessageContext,\n) {\n    // The first thing to do after decrypting the message is to determine what type of message we're processing. We\n    // have 3 message types: private notes, partial notes and events.\n\n    // We decode the message to obtain the message type id, metadata and content.\n    let (msg_type_id, msg_metadata, msg_content) = decode_message(message_plaintext);\n\n    if msg_type_id == PRIVATE_NOTE_MSG_TYPE_ID {\n        debug_log(\"Processing private note msg\");\n\n        process_private_note_msg(\n            contract_address,\n            message_context.tx_hash,\n            message_context.unique_note_hashes_in_tx,\n            message_context.first_nullifier_in_tx,\n            message_context.recipient,\n            compute_note_hash_and_nullifier,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID {\n        debug_log(\"Processing partial note private msg\");\n\n        process_partial_note_private_msg(\n            contract_address,\n            message_context.recipient,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PRIVATE_EVENT_MSG_TYPE_ID {\n        debug_log(\"Processing private event msg\");\n\n        process_private_event_msg(\n            contract_address,\n            message_context.recipient,\n            msg_metadata,\n            msg_content,\n            message_context.tx_hash,\n        );\n    } else {\n        debug_log_format(\"Unknown msg type id {0}\", [msg_type_id as Field]);\n    }\n}\n","path":"/Users/zac/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/messages/discovery/process_message.nr"},"132":{"source":"// TODO(#12750): don't make these values assume we're using AES.\nuse crate::utils::array;\nuse protocol_types::constants::PRIVATE_LOG_CIPHERTEXT_LEN;\n\n// We reassign to the constant here to communicate the distinction between a log and a message. In Aztec.nr, unlike in\n// protocol circuits, we have a concept of a message that can be emitted either as a private log or as an offchain\n// message. Message is a piece of data that is to be eventually delivered to a contract via the `process_message(...)`\n// utility function function that is injected by the #[aztec] macro.\n// Note: PRIVATE_LOG_CIPHERTEXT_LEN is an amount of fields,\n// so MESSAGE_CIPHERTEXT_LEN is the size of the message in fields.\npub global MESSAGE_CIPHERTEXT_LEN: u32 = PRIVATE_LOG_CIPHERTEXT_LEN;\n\n// TODO(#12750): The global variables below should not be here as they are AES128 specific.\n// ciphertext_length (2) + 14 bytes pkcs#7 AES padding.\npub(crate) global HEADER_CIPHERTEXT_SIZE_IN_BYTES: u32 = 16;\n\npub global EPH_PK_X_SIZE_IN_FIELDS: u32 = 1;\npub global EPH_PK_SIGN_BYTE_SIZE_IN_BYTES: u32 = 1;\n\n// (17 - 1) * 31 - 16 - 1 = 479\n// Note: We multiply by 31 because ciphertext bytes are stored in fields using bytes_to_fields, which packs 31 bytes per\n// field (since a Field is ~254 bits and can safely store 31 whole bytes).\nglobal MESSAGE_PLAINTEXT_SIZE_IN_BYTES: u32 = (MESSAGE_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS)\n    * 31\n    - HEADER_CIPHERTEXT_SIZE_IN_BYTES\n    - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES;\n// The plaintext bytes represent Field values that were originally serialized using fields_to_bytes, which converts each\n// Field to 32 bytes. To convert the plaintext bytes back to fields, we divide by 32.\n// 479 / 32 = 14\npub global MESSAGE_PLAINTEXT_LEN: u32 = MESSAGE_PLAINTEXT_SIZE_IN_BYTES / 32;\n\npub global MESSAGE_EXPANDED_METADATA_LEN: u32 = 1;\n\n// The standard message layout is composed of:\n//  - an initial field called the 'expanded metadata'\n//  - an arbitrary number of fields following that called the 'message content'\n//\n// ```\n// message: [ msg_expanded_metadata, ...msg_content ]\n// ```\n//\n// The expanded metadata itself is interpreted as a u128, of which:\n//  - the upper 64 bits are the message type id\n//  - the lower 64 bits are called the 'message metadata'\n//\n// ```\n// msg_expanded_metadata: [  msg_type_id    |  msg_metadata  ]\n//                        <---  64 bits --->|<--- 64 bits --->\n// ```\n//\n// The meaning of the message metadata and message content depend on the value of the message type id. Note that there\n// is nothing special about the message metadata, it _can_ be considered part of the content. It just has a different\n// name to make it distinct from the message content given that it is not a full field.\n\n/// The maximum length of a message's content, i.e. not including the expanded message metadata.\npub global MAX_MESSAGE_CONTENT_LEN: u32 = MESSAGE_PLAINTEXT_LEN - MESSAGE_EXPANDED_METADATA_LEN;\n\n/// Encodes a message following aztec-nr's standard message encoding. This message can later be decoded with\n/// `decode_message` to retrieve the original values.\n///\n/// - The `msg_type` is an identifier that groups types of messages that are all processed the same way, e.g. private\n/// notes or events. Possible values are defined in `aztec::messages::msg_type`.\n/// - The `msg_metadata` and `msg_content` are the values stored in the message, whose meaning depends on the\n///  `msg_type`. The only special thing about `msg_metadata` that separates it from `msg_content` is that it is a u64\n/// instead of a full Field (due to details of how messages are encoded), allowing applications that can fit values into\n/// this smaller variable to achieve higher data efficiency.\npub fn encode_message<let N: u32>(\n    msg_type: u64,\n    msg_metadata: u64,\n    msg_content: [Field; N],\n) -> [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] {\n    std::static_assert(\n        msg_content.len() <= MAX_MESSAGE_CONTENT_LEN,\n        \"Invalid message content: it must have a length of at most MAX_MESSAGE_CONTENT_LEN\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n    let mut message: [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] = std::mem::zeroed();\n\n    message[0] = to_expanded_metadata(msg_type, msg_metadata);\n    for i in 0..msg_content.len() {\n        message[MESSAGE_EXPANDED_METADATA_LEN + i] = msg_content[i];\n    }\n\n    message\n}\n\n/// Decodes a standard aztec-nr message, i.e. one created via `encode_message`, returning the original encoded values.\n///\n/// Note that `encode_message` returns a fixed size array while this function takes a `BoundedVec`: this is because\n/// prior to decoding the message type is unknown, and consequentially not known at compile time. If working with\n/// fixed-size messages, consider using `BoundedVec::from_array` to convert them.\npub unconstrained fn decode_message(\n    message: BoundedVec<Field, MESSAGE_PLAINTEXT_LEN>,\n) -> (u64, u64, BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>) {\n    assert(\n        message.len() >= MESSAGE_EXPANDED_METADATA_LEN,\n        f\"Invalid message: it must have at least {MESSAGE_EXPANDED_METADATA_LEN} fields\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n\n    let msg_expanded_metadata = message.get(0);\n    let (msg_type_id, msg_metadata) = from_expanded_metadata(msg_expanded_metadata);\n    let msg_content = array::subbvec(message, MESSAGE_EXPANDED_METADATA_LEN);\n\n    (msg_type_id, msg_metadata, msg_content)\n}\n\nglobal U64_SHIFT_MULTIPLIER: Field = 2.pow_32(64);\n\nfn to_expanded_metadata(msg_type: u64, msg_metadata: u64) -> Field {\n    // We use multiplication instead of bit shifting operations to shift the type bits as bit shift operations are\n    // expensive in circuits.\n    let type_field: Field = (msg_type as Field) * U64_SHIFT_MULTIPLIER;\n    let msg_metadata_field = msg_metadata as Field;\n\n    type_field + msg_metadata_field\n}\n\nfn from_expanded_metadata(input: Field) -> (u64, u64) {\n    input.assert_max_bit_size::<128>();\n    let msg_metadata = (input as u64);\n    let msg_type = ((input - (msg_metadata as Field)) / U64_SHIFT_MULTIPLIER) as u64;\n    // Use division instead of bit shift since bit shifts are expensive in circuits\n    (msg_type, msg_metadata)\n}\n\nmod tests {\n    use crate::utils::array::subarray::subarray;\n    use super::{\n        decode_message, encode_message, from_expanded_metadata, MAX_MESSAGE_CONTENT_LEN,\n        to_expanded_metadata,\n    };\n\n    global U64_MAX: u64 = (2.pow_32(64) - 1) as u64;\n    global U128_MAX: Field = (2.pow_32(128) - 1);\n\n    #[test]\n    unconstrained fn encode_decode_empty_message(msg_type: u64, msg_metadata: u64) {\n        let encoded = encode_message(msg_type, msg_metadata, []);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_short_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN / 2],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_full_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn to_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let packed = to_expanded_metadata(U64_MAX, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let packed = to_expanded_metadata(U64_MAX, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let packed = to_expanded_metadata(0, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let packed = to_expanded_metadata(0, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn from_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let input = U128_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let input = (U128_MAX - U64_MAX as Field);\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let input = U64_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let input = 0;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn to_from_expanded_metadata(original_msg_type: u64, original_msg_metadata: u64) {\n        let packed = to_expanded_metadata(original_msg_type, original_msg_metadata);\n        let (unpacked_msg_type, unpacked_msg_metadata) = from_expanded_metadata(packed);\n\n        assert_eq(original_msg_type, unpacked_msg_type);\n        assert_eq(original_msg_metadata, unpacked_msg_metadata);\n    }\n}\n","path":"/Users/zac/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/messages/encoding.nr"},"133":{"source":"use dep::protocol_types::{\n    address::AztecAddress,\n    constants::{GENERATOR_INDEX__SYMMETRIC_KEY, GENERATOR_INDEX__SYMMETRIC_KEY_2},\n    hash::poseidon2_hash_with_separator,\n    point::Point,\n    public_keys::AddressPoint,\n};\n\nuse crate::{\n    keys::{ecdh_shared_secret::derive_ecdh_shared_secret, ephemeral::generate_ephemeral_key_pair},\n    messages::{\n        encoding::{\n            EPH_PK_SIGN_BYTE_SIZE_IN_BYTES, EPH_PK_X_SIZE_IN_FIELDS,\n            HEADER_CIPHERTEXT_SIZE_IN_BYTES, MESSAGE_CIPHERTEXT_LEN, MESSAGE_PLAINTEXT_LEN,\n        },\n        encryption::message_encryption::MessageEncryption,\n        logs::arithmetic_generics_utils::{\n            get_arr_of_size__message_bytes__from_PT,\n            get_arr_of_size__message_bytes_padding__from_PT,\n        },\n    },\n    oracle::{\n        aes128_decrypt::aes128_decrypt_oracle, random::random, shared_secret::get_shared_secret,\n    },\n    utils::{\n        array,\n        conversion::{\n            bytes_to_fields::{bytes_from_fields, bytes_to_fields},\n            fields_to_bytes::{fields_from_bytes, fields_to_bytes},\n        },\n        point::{get_sign_of_point, point_from_x_coord_and_sign},\n        random::get_random_bytes,\n    },\n};\n\nuse std::aes128::aes128_encrypt;\n\n/**\n * Computes N close-to-uniformly-random 256 bits from a given ECDH shared_secret.\n *\n * NEVER re-use the same iv and sym_key.\n * DO NOT call this function more than once with the same shared_secret.\n *\n * This function is only known to be safe if shared_secret is computed by combining a \n * random ephemeral key with an address point. See big comment within the body of the function.\n * See big comment within the body of the function.\n */\nfn extract_many_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2_unsafe<let N: u32>(\n    shared_secret: Point,\n) -> [[u8; 32]; N] {\n    /*\n     * Unsafe because of https://eprint.iacr.org/2010/264.pdf Page 13, Lemma 2 (and the * two paragraphs below it).\n     *\n     * If you call this function, you need to be careful and aware of how the arg\n     * `shared_secret` has been derived.\n     *\n     * The paper says that the way you derive aes keys and IVs should be fine with poseidon2\n     * (modelled as a RO), as long as you _don't_ use Poseidon2 as a PRG to generate the * two exponents x & y which multiply to the shared secret S:\n     *\n     * S = [x*y]*G.\n     *\n     * (Otherwise, you would have to \"key\" poseidon2, i.e. generate a uniformly string K\n     * which can be public and compute Hash(x) as poseidon(K,x)).\n     * In that lemma, k would be 2*254=508, and m would be the number of points on the * grumpkin curve (which is close to r according to the Hasse bound).\n     *\n     * Our shared secret S is [esk * address_sk] * G, and the question is: * Can we compute hash(S) using poseidon2 instead of sha256?\n     *\n     * Well, esk is random and not generated with poseidon2, so that's good.\n     * What about address_sk?\n     * Well, address_sk = poseidon2(stuff) + ivsk, so there was some\n     * discussion about whether address_sk is independent of poseidon2.\n     * Given that ivsk is random and independent of poseidon2, the address_sk is also\n     * independent of poseidon2.\n     *\n     * Tl;dr: we believe it's safe to hash S = [esk * address_sk] * G using poseidon2,\n     * in order to derive a symmetric key.\n     *\n     * If you're calling this function for a differently-derived `shared_secret`, be\n     * careful.\n     *\n     */\n\n    /* The output of this function needs to be 32 random bytes.\n     * A single field won't give us 32 bytes of entropy.\n     * So we compute two \"random\" fields, by poseidon-hashing with two different\n     * generators.\n     * We then extract the last 16 (big endian) bytes of each \"random\" field.\n     * Note: we use to_be_bytes because it's slightly more efficient. But we have to\n     * be careful not to take bytes from the \"big end\", because the \"big\" byte is\n     * not uniformly random over the byte: it only has < 6 bits of randomness, because\n     * it's the big end of a 254-bit field element.\n     */\n\n    let mut all_bytes: [[u8; 32]; N] = std::mem::zeroed();\n    // We restrict N to be < 2^8, because of how we compute the domain separator\n    // from k below (where k <= N must be 8 bits). In practice, it's extremely\n    // unlikely that an app will want to compute >= 256 ciphertexts.\n    std::static_assert(N < 256, \"N too large\");\n    for k in 0..N {\n        // We augment the domain separator with the loop index, so that we can\n        // generate N lots of randomness.\n        let k_shift = (k as u16 << 8);\n        let separator_1 = k_shift + GENERATOR_INDEX__SYMMETRIC_KEY as u16;\n        let separator_2 = k_shift + GENERATOR_INDEX__SYMMETRIC_KEY_2 as u16;\n\n        let rand1: Field =\n            poseidon2_hash_with_separator([shared_secret.x, shared_secret.y], separator_1);\n        let rand2: Field =\n            poseidon2_hash_with_separator([shared_secret.x, shared_secret.y], separator_2);\n\n        let rand1_bytes: [u8; 32] = rand1.to_be_bytes();\n        let rand2_bytes: [u8; 32] = rand2.to_be_bytes();\n\n        let mut bytes: [u8; 32] = [0; 32];\n        for i in 0..16 {\n            // We take bytes from the \"little end\" of the be-bytes arrays:\n            let j = 32 - i - 1;\n            bytes[i] = rand1_bytes[j];\n            bytes[16 + i] = rand2_bytes[j];\n        }\n\n        all_bytes[k] = bytes;\n    }\n\n    all_bytes\n}\n\nfn derive_aes_symmetric_key_and_iv_from_uniformly_random_256_bits<let N: u32>(\n    many_random_256_bits: [[u8; 32]; N],\n) -> [([u8; 16], [u8; 16]); N] {\n    // Many (sym_key, iv) pairs:\n    let mut many_pairs: [([u8; 16], [u8; 16]); N] = std::mem::zeroed();\n    for k in 0..N {\n        let random_256_bits = many_random_256_bits[k];\n        let mut sym_key = [0; 16];\n        let mut iv = [0; 16];\n        for i in 0..16 {\n            sym_key[i] = random_256_bits[i];\n            iv[i] = random_256_bits[i + 16];\n        }\n        many_pairs[k] = (sym_key, iv);\n    }\n\n    many_pairs\n}\n\npub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2_unsafe<let N: u32>(\n    shared_secret: Point,\n) -> [([u8; 16], [u8; 16]); N] {\n    let many_random_256_bits: [[u8; 32]; N] = extract_many_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2_unsafe(\n        shared_secret,\n    );\n\n    derive_aes_symmetric_key_and_iv_from_uniformly_random_256_bits(many_random_256_bits)\n}\n\npub struct AES128 {}\n\nimpl MessageEncryption for AES128 {\n    fn encrypt<let PlaintextLen: u32>(\n        plaintext: [Field; PlaintextLen],\n        recipient: AztecAddress,\n    ) -> [Field; MESSAGE_CIPHERTEXT_LEN] {\n        // AES 128 operates on bytes, not fields, so we need to convert the fields to bytes.\n        // (This process is then reversed when processing the message in `do_process_message`)\n        let plaintext_bytes = fields_to_bytes(plaintext);\n\n        // *****************************************************************************\n        // Compute the shared secret\n        // *****************************************************************************\n\n        let (eph_sk, eph_pk) = generate_ephemeral_key_pair();\n\n        let eph_pk_sign_byte: u8 = get_sign_of_point(eph_pk) as u8;\n\n        // (not to be confused with the tagging shared secret)\n        // TODO (#17158): Currently we unwrap the Option returned by derive_ecdh_shared_secret.\n        // We need to handle the case where the ephemeral public key is invalid to prevent potential DoS vectors.\n        let ciphertext_shared_secret = derive_ecdh_shared_secret(\n            eph_sk,\n            recipient\n                .to_address_point()\n                .unwrap_or(\n                    // Safety: if the recipient is an invalid address, then it is not possible to encrypt a message for\n                    // them because we cannot establish a shared secret. This is never expected to occur during normal\n                    // operation. However, it is technically possible for us to receive an invalid address, and we must\n                    // therefore handle it.\n                    // We could simply fail, but that'd introduce a potential security issue in which an attacker forces\n                    // a contract to encrypt a message for an invalid address, resulting in an impossible transaction -\n                    // this is sometimes called a 'king of the hill' attack.\n                    // We choose instead to not fail and encrypt the plaintext regardless using the shared secret that\n                    // results from a random valid address. The sender is free to choose this address and hence shared\n                    // secret, but this has no security implications as they already know not only the full plaintext\n                    // but also the ephemeral private key anyway.\n                    unsafe { random_address_point() },\n                )\n                .inner,\n        );\n        // TODO: also use this shared secret for deriving note randomness.\n\n        // *****************************************************************************\n        // Convert the plaintext into whatever format the encryption function expects\n        // *****************************************************************************\n\n        // Already done for this strategy: AES expects bytes.\n\n        // *****************************************************************************\n        // Encrypt the plaintext\n        // *****************************************************************************\n\n        // It is safe to call the `unsafe` function here, because we know the `shared_secret`\n        // was derived using an AztecAddress (the recipient). See the block comment\n        // at the start of this unsafe target function for more info.\n        let pairs = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2_unsafe::<2>(\n            ciphertext_shared_secret,\n        );\n        let (body_sym_key, body_iv) = pairs[0];\n        let (header_sym_key, header_iv) = pairs[1];\n\n        let ciphertext_bytes = aes128_encrypt(plaintext_bytes, body_iv, body_sym_key);\n\n        // |full_pt| = |pt_length| + |pt|\n        // |pt_aes_padding| = 16 - (|full_pt| % 16)\n        // or... since a % b is the same as a - b * (a // b) (integer division), so:\n        // |pt_aes_padding| = 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        // |ct| = |full_pt| + |pt_aes_padding|\n        //      = |full_pt| + 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        //      = 16 + 16 * (|full_pt| // 16)\n        //      = 16 * (1 + |full_pt| // 16)\n        std::static_assert(\n            ciphertext_bytes.len() == 16 * (1 + (PlaintextLen * 32) / 16),\n            \"unexpected ciphertext length\",\n        );\n\n        // *****************************************************************************\n        // Compute the header ciphertext\n        // *****************************************************************************\n\n        // Header contains only the length of the ciphertext stored in 2 bytes.\n        let mut header_plaintext: [u8; 2] = [0 as u8; 2];\n        let ciphertext_bytes_length = ciphertext_bytes.len();\n        header_plaintext[0] = (ciphertext_bytes_length >> 8) as u8;\n        header_plaintext[1] = ciphertext_bytes_length as u8;\n\n        // Note: the aes128_encrypt builtin fn automatically appends bytes to the\n        // input, according to pkcs#7; hence why the output `header_ciphertext_bytes` is 16\n        // bytes larger than the input in this case.\n        let header_ciphertext_bytes = aes128_encrypt(header_plaintext, header_iv, header_sym_key);\n        // I recall that converting a slice to an array incurs constraints, so I'll check the length this way instead:\n        std::static_assert(\n            header_ciphertext_bytes.len() == HEADER_CIPHERTEXT_SIZE_IN_BYTES,\n            \"unexpected ciphertext header length\",\n        );\n\n        // *****************************************************************************\n        // Prepend / append more bytes of data to the ciphertext, before converting back\n        // to fields.\n        // *****************************************************************************\n\n        let mut message_bytes_padding_to_mult_31 =\n            get_arr_of_size__message_bytes_padding__from_PT::<PlaintextLen * 32>();\n        // Safety: this randomness won't be constrained to be random. It's in the\n        // interest of the executor of this fn to encrypt with random bytes.\n        message_bytes_padding_to_mult_31 = unsafe { get_random_bytes() };\n\n        let mut message_bytes = get_arr_of_size__message_bytes__from_PT::<PlaintextLen * 32>();\n\n        std::static_assert(\n            message_bytes.len() % 31 == 0,\n            \"Unexpected error: message_bytes.len() should be divisible by 31, by construction.\",\n        );\n\n        message_bytes[0] = eph_pk_sign_byte;\n        let mut offset = 1;\n        for i in 0..header_ciphertext_bytes.len() {\n            message_bytes[offset + i] = header_ciphertext_bytes[i];\n        }\n        offset += header_ciphertext_bytes.len();\n\n        for i in 0..ciphertext_bytes.len() {\n            message_bytes[offset + i] = ciphertext_bytes[i];\n        }\n        offset += ciphertext_bytes.len();\n\n        for i in 0..message_bytes_padding_to_mult_31.len() {\n            message_bytes[offset + i] = message_bytes_padding_to_mult_31[i];\n        }\n        offset += message_bytes_padding_to_mult_31.len();\n\n        // Ideally we would be able to have a static assert where we check that the offset would be such that we've\n        // written to the entire log_bytes array, but we cannot since Noir does not treat the offset as a comptime\n        // value (despite the values that it goes through being known at each stage). We instead check that the\n        // computation used to obtain the offset computes the expected value (which we _can_ do in a static check), and\n        // then add a cheap runtime check to also validate that the offset matches this.\n        std::static_assert(\n            1\n                + header_ciphertext_bytes.len()\n                + ciphertext_bytes.len()\n                + message_bytes_padding_to_mult_31.len()\n                == message_bytes.len(),\n            \"unexpected message length\",\n        );\n        assert(offset == message_bytes.len(), \"unexpected encrypted message length\");\n\n        // *****************************************************************************\n        // Convert bytes back to fields\n        // *****************************************************************************\n\n        // TODO(#12749): As Mike pointed out, we need to make messages produced by different encryption schemes\n        // indistinguishable from each other and for this reason the output here and in the last for-loop of this function\n        // should cover a full field.\n        let message_bytes_as_fields = bytes_to_fields(message_bytes);\n\n        // *****************************************************************************\n        // Prepend / append fields, to create the final message\n        // *****************************************************************************\n\n        let mut ciphertext: [Field; MESSAGE_CIPHERTEXT_LEN] = [0; MESSAGE_CIPHERTEXT_LEN];\n\n        ciphertext[0] = eph_pk.x;\n\n        let mut offset = 1;\n        for i in 0..message_bytes_as_fields.len() {\n            ciphertext[offset + i] = message_bytes_as_fields[i];\n        }\n        offset += message_bytes_as_fields.len();\n\n        for i in offset..MESSAGE_CIPHERTEXT_LEN {\n            // We need to get a random value that fits in 31 bytes to not leak information about the size of the message\n            // (all the \"real\" message fields contain at most 31 bytes because of the way we convert the bytes to fields).\n            // TODO(#12749): Long term, this is not a good solution.\n\n            // Safety: we assume that the sender wants for the message to be private - a malicious one could simply reveal its\n            // contents publicly. It is therefore fine to trust the sender to provide random padding.\n            let field_bytes = unsafe { get_random_bytes::<31>() };\n            ciphertext[i] = Field::from_be_bytes::<31>(field_bytes);\n        }\n\n        ciphertext\n    }\n\n    unconstrained fn decrypt(\n        ciphertext: BoundedVec<Field, MESSAGE_CIPHERTEXT_LEN>,\n        recipient: AztecAddress,\n    ) -> Option<BoundedVec<Field, MESSAGE_PLAINTEXT_LEN>> {\n        let eph_pk_x = ciphertext.get(0);\n\n        let ciphertext_without_eph_pk_x_fields = array::subbvec::<Field, MESSAGE_CIPHERTEXT_LEN, MESSAGE_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS>(\n            ciphertext,\n            EPH_PK_X_SIZE_IN_FIELDS,\n        );\n\n        // Convert the ciphertext represented as fields to a byte representation (its original format)\n        let ciphertext_without_eph_pk_x = bytes_from_fields(ciphertext_without_eph_pk_x_fields);\n\n        // First byte of the ciphertext represents the ephemeral public key sign\n        let eph_pk_sign_bool = ciphertext_without_eph_pk_x.get(0) != 0;\n\n        // With the sign and the x-coordinate of the ephemeral public key, we can reconstruct the point. This may fail\n        // however, as not all x-coordinates are on the curve. In that case, we simply return `Option::none`.\n        point_from_x_coord_and_sign(eph_pk_x, eph_pk_sign_bool).map(|eph_pk| {\n            // Derive shared secret\n            let ciphertext_shared_secret = get_shared_secret(recipient, eph_pk);\n\n            // Derive symmetric keys:\n            let pairs = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2_unsafe::<2>(\n                ciphertext_shared_secret,\n            );\n            let (body_sym_key, body_iv) = pairs[0];\n            let (header_sym_key, header_iv) = pairs[1];\n\n            // Extract the header ciphertext\n            let header_start = EPH_PK_SIGN_BYTE_SIZE_IN_BYTES; // Skip eph_pk_sign byte\n            let header_ciphertext: [u8; HEADER_CIPHERTEXT_SIZE_IN_BYTES] =\n                array::subarray(ciphertext_without_eph_pk_x.storage(), header_start);\n            // We need to convert the array to a BoundedVec because the oracle expects a BoundedVec as it's designed to work\n            // with messages with unknown length at compile time. This would not be necessary here as the header ciphertext length\n            // is fixed. But we do it anyway to not have to have duplicate oracles.\n            let header_ciphertext_bvec =\n                BoundedVec::<u8, HEADER_CIPHERTEXT_SIZE_IN_BYTES>::from_array(header_ciphertext);\n\n            // Decrypt header\n            let header_plaintext =\n                aes128_decrypt_oracle(header_ciphertext_bvec, header_iv, header_sym_key);\n\n            // Extract ciphertext length from header (2 bytes, big-endian)\n            let ciphertext_length =\n                ((header_plaintext.get(0) as u32) << 8) | (header_plaintext.get(1) as u32);\n\n            // Extract and decrypt main ciphertext\n            let ciphertext_start = header_start + HEADER_CIPHERTEXT_SIZE_IN_BYTES;\n            let ciphertext_with_padding: [u8; (MESSAGE_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES] =\n                array::subarray(ciphertext_without_eph_pk_x.storage(), ciphertext_start);\n            let ciphertext: BoundedVec<u8, (MESSAGE_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES> =\n                BoundedVec::from_parts(ciphertext_with_padding, ciphertext_length);\n\n            // Decrypt main ciphertext and return it\n            let plaintext_bytes = aes128_decrypt_oracle(ciphertext, body_iv, body_sym_key);\n\n            // Each field of the original note message was serialized to 32 bytes so we convert the bytes back to fields.\n            fields_from_bytes(plaintext_bytes)\n        })\n    }\n}\n\n/// Produces a random valid address point, i.e. one that is on the curve. This is equivalent to calling\n/// [AztecAddress::to_address_point] on a random valid address.\nunconstrained fn random_address_point() -> AddressPoint {\n    let mut result = std::mem::zeroed();\n\n    loop {\n        // We simply produce random x coordinates until we find one that is on the curve. About half of the x\n        // coordinates fulfill this condition, so this should only take a few iterations at most.\n        let x_coord = random();\n        let point = point_from_x_coord_and_sign(x_coord, true);\n        if point.is_some() {\n            result = AddressPoint { inner: point.unwrap() };\n            break;\n        }\n    }\n\n    result\n}\n\nmod test {\n    use crate::{\n        keys::ecdh_shared_secret::derive_ecdh_shared_secret,\n        messages::{\n            encoding::MESSAGE_PLAINTEXT_LEN, encryption::message_encryption::MessageEncryption,\n        },\n        test::helpers::test_environment::TestEnvironment,\n    };\n    use super::{AES128, random_address_point};\n    use protocol_types::{address::AztecAddress, traits::FromField};\n    use std::{embedded_curve_ops::EmbeddedCurveScalar, test::OracleMock};\n\n    #[test]\n    unconstrained fn encrypt_decrypt_deterministic() {\n        let env = TestEnvironment::new();\n\n        // Message decryption requires oracles that are only available during private execution\n        env.private_context(|_| {\n            let plaintext = [1, 2, 3];\n\n            let recipient = AztecAddress::from_field(\n                0x25afb798ea6d0b8c1618e50fdeafa463059415013d3b7c75d46abf5e242be70c,\n            );\n\n            // Mock random values for deterministic test\n            let eph_sk = 0x1358d15019d4639393d62b97e1588c095957ce74a1c32d6ec7d62fe6705d9538;\n            let _ = OracleMock::mock(\"utilityGetRandomField\").returns(eph_sk).times(1);\n\n            let randomness = 0x0101010101010101010101010101010101010101010101010101010101010101;\n            let _ = OracleMock::mock(\"utilityGetRandomField\").returns(randomness).times(1000000);\n\n            let _ = OracleMock::mock(\"privateGetNextAppTagAsSender\").returns(42);\n\n            // Encrypt the message\n            let encrypted_message = BoundedVec::from_array(AES128::encrypt(plaintext, recipient));\n\n            // Mock shared secret for deterministic test\n            let shared_secret = derive_ecdh_shared_secret(\n                EmbeddedCurveScalar::from_field(eph_sk),\n                recipient.to_address_point().unwrap().inner,\n            );\n\n            let _ = OracleMock::mock(\"utilityGetSharedSecret\").returns(shared_secret);\n\n            // Decrypt the message\n            let decrypted = AES128::decrypt(encrypted_message, recipient).unwrap();\n\n            // The decryption function spits out a BoundedVec because it's designed to work with messages with unknown length\n            // at compile time. For this reason we need to convert the original input to a BoundedVec.\n            let plaintext_bvec = BoundedVec::<Field, MESSAGE_PLAINTEXT_LEN>::from_array(plaintext);\n\n            // Verify decryption matches original plaintext\n            assert_eq(\n                decrypted,\n                plaintext_bvec,\n                \"Decrypted bytes should match original plaintext\",\n            );\n\n            // The following is a workaround of \"struct is never constructed\" Noir compilation error (we only ever use\n            // static methods of the struct).\n            let _ = AES128 {};\n        });\n    }\n\n    #[test]\n    unconstrained fn encrypt_decrypt_random() {\n        // Same as `encrypt_decrypt_deterministic`, except we don't mock any of the oracles and rely on\n        // `TestEnvironment` instead.\n        let mut env = TestEnvironment::new();\n\n        let recipient = env.create_light_account();\n\n        env.private_context(|_| {\n            let plaintext = [1, 2, 3];\n            let ciphertext = AES128::encrypt(plaintext, recipient);\n\n            assert_eq(\n                AES128::decrypt(BoundedVec::from_array(ciphertext), recipient).unwrap(),\n                BoundedVec::from_array(plaintext),\n            );\n        });\n    }\n\n    #[test]\n    unconstrained fn encrypt_to_invalid_address() {\n        // x = 3 is a non-residue for this curve, resulting in an invalid address\n        let invalid_address = AztecAddress { inner: 3 };\n\n        // We just test that we produced some output and did not crash - the result is gibberish as it is encrypted\n        // using a public key for which we do not know the private key.\n        let _ = AES128::encrypt([1, 2, 3, 4], invalid_address);\n    }\n\n    #[test]\n    unconstrained fn random_address_point_produces_valid_points() {\n        // About half of random addresses are invalid, so testing just a couple gives us high confidence that\n        // `random_address_point` is indeed producing valid addresses.\n        for _ in 0..10 {\n            let random_address = AztecAddress { inner: random_address_point().inner.x };\n            assert(random_address.to_address_point().is_some());\n        }\n    }\n\n    #[test]\n    unconstrained fn decrypt_invalid_ephemeral_public_key() {\n        let mut env = TestEnvironment::new();\n\n        let recipient = env.create_light_account();\n\n        env.private_context(|_| {\n            let plaintext = [1, 2, 3, 4];\n            let ciphertext = AES128::encrypt(plaintext, recipient);\n\n            // The first field of the ciphertext is the x-coordinate of the ephemeral public key. We set it to a known\n            // non-residue (3), causing `decrypt` to fail to produce a decryption shared secret.\n            let mut bad_ciphertext = BoundedVec::from_array(ciphertext);\n            bad_ciphertext.set(0, 3);\n\n            assert(AES128::decrypt(bad_ciphertext, recipient).is_none());\n        });\n    }\n}\n","path":"/Users/zac/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/messages/encryption/aes128.nr"},"150":{"source":"pub(crate) mod event_validation_request;\npub mod message_context;\npub(crate) mod note_validation_request;\npub(crate) mod log_retrieval_request;\npub(crate) mod log_retrieval_response;\npub(crate) mod pending_tagged_log;\n\nuse crate::{\n    capsules::CapsuleArray,\n    event::event_selector::EventSelector,\n    messages::{\n        discovery::{\n            partial_notes::DeliveredPendingPartialNote, private_events::MAX_EVENT_SERIALIZED_LEN,\n            private_notes::MAX_NOTE_PACKED_LEN,\n        },\n        processing::{\n            log_retrieval_request::LogRetrievalRequest,\n            log_retrieval_response::LogRetrievalResponse,\n            note_validation_request::NoteValidationRequest, pending_tagged_log::PendingTaggedLog,\n        },\n    },\n    oracle,\n};\nuse event_validation_request::EventValidationRequest;\nuse protocol_types::{address::AztecAddress, hash::sha256_to_field};\n\n// Base slot for the pending tagged log array to which the fetch_tagged_logs oracle inserts found private logs.\nglobal PENDING_TAGGED_LOG_ARRAY_BASE_SLOT: Field =\n    sha256_to_field(\"AZTEC_NR::PENDING_TAGGED_LOG_ARRAY_BASE_SLOT\".as_bytes());\n\nglobal NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\nglobal EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\nglobal LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\nglobal LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\n/// Searches for private logs emitted by `contract_address` that might contain messages for one of the local accounts,\n/// and stores them in a `CapsuleArray` which is then returned.\npub(crate) unconstrained fn get_private_logs(\n    contract_address: AztecAddress,\n) -> CapsuleArray<PendingTaggedLog> {\n    // We will eventually perform log discovery via tagging here, but for now we simply call the `fetchTaggedLogs`\n    // oracle. This makes PXE synchronize tags, download logs and store the pending tagged logs in a capsule array.\n    oracle::message_processing::fetch_tagged_logs(PENDING_TAGGED_LOG_ARRAY_BASE_SLOT);\n\n    CapsuleArray::at(contract_address, PENDING_TAGGED_LOG_ARRAY_BASE_SLOT)\n}\n\n/// Enqueues a note for validation by PXE, so that it becomes aware of a note's existence allowing for later retrieval\n/// via `get_notes` oracle. The note will be scoped to `contract_address`, meaning other contracts will not be able to\n/// access it unless authorized.\n///\n/// In order for the note validation and insertion to occur, `validate_enqueued_notes_and_events` must be later called.\n/// For optimal performance, accumulate as many note validation requests as possible and then validate them all at the\n/// end (which results in PXE minimizing the number of network round-trips).\n///\n/// The `packed_note` is what `getNotes` will later return. PXE indexes notes by `storage_slot`, so this value\n/// is typically used to filter notes that correspond to different state variables. `note_hash` and `nullifier` are\n/// the inner hashes, i.e. the raw hashes returned by `NoteHash::compute_note_hash` and\n/// `NoteHash::compute_nullifier`. PXE will verify that the siloed unique note hash was inserted into the tree\n/// at `tx_hash`, and will store the nullifier to later check for nullification.\n///\n/// `owner` is the address used in note hash and nullifier computation, often requiring knowledge of their\n/// nullifier secret key.\n///\n/// `recipient` is the account to which the note message was delivered (i.e. the address the message was encrypted to).\n/// This determines which PXE account can see the note - other accounts will not be able to access it (e.g. other\n/// accounts will not be able to see one another's token balance notes, even in the same PXE) unless authorized. In most\n/// cases `recipient` equals `owner`, but they can differ in scenarios like delegated discovery.\npub(crate) unconstrained fn enqueue_note_for_validation(\n    contract_address: AztecAddress,\n    owner: AztecAddress,\n    storage_slot: Field,\n    randomness: Field,\n    note_nonce: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) {\n    // We store requests in a `CapsuleArray`, which PXE will later read from and deserialize into its version of the\n    // Noir `NoteValidationRequest`\n    CapsuleArray::at(contract_address, NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT).push(\n        NoteValidationRequest {\n            contract_address,\n            owner,\n            storage_slot,\n            randomness,\n            note_nonce,\n            packed_note,\n            note_hash,\n            nullifier,\n            tx_hash,\n            recipient,\n        },\n    )\n}\n\n/// Enqueues an event for validation by PXE, so that it can be efficiently validated and then inserted into the event\n/// store.\n///\n/// In order for the event validation and insertion to occur, `validate_enqueued_notes_and_events` must be later\n/// called. For optimal performance, accumulate as many event validation requests as possible and then validate them\n/// all at the end (which results in PXE minimizing the number of network round-trips).\npub(crate) unconstrained fn enqueue_event_for_validation(\n    contract_address: AztecAddress,\n    event_type_id: EventSelector,\n    serialized_event: BoundedVec<Field, MAX_EVENT_SERIALIZED_LEN>,\n    event_commitment: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) {\n    // We store requests in a `CapsuleArray`, which PXE will later read from and deserialize into its version of the\n    // Noir `EventValidationRequest`\n    CapsuleArray::at(contract_address, EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT).push(\n        EventValidationRequest {\n            contract_address,\n            event_type_id,\n            serialized_event,\n            event_commitment,\n            tx_hash,\n            recipient,\n        },\n    )\n}\n\n/// Validates all note and event validation requests enqueued via `enqueue_note_for_validation` and\n/// `enqueue_event_for_validation`, inserting them into the note database and event store respectively, making them\n/// queryable via `get_notes` oracle and our TS API (PXE::getPrivateEvents).\n///\n/// This automatically clears both validation request queues, so no further work needs to be done by the caller.\npub(crate) unconstrained fn validate_enqueued_notes_and_events(contract_address: AztecAddress) {\n    oracle::message_processing::validate_enqueued_notes_and_events(\n        contract_address,\n        NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT,\n        EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT,\n    );\n}\n\n/// Efficiently queries the node for logs that result in the completion of all `DeliveredPendingPartialNote`s stored in\n/// a `CapsuleArray` by performing all node communication concurrently. Returns a second `CapsuleArray` with Options for\n/// the responses that correspond to the pending partial notes at the same index.\n///\n/// For example, given an array with pending partial notes `[ p1, p2, p3 ]`, where `p1` and `p3` have corresponding\n/// completion logs but `p2` does not, the returned `CapsuleArray` will have contents\n/// `[some(p1_log), none(), some(p3_log)]`.\npub(crate) unconstrained fn get_pending_partial_notes_completion_logs(\n    contract_address: AztecAddress,\n    pending_partial_notes: CapsuleArray<DeliveredPendingPartialNote>,\n) -> CapsuleArray<Option<LogRetrievalResponse>> {\n    let log_retrieval_requests =\n        CapsuleArray::at(contract_address, LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT);\n\n    // We create a LogRetrievalRequest for each PendingPartialNote in the CapsuleArray. Because we need the indices in\n    // the request array to match the indices in the partial note array, we can't use CapsuleArray::for_each, as that\n    // function has arbitrary iteration order. Instead, we manually iterate the array from the beginning and push into\n    // the requests array, which we expect to be empty.\n    let mut i = 0;\n    let pending_partial_notes_count = pending_partial_notes.len();\n    while i < pending_partial_notes_count {\n        let pending_partial_note = pending_partial_notes.get(i);\n        log_retrieval_requests.push(\n            LogRetrievalRequest {\n                contract_address,\n                unsiloed_tag: pending_partial_note.note_completion_log_tag,\n            },\n        );\n        i += 1;\n    }\n\n    oracle::message_processing::bulk_retrieve_logs(\n        contract_address,\n        LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT,\n        LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT,\n    );\n\n    CapsuleArray::at(contract_address, LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT)\n}\n","path":"/Users/zac/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/messages/processing/mod.nr"},"170":{"source":"use protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// Stores arbitrary information in a per-contract non-volatile database, which can later be retrieved with `load`. If\n/// data was already stored at this slot, it is overwritten.\npub unconstrained fn store<T>(contract_address: AztecAddress, slot: Field, value: T)\nwhere\n    T: Serialize,\n{\n    let serialized = value.serialize();\n    store_oracle(contract_address, slot, serialized);\n}\n\n/// Returns data previously stored via `storeCapsule` in the per-contract non-volatile database. Returns Option::none() if\n/// nothing was stored at the given slot.\npub unconstrained fn load<T>(contract_address: AztecAddress, slot: Field) -> Option<T>\nwhere\n    T: Deserialize,\n{\n    let serialized_option = load_oracle(contract_address, slot, <T as Deserialize>::N);\n    serialized_option.map(|arr| Deserialize::deserialize(arr))\n}\n\n/// Deletes data in the per-contract non-volatile database. Does nothing if no data was present.\npub unconstrained fn delete(contract_address: AztecAddress, slot: Field) {\n    delete_oracle(contract_address, slot);\n}\n\n/// Copies a number of contiguous entries in the per-contract non-volatile database. This allows for efficient data\n/// structures by avoiding repeated calls to `loadCapsule` and `storeCapsule`.\n/// Supports overlapping source and destination regions (which will result in the overlapped source values being\n/// overwritten). All copied slots must exist in the database (i.e. have been stored and not deleted)\npub unconstrained fn copy(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {\n    copy_oracle(contract_address, src_slot, dst_slot, num_entries);\n}\n\n#[oracle(utilityStoreCapsule)]\nunconstrained fn store_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    values: [Field; N],\n) {}\n\n/// We need to pass in `array_len` (the value of N) as a parameter to tell the oracle how many fields the response must\n/// have.\n///\n/// Note that the oracle returns an Option<[Field; N]> because we cannot return an Option<T> directly. That would\n/// require for the oracle resolver to know the shape of T (e.g. if T were a struct of 3 u32 values then the expected\n/// response shape would be 3 single items, whereas it were a struct containing `u32, [Field;10], u32` then the expected\n/// shape would be single, array, single.). Instead, we return the serialization and deserialize in Noir.\n#[oracle(utilityLoadCapsule)]\nunconstrained fn load_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    array_len: u32,\n) -> Option<[Field; N]> {}\n\n#[oracle(utilityDeleteCapsule)]\nunconstrained fn delete_oracle(contract_address: AztecAddress, slot: Field) {}\n\n#[oracle(utilityCopyCapsule)]\nunconstrained fn copy_oracle(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {}\n\nmod test {\n    // These tests are sort of redundant since we already test the oracle implementation directly in TypeScript, but\n    // they are cheap regardless and help ensure both that the TXE implementation works accordingly and that the Noir\n    // oracles are hooked up correctly.\n\n    use crate::{\n        oracle::capsules::{copy, delete, load, store},\n        test::{helpers::test_environment::TestEnvironment, mocks::mock_struct::MockStruct},\n    };\n    use protocol_types::{address::AztecAddress, traits::{FromField, ToField}};\n\n    global SLOT: Field = 1;\n\n    #[test]\n    unconstrained fn stores_and_loads() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let value = MockStruct::new(5, 6);\n            store(contract_address, SLOT, value);\n\n            assert_eq(load(contract_address, SLOT).unwrap(), value);\n        });\n    }\n\n    #[test]\n    unconstrained fn store_overwrites() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let value = MockStruct::new(5, 6);\n            store(contract_address, SLOT, value);\n\n            let new_value = MockStruct::new(7, 8);\n            store(contract_address, SLOT, new_value);\n\n            assert_eq(load(contract_address, SLOT).unwrap(), new_value);\n        });\n    }\n\n    #[test]\n    unconstrained fn loads_empty_slot() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n            assert_eq(loaded_value, Option::none());\n        });\n    }\n\n    #[test]\n    unconstrained fn deletes_stored_value() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let value = MockStruct::new(5, 6);\n            store(contract_address, SLOT, value);\n            delete(contract_address, SLOT);\n\n            let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n            assert_eq(loaded_value, Option::none());\n        });\n    }\n\n    #[test]\n    unconstrained fn deletes_empty_slot() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            delete(contract_address, SLOT);\n            let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n            assert_eq(loaded_value, Option::none());\n        });\n    }\n\n    #[test]\n    unconstrained fn copies_non_overlapping_values() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let src = 5;\n\n            let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n            store(contract_address, src, values[0]);\n            store(contract_address, src + 1, values[1]);\n            store(contract_address, src + 2, values[2]);\n\n            let dst = 10;\n            copy(contract_address, src, dst, 3);\n\n            assert_eq(load(contract_address, dst).unwrap(), values[0]);\n            assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n            assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n        });\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_src_ahead() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let src = 1;\n\n            let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n            store(contract_address, src, values[0]);\n            store(contract_address, src + 1, values[1]);\n            store(contract_address, src + 2, values[2]);\n\n            let dst = 2;\n            copy(contract_address, src, dst, 3);\n\n            assert_eq(load(contract_address, dst).unwrap(), values[0]);\n            assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n            assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n            // src[1] and src[2] should have been overwritten since they are also dst[0] and dst[1]\n            assert_eq(load(contract_address, src).unwrap(), values[0]); // src[0] (unchanged)\n            assert_eq(load(contract_address, src + 1).unwrap(), values[0]); // dst[0]\n            assert_eq(load(contract_address, src + 2).unwrap(), values[1]); // dst[1]\n        });\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_dst_ahead() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let src = 2;\n\n            let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n            store(contract_address, src, values[0]);\n            store(contract_address, src + 1, values[1]);\n            store(contract_address, src + 2, values[2]);\n\n            let dst = 1;\n            copy(contract_address, src, dst, 3);\n\n            assert_eq(load(contract_address, dst).unwrap(), values[0]);\n            assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n            assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n            // src[0] and src[1] should have been overwritten since they are also dst[1] and dst[2]\n            assert_eq(load(contract_address, src).unwrap(), values[1]); // dst[1]\n            assert_eq(load(contract_address, src + 1).unwrap(), values[2]); // dst[2]\n            assert_eq(load(contract_address, src + 2).unwrap(), values[2]); // src[2] (unchanged)\n        });\n    }\n\n    #[test(should_fail_with = \"copy empty slot\")]\n    unconstrained fn cannot_copy_empty_values() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            copy(contract_address, SLOT, SLOT, 1);\n        });\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_store_other_contract() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n            let value = MockStruct::new(5, 6);\n            store(other_contract_address, SLOT, value);\n        });\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_load_other_contract() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n            let _: Option<MockStruct> = load(other_contract_address, SLOT);\n        });\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_delete_other_contract() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n            delete(other_contract_address, SLOT);\n        });\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_copy_other_contract() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n            copy(other_contract_address, SLOT, SLOT, 0);\n        });\n    }\n}\n","path":"/Users/zac/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/oracle/capsules.nr"},"172":{"source":"use crate::context::utility_context::UtilityContext;\n\n#[oracle(utilityGetUtilityContext)]\nunconstrained fn get_utility_context_oracle() -> UtilityContext {}\n\n/// Returns a utility context built from the global variables of anchor block and the contract address of the function\n/// being executed.\npub unconstrained fn get_utility_context() -> UtilityContext {\n    get_utility_context_oracle()\n}\n","path":"/Users/zac/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/oracle/execution.nr"},"174":{"source":"use protocol_types::{\n    address::AztecAddress, contract_class_id::ContractClassId, contract_instance::ContractInstance,\n    traits::FromField,\n};\n\n// NOTE: this is for use in private only\n#[oracle(utilityGetContractInstance)]\nunconstrained fn get_contract_instance_oracle(_address: AztecAddress) -> ContractInstance {}\n\n// NOTE: this is for use in private only\nunconstrained fn get_contract_instance_internal(address: AztecAddress) -> ContractInstance {\n    get_contract_instance_oracle(address)\n}\n\n// NOTE: this is for use in private only\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    // Safety: The to_address function combines all values in the instance object to produce an address,\n    // so by checking that we get the expected address we validate the entire struct.\n    let instance = unsafe { get_contract_instance_internal(address) };\n    assert_eq(instance.to_address(), address);\n\n    instance\n}\n\nstruct GetContractInstanceResult {\n    exists: bool,\n    member: Field,\n}\n\n// These oracles each return a ContractInstance member\n// plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstanceDeployer)]\nunconstrained fn get_contract_instance_deployer_oracle_avm(\n    _address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {}\n#[oracle(avmOpcodeGetContractInstanceClassId)]\nunconstrained fn get_contract_instance_class_id_oracle_avm(\n    _address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {}\n#[oracle(avmOpcodeGetContractInstanceInitializationHash)]\nunconstrained fn get_contract_instance_initialization_hash_oracle_avm(\n    _address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {}\n\nunconstrained fn get_contract_instance_deployer_internal_avm(\n    address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {\n    get_contract_instance_deployer_oracle_avm(address)\n}\nunconstrained fn get_contract_instance_class_id_internal_avm(\n    address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {\n    get_contract_instance_class_id_oracle_avm(address)\n}\nunconstrained fn get_contract_instance_initialization_hash_internal_avm(\n    address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {\n    get_contract_instance_initialization_hash_oracle_avm(address)\n}\n\npub fn get_contract_instance_deployer_avm(address: AztecAddress) -> Option<AztecAddress> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let GetContractInstanceResult { exists, member } =\n        unsafe { get_contract_instance_deployer_internal_avm(address)[0] };\n    if exists {\n        Option::some(AztecAddress::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_class_id_avm(address: AztecAddress) -> Option<ContractClassId> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let GetContractInstanceResult { exists, member } =\n        unsafe { get_contract_instance_class_id_internal_avm(address)[0] };\n    if exists {\n        Option::some(ContractClassId::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_initialization_hash_avm(address: AztecAddress) -> Option<Field> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let GetContractInstanceResult { exists, member } =\n        unsafe { get_contract_instance_initialization_hash_internal_avm(address)[0] };\n    if exists {\n        Option::some(member)\n    } else {\n        Option::none()\n    }\n}\n","path":"/Users/zac/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/oracle/get_contract_instance.nr"},"182":{"source":"use protocol_types::address::AztecAddress;\n\n/// Finds new private logs that may have been sent to all registered accounts in PXE in the current contract and makes\n/// them available for later processing in Noir by storing them in a capsule array.\npub unconstrained fn fetch_tagged_logs(pending_tagged_log_array_base_slot: Field) {\n    fetch_tagged_logs_oracle(pending_tagged_log_array_base_slot);\n}\n\n#[oracle(utilityFetchTaggedLogs)]\nunconstrained fn fetch_tagged_logs_oracle(pending_tagged_log_array_base_slot: Field) {}\n\n// This must be a single oracle and not one for notes and one for events because the entire point is to validate\n// all notes and events in one go, minimizing node round-trips.\npub(crate) unconstrained fn validate_enqueued_notes_and_events(\n    contract_address: AztecAddress,\n    note_validation_requests_array_base_slot: Field,\n    event_validation_requests_array_base_slot: Field,\n) {\n    validate_enqueued_notes_and_events_oracle(\n        contract_address,\n        note_validation_requests_array_base_slot,\n        event_validation_requests_array_base_slot,\n    );\n}\n\n#[oracle(utilityValidateEnqueuedNotesAndEvents)]\nunconstrained fn validate_enqueued_notes_and_events_oracle(\n    contract_address: AztecAddress,\n    note_validation_requests_array_base_slot: Field,\n    event_validation_requests_array_base_slot: Field,\n) {}\n\npub(crate) unconstrained fn bulk_retrieve_logs(\n    contract_address: AztecAddress,\n    log_retrieval_requests_array_base_slot: Field,\n    log_retrieval_responses_array_base_slot: Field,\n) {\n    bulk_retrieve_logs_oracle(\n        contract_address,\n        log_retrieval_requests_array_base_slot,\n        log_retrieval_responses_array_base_slot,\n    );\n}\n\n#[oracle(utilityBulkRetrieveLogs)]\nunconstrained fn bulk_retrieve_logs_oracle(\n    contract_address: AztecAddress,\n    log_retrieval_requests_array_base_slot: Field,\n    log_retrieval_responses_array_base_slot: Field,\n) {}\n","path":"/Users/zac/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/oracle/message_processing.nr"},"187":{"source":"use protocol_types::{address::aztec_address::AztecAddress, point::Point};\n\n// TODO(#12656): return an app-siloed secret + document this\n#[oracle(utilityGetSharedSecret)]\nunconstrained fn get_shared_secret_oracle(address: AztecAddress, ephPk: Point) -> Point {}\n\n/// Returns an app-siloed shared secret between `address` and someone who knows the secret key behind an\n/// ephemeral public key `ephPk`. The app-siloing means that contracts cannot retrieve secrets that belong to\n/// other contracts, and therefore cannot e.g. decrypt their messages. This is an important security consideration\n/// given that both the `address` and `ephPk` are public information.\n///\n/// The shared secret `S` is computed as:\n/// `let S =  (ivsk + h) * ephPk`\n/// where `ivsk + h` is the 'preaddress' i.e. the preimage of the address, also called the address secret.\n/// TODO(#12656): app-silo this secret\npub unconstrained fn get_shared_secret(address: AztecAddress, ephPk: Point) -> Point {\n    get_shared_secret_oracle(address, ephPk)\n}\n","path":"/Users/zac/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/oracle/shared_secret.nr"},"188":{"source":"use dep::protocol_types::{address::AztecAddress, traits::{Packable, ToField}};\n\n#[oracle(utilityStorageRead)]\nunconstrained fn storage_read_oracle<let N: u32>(\n    address: Field,\n    storage_slot: Field,\n    block_number: u32,\n    length: u32,\n) -> [Field; N] {}\n\npub unconstrained fn raw_storage_read<let N: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32,\n) -> [Field; N] {\n    storage_read_oracle(address.to_field(), storage_slot, block_number, N)\n}\n\npub unconstrained fn storage_read<T>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32,\n) -> T\nwhere\n    T: Packable,\n{\n    T::unpack(raw_storage_read(address, storage_slot, block_number))\n}\n\nmod tests {\n    use crate::oracle::storage::{raw_storage_read, storage_read};\n    use dep::protocol_types::{address::AztecAddress, traits::{FromField, Packable}};\n\n    use crate::test::mocks::mock_struct::MockStruct;\n    use std::test::OracleMock;\n\n    global address: AztecAddress = AztecAddress::from_field(29);\n    global slot: Field = 7;\n    global block_number: u32 = 17;\n\n    #[test]\n    unconstrained fn test_raw_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"utilityStorageRead\").returns(written.pack());\n\n        let read: [Field; 2] = raw_storage_read(address, slot, block_number);\n        assert_eq(read[0], 13);\n        assert_eq(read[1], 42);\n    }\n\n    #[test]\n    unconstrained fn test_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"utilityStorageRead\").returns(written.pack());\n\n        let read: MockStruct = storage_read(address, slot, block_number);\n        assert_eq(read.a, 13);\n        assert_eq(read.b, 42);\n    }\n}\n","path":"/Users/zac/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/oracle/storage.nr"},"189":{"source":"/// The ORACLE_VERSION constant is used to check that the oracle interface is in sync between PXE and Aztec.nr. We need\n/// to version the oracle interface to ensure that developers get a reasonable error message if they use incompatible\n/// versions of Aztec.nr and PXE. The TypeScript counterpart is in `oracle_version.ts`.\n///\n/// @dev Whenever a contract function or Noir test is run, the `utilityAssertCompatibleOracleVersion` oracle is called and\n/// if the oracle version is incompatible an error is thrown.\npub global ORACLE_VERSION: Field = 5;\n\n/// Asserts that the version of the oracle is compatible with the version expected by the contract.\npub fn assert_compatible_oracle_version() {\n    // Safety: This oracle call returns nothing: we only call it to check Aztec.nr and Oracle interface versions are\n    // compatible. It is therefore always safe to call.\n    unsafe {\n        assert_compatible_oracle_version_wrapper();\n    }\n}\n\nunconstrained fn assert_compatible_oracle_version_wrapper() {\n    assert_compatible_oracle_version_oracle(ORACLE_VERSION);\n}\n\n#[oracle(utilityAssertCompatibleOracleVersion)]\nunconstrained fn assert_compatible_oracle_version_oracle(version: Field) {}\n\nmod test {\n    use super::{assert_compatible_oracle_version_oracle, ORACLE_VERSION};\n\n    #[test]\n    unconstrained fn compatible_oracle_version() {\n        assert_compatible_oracle_version_oracle(ORACLE_VERSION);\n    }\n\n    #[test(should_fail_with = \"Incompatible oracle version. TXE is using version\")]\n    unconstrained fn incompatible_oracle_version() {\n        let arbitrary_incorrect_version = 318183437;\n        assert_compatible_oracle_version_oracle(arbitrary_incorrect_version);\n    }\n}\n","path":"/Users/zac/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/oracle/version.nr"},"193":{"source":"use crate::state_vars::state_variable::StateVariable;\nuse dep::protocol_types::{storage::map::derive_storage_slot_in_map, traits::ToField};\n\n/// Map\n///\n/// A key-value storage container that maps keys to state variables, similar\n/// to Solidity mappings.\n///\n/// `Map` enables you to associate keys (like addresses or other identifiers)\n/// with state variables in your Aztec smart contract. This is conceptually\n/// similar to Solidity's `mapping(K => V)` syntax, where you can store and\n/// retrieve values by their associated keys.\n///\n/// You can declare a state variable contained within a Map in your contract's\n/// #[storage] struct.\n///\n/// For example, you might use\n/// `Map<AztecAddress, PublicMutable<FieldNote, Context>, Context>` to track\n/// token balances for different users, similar to how you'd use\n/// `mapping(address => uint256)` in Solidity.\n///\n/// > Aside: the verbose `Context` in the declaration is a consequence of\n/// > leveraging Noir's regular syntax for generics to ensure that certain\n/// > state variable methods can only be called in some contexts (private,\n/// > public, utility).\n///\n/// The methods of Map are:\n/// - `at` (access state variable for a given key)\n/// (see the method's own doc comments for more info).\n///\n/// ## Generic Parameters\n/// - `K`: The key type (must implement `ToField` trait for hashing)\n/// - `V`: The value type:\n///   - any Aztec state variable (variable that implements the StateVariable trait):\n///     - `PublicMutable`\n///     - `PublicImmutable`\n///     - `DelayedPublicMutable`\n///     - `Map`\n/// - `Context`: The execution context (handles private/public function\n///   contexts)\n///\n/// ## Usage\n/// Maps are typically declared in your contract's #[storage] struct and\n/// accessed\n/// using the `at(key)` method to get the state variable for a specific key.\n/// The resulting state variable can then be read from or written to using its\n/// own methods.\n///\n/// Note that maps cannot be used with owned state variables (variables that\n/// implement the OwnedStateVariable trait) - those need to be wrapped in an\n/// `Owned` state variable instead.\n///\n/// ## Advanced\n/// Internally, `Map` uses a single base storage slot to represent the\n/// mapping\n/// itself, similar to Solidity's approach. Individual key-value pairs are\n/// stored at derived storage slots computed by hashing the base storage\n/// slot\n/// with the key using Poseidon2. This ensures:\n/// - No storage slot collisions between different keys\n/// - Uniform distribution of storage slots across the storage space\n/// - Compatibility with Aztec's storage tree structure\n/// - Gas-efficient storage access patterns similar to Solidity mappings\n///\n/// The storage slot derivation uses `derive_storage_slot_in_map(base_slot,\n/// key)` which computes `poseidon2_hash([base_slot, key.to_field()])`,\n/// ensuring cryptographically secure slot separation.\n///\n/// docs:start:map\npub struct Map<K, V, Context> {\n    pub context: Context,\n    storage_slot: Field,\n}\n\n// Map reserves a single storage slot regardless of what it stores because\n// nothing is stored at said slot: it is only used to derive the storage slots\n// of nested state variables, which is expected to never result in collisions\n// or slots being close to one another due to these being hashes. This mirrors\n// the strategy adopted by Solidity mappings.\nimpl<K, V, Context> StateVariable<1, Context> for Map<K, V, Context> {\n    fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot }\n    }\n\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<K, V, Context> Map<K, V, Context> {\n    /// Returns the state variable associated with the given key.\n    ///\n    /// This is equivalent to accessing `mapping[key]` in Solidity. It returns\n    /// the state variable instance for the specified key, which can then be\n    /// used to read or write the value at that key.\n    ///\n    /// Unlike Solidity mappings which return the value directly, this returns\n    /// the state variable wrapper (like PublicMutable, nested Map etc.)\n    /// that you then call methods on to interact with the actual value.\n    ///\n    /// # Arguments\n    ///\n    /// * `key` - The key to look up in the map. Must implement the ToField\n    ///           trait (which most basic Noir & Aztec types do).\n    ///\n    /// # Returns\n    ///\n    /// * `V` - The state variable instance for this key. You can then call\n    ///         methods like `.read()`, `.write()`, `.get_note()`, etc. on this\n    ///         depending on the specific state variable type.\n    ///\n    /// # Example\n    ///\n    /// ```noir\n    /// // Get a user's balance (assuming PrivateMutable<FieldNote>)\n    /// let user_balance = self.storage.balances.at(user_address);\n    /// let current_note = user_balance.get_note();\n    ///\n    /// // Update the balance\n    /// user_balance.replace(new_note);\n    /// ```\n    ///\n    pub fn at<let N: u32>(self, key: K) -> V\n    where\n        K: ToField,\n        V: StateVariable<N, Context>,\n    {\n        V::new(\n            self.context,\n            derive_storage_slot_in_map(self.storage_slot, key),\n        )\n    }\n}\n","path":"/Users/zac/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/state_vars/map.nr"},"205":{"source":"use crate::context::{PublicContext, UtilityContext};\nuse crate::state_vars::state_variable::StateVariable;\nuse dep::protocol_types::traits::Packable;\n\n/// # PublicMutable\n///\n/// PublicMutable is a public state variable type for values that can be read\n/// and written within #[external(\"public\")] functions of your smart contract.\n///\n/// You can declare a state variable of type PublicMutable within your contract's\n/// #[storage] struct:\n///\n/// E.g.:\n/// `your_variable: PublicMutable<T, Context>`\n/// or:\n/// `your_mapping: Map<Field, PublicMutable<T, Context>>`\n///\n/// The methods of PublicMutable are:\n/// - `read`\n/// - `write`\n/// (see the methods' own doc comments for more info).\n///\n/// ## Example.\n///\n/// A voting contract's proposal count can be represented as a PublicMutable<u64>.\n/// The count can be read by anyone to see how many proposals exist, and incremented\n/// when new proposals are submitted.\n///\n/// # Generic Parameters:\n///\n/// * `T` - The type of value stored (must implement Packable).\n/// * `Context` - The execution context (PublicContext or UtilityContext).\n///\n/// # Advanced\n///\n/// Unlike private state variables which use notes, PublicMutable stores values\n/// directly in Aztec's public data tree. This enables direct read and write\n/// access to the current state during public function execution.\n///\n/// docs:start:public_mutable_struct\npub struct PublicMutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n\nimpl<T, Context, let M: u32> StateVariable<M, Context> for PublicMutable<T, Context>\nwhere\n    T: Packable<N = M>,\n{\n    fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicMutable { context, storage_slot }\n    }\n\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<T> PublicMutable<T, PublicContext> {\n    /// Reads the current value stored in this PublicMutable state variable.\n    ///\n    /// # Returns\n    ///\n    /// * `T` - The current value stored in this PublicMutable.\n    ///\n    /// docs:start:public_mutable_struct_read\n    pub fn read(self) -> T\n    where\n        T: Packable,\n    {\n        self.context.storage_read(self.storage_slot)\n    }\n\n    /// Writes a new value to this PublicMutable state variable.\n    ///\n    /// # Arguments\n    ///\n    /// * `value` - The new value to store in this PublicMutable.\n    ///\n    /// # Advanced\n    ///\n    /// This function updates the value stored in Aztec's public data tree.\n    /// The new value becomes immediately available to subsequent reads within\n    /// the same transaction.\n    ///\n    /// docs:start:public_mutable_struct_write\n    pub fn write(self, value: T)\n    where\n        T: Packable,\n    {\n        self.context.storage_write(self.storage_slot, value);\n    }\n}\n\nimpl<T> PublicMutable<T, UtilityContext> {\n    /// Reads the current value stored in this PublicMutable state variable.\n    ///\n    /// Notice that this function is executable only within a UtilityContext, which\n    /// is an unconstrained environment on the user's local device.\n    ///\n    /// # Returns\n    ///\n    /// * `T` - The current value stored in this PublicMutable.\n    ///\n    pub unconstrained fn read(self) -> T\n    where\n        T: Packable,\n    {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n","path":"/Users/zac/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/state_vars/public_mutable.nr"},"230":{"source":"/// Appends the elements of the second `BoundedVec` to the end of the first one. The resulting `BoundedVec` can have any arbitrary maximum length, but it must be\n/// large enough to fit all of the elements of both the first and second vectors.\npub fn append<T, let ALen: u32, let BLen: u32, let DstLen: u32>(\n    a: BoundedVec<T, ALen>,\n    b: BoundedVec<T, BLen>,\n) -> BoundedVec<T, DstLen> {\n    let mut dst = BoundedVec::new();\n\n    dst.extend_from_bounded_vec(a);\n    dst.extend_from_bounded_vec(b);\n\n    dst\n}\n\nmod test {\n    use super::append;\n\n    #[test]\n    unconstrained fn append_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::new();\n        let b: BoundedVec<_, 14> = BoundedVec::new();\n\n        let result: BoundedVec<Field, 5> = append(a, b);\n\n        assert_eq(result.len(), 0);\n        assert_eq(result.storage(), std::mem::zeroed());\n    }\n\n    #[test]\n    unconstrained fn append_non_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let result: BoundedVec<Field, 8> = append(a, b);\n\n        assert_eq(result.len(), 6);\n        assert_eq(result.storage(), [1, 2, 3, 4, 5, 6, std::mem::zeroed(), std::mem::zeroed()]);\n    }\n\n    #[test(should_fail_with = \"out of bounds\")]\n    unconstrained fn append_non_empty_vecs_insufficient_max_len() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let _: BoundedVec<Field, 5> = append(a, b);\n    }\n}\n","path":"/Users/zac/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/utils/array/append.nr"},"233":{"source":"/// Returns `DstLen` elements from a source array, starting at `offset`. `DstLen` must not be larger than the number\n/// of elements past `offset`.\n///\n/// Examples:\n/// ```\n/// let foo: [Field; 2] = subarray([1, 2, 3, 4, 5], 2);\n/// assert_eq(foo, [3, 4]);\n///\n/// let bar: [Field; 5] = subarray([1, 2, 3, 4, 5], 2); // fails - we can't return 5 elements since only 3 remain\n/// ```\npub fn subarray<T, let SrcLen: u32, let DstLen: u32>(src: [T; SrcLen], offset: u32) -> [T; DstLen] {\n    assert(offset + DstLen <= SrcLen, \"DstLen too large for offset\");\n\n    let mut dst: [T; DstLen] = std::mem::zeroed();\n    for i in 0..DstLen {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\nmod test {\n    use super::subarray;\n\n    #[test]\n    unconstrained fn subarray_into_empty() {\n        // In all of these cases we're setting DstLen to be 0, so we always get back an empty array.\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 2), []);\n    }\n\n    #[test]\n    unconstrained fn subarray_complete() {\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), [1, 2, 3, 4, 5]);\n    }\n\n    #[test]\n    unconstrained fn subarray_different_end_sizes() {\n        // We implicitly select how many values to read in the size of the return array\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4, 5]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2]);\n    }\n\n    #[test(should_fail_with = \"DstLen too large for offset\")]\n    unconstrained fn subarray_offset_too_large() {\n        // With an offset of 1 we can only request up to 4 elements\n        let _: [_; 5] = subarray([1, 2, 3, 4, 5], 1);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subarray_bad_return_value() {\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [3, 3, 4, 5]);\n    }\n}\n","path":"/Users/zac/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/utils/array/subarray.nr"},"234":{"source":"use crate::utils::array;\n\n/// Returns `DstMaxLen` elements from a source BoundedVec, starting at `offset`. `offset` must not be larger than the\n/// original length, and `DstLen` must not be larger than the total number of elements past `offset` (including the\n/// zeroed elements past `len()`).\n///\n/// Only elements at the beginning of the vector can be removed: it is not possible to also remove elements at the end\n/// of the vector by passing a value for `DstLen` that is smaller than `len() - offset`.\n///\n/// Examples:\n/// ```\n/// let foo = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n/// assert_eq(subbvec(foo, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n///\n/// let bar: BoundedVec<_, 1> = subbvec(foo, 2); // fails - we can't return just 1 element since 3 remain\n/// let baz: BoundedVec<_, 10> = subbvec(foo, 3); // fails - we can't return 10 elements since only 7 remain\n/// ```\npub fn subbvec<T, let SrcMaxLen: u32, let DstMaxLen: u32>(\n    bvec: BoundedVec<T, SrcMaxLen>,\n    offset: u32,\n) -> BoundedVec<T, DstMaxLen> {\n    // from_parts_unchecked does not verify that the elements past len are zeroed, but that is not an issue in our case\n    // because we're constructing the new storage array as a subarray of the original one (which should have zeroed\n    // storage past len), guaranteeing correctness. This is because `subarray` does not allow extending arrays past\n    // their original length.\n    BoundedVec::from_parts_unchecked(array::subarray(bvec.storage(), offset), bvec.len() - offset)\n}\n\nmod test {\n    use super::subbvec;\n\n    #[test]\n    unconstrained fn subbvec_empty() {\n        let bvec = BoundedVec::<Field, 0>::from_array([]);\n        assert_eq(subbvec(bvec, 0), bvec);\n    }\n\n    #[test]\n    unconstrained fn subbvec_complete() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), bvec);\n\n        let smaller_capacity = BoundedVec::<_, 5>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), smaller_capacity);\n    }\n\n    #[test]\n    unconstrained fn subbvec_partial() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 3>::from_array([3, 4, 5]));\n    }\n\n    #[test]\n    unconstrained fn subbvec_into_empty() {\n        let bvec: BoundedVec<_, 10> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 5), BoundedVec::<_, 5>::from_array([]));\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_offset_past_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        let _: BoundedVec<_, 1> = subbvec(bvec, 6);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_insufficient_dst_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // We're not providing enough space to hold all of the items inside the original BoundedVec. subbvec can cause\n        // for the capacity to reduce, but not the length (other than by len - offset).\n        let _: BoundedVec<_, 1> = subbvec(bvec, 2);\n    }\n\n    #[test(should_fail_with = \"DstLen too large for offset\")]\n    unconstrained fn subbvec_dst_len_causes_enlarge() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // subbvec does not supprt capacity increases\n        let _: BoundedVec<_, 11> = subbvec(bvec, 0);\n    }\n\n    #[test(should_fail_with = \"DstLen too large for offset\")]\n    unconstrained fn subbvec_dst_len_too_large_for_offset() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // This effectively requests a capacity increase, since there'd be just one element plus the 5 empty slots,\n        // which is less than 7.\n        let _: BoundedVec<_, 7> = subbvec(bvec, 4);\n    }\n}\n","path":"/Users/zac/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/utils/array/subbvec.nr"},"236":{"source":"use std::static_assert;\n\n// These functions are used to facilitate the conversion of log ciphertext between byte and field representations.\n//\n// `bytes_to_fields` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `bytes_from_fields` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between bytes and fields when processing encrypted logs.\n\n/// Converts the input bytes into an array of fields. A Field is ~254 bits meaning that each field can store 31 whole\n/// bytes. Use `bytes_from_fields` to obtain the original bytes array.\n///\n/// The input bytes are chunked into chunks of 31 bytes. Each 31-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (31 bytes) is encoded as [1 * 256^30 + 10 * 256^29 + 3 * 256^28 + ... + 0]\n/// Note: N must be a multiple of 31 bytes\npub fn bytes_to_fields<let N: u32>(bytes: [u8; N]) -> [Field; N / 31] {\n    // Assert that N is a multiple of 31\n    static_assert(N % 31 == 0, \"N must be a multiple of 31\");\n\n    let mut fields = [0; N / 31];\n\n    // Since N is a multiple of 31, we can simply process all chunks fully\n    for i in 0..N / 31 {\n        let mut field = 0;\n        for j in 0..31 {\n            // Shift the existing value left by 8 bits and add the new byte\n            field = field * 256 + bytes[i * 31 + j] as Field;\n        }\n        fields[i] = field;\n    }\n\n    fields\n}\n\n/// Converts an input BoundedVec of fields into a BoundedVec of bytes in big-endian order. Arbitrary Field arrays\n/// are not allowed: this is assumed to be an array obtained via `bytes_to_fields`, i.e. one that actually represents\n/// bytes. To convert a Field array into bytes, use `fields_to_bytes`.\n///\n/// Each input field must contain at most 31 bytes (this is constrained to be so).\n/// Each field is converted into 31 big-endian bytes, and the resulting 31-byte chunks are concatenated\n/// back together in the order of the original fields.\npub fn bytes_from_fields<let N: u32>(fields: BoundedVec<Field, N>) -> BoundedVec<u8, N * 31> {\n    let mut bytes = BoundedVec::new();\n\n    for i in 0..fields.len() {\n        let field = fields.get(i);\n\n        // We expect that the field contains at most 31 bytes of information.\n        field.assert_max_bit_size::<248>();\n\n        // Now we can safely convert the field to 31 bytes.\n        let field_as_bytes: [u8; 31] = field.to_be_bytes();\n\n        for j in 0..31 {\n            bytes.push(field_as_bytes[j]);\n        }\n    }\n\n    bytes\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{bytes_from_fields, bytes_to_fields};\n\n    #[test]\n    unconstrained fn random_bytes_to_fields_and_back(input: [u8; 93]) {\n        let fields = bytes_to_fields(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `bytes_from_fields`\n        // function.\n        let fields_as_bounded_vec = BoundedVec::<_, 6>::from_array(fields);\n\n        let bytes_back = bytes_from_fields(fields_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(bytes_back.len(), input.len());\n        assert_eq(subarray(bytes_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"N must be a multiple of 31\")]\n    unconstrained fn bytes_to_fields_input_length_not_multiple_of_31() {\n        // Try to convert 32 bytes (not a multiple of 31) to fields\n        let _fields = bytes_to_fields([0; 32]);\n    }\n\n}\n","path":"/Users/zac/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/utils/conversion/bytes_to_fields.nr"},"237":{"source":"// These functions are used to facilitate the conversion of log plaintext represented as fields into bytes and back.\n//\n// `fields_to_bytes` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `fields_from_bytes` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between fields and bytes.\n\n/// Converts an input array of fields into a single array of bytes. Use `fields_from_bytes` to obtain the original\n/// field array.\n/// Each field is converted to a 32-byte big-endian array.\n///\n/// For example, if you have a field array [123, 456], it will be converted to a 64-byte array:\n/// [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,123,  // First field (32 bytes)\n///  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,200]  // Second field (32 bytes)\n///\n/// Since a field is ~254 bits, you'll end up with a subtle 2-bit \"gap\" at the big end, every 32 bytes. Be careful\n/// that such a gap doesn't leak information! This could happen if you for example expected the output to be\n/// indistinguishable from random bytes.\npub fn fields_to_bytes<let N: u32>(fields: [Field; N]) -> [u8; 32 * N] {\n    let mut bytes = [0; 32 * N];\n\n    for i in 0..N {\n        let field_as_bytes: [u8; 32] = fields[i].to_be_bytes();\n\n        for j in 0..32 {\n            bytes[i * 32 + j] = field_as_bytes[j];\n        }\n    }\n\n    bytes\n}\n\n/// Converts an input BoundedVec of bytes into a BoundedVec of fields. Arbitrary byte arrays are not allowed: this\n/// is assumed to be an array obtained via `fields_to_bytes`, i.e. one that actually represents fields. To convert\n/// a byte array into Fields, use `bytes_to_fields`.\n///\n/// The input bytes are chunked into chunks of 32 bytes. Each 32-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (32 bytes) is encoded as [1 * 256^31 + 10 * 256^30 + 3 * 256^29 + ... + 0]\n/// Note 1: N must be a multiple of 32 bytes\n/// Note 2: The max value check code was taken from std::field::to_be_bytes function.\npub fn fields_from_bytes<let N: u32>(bytes: BoundedVec<u8, N>) -> BoundedVec<Field, N / 32> {\n    // Assert that input length is a multiple of 32\n    assert(bytes.len() % 32 == 0, \"Input length must be a multiple of 32\");\n\n    let mut fields = BoundedVec::new();\n\n    let p = std::field::modulus_be_bytes();\n\n    // Since input length is a multiple of 32, we can simply process all chunks fully\n    for i in 0..bytes.len() / 32 {\n        let mut field = 0;\n\n        // Process each byte in the 32-byte chunk\n        let mut ok = false;\n\n        for j in 0..32 {\n            let next_byte = bytes.get(i * 32 + j);\n            field = field * 256 + next_byte as Field;\n\n            if !ok {\n                if next_byte != p[j] {\n                    assert(next_byte < p[j], \"Value does not fit in field\");\n                    ok = true;\n                }\n            }\n        }\n        assert(ok, \"Value does not fit in field\");\n\n        fields.push(field);\n    }\n\n    fields\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{fields_from_bytes, fields_to_bytes};\n\n    #[test]\n    unconstrained fn random_fields_to_bytes_and_back(input: [Field; 3]) {\n        // Convert to bytes\n        let bytes = fields_to_bytes(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `fields_from_bytes`\n        // function.\n        // 113 is an arbitrary max length that is larger than the input length of 96.\n        let bytes_as_bounded_vec = BoundedVec::<_, 113>::from_array(bytes);\n\n        // Convert back to fields\n        let fields_back = fields_from_bytes(bytes_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(fields_back.len(), input.len());\n        assert_eq(subarray(fields_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"Input length must be a multiple of 32\")]\n    unconstrained fn to_fields_assert() {\n        // 143 is an arbitrary max length that is larger than 33\n        let input = BoundedVec::<_, 143>::from_array([\n            1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n            25, 26, 27, 28, 29, 30, 31, 32, 33,\n        ]);\n\n        // This should fail since 33 is not a multiple of 32\n        let _fields = fields_from_bytes(input);\n    }\n\n    #[test]\n    unconstrained fn fields_from_bytes_max_value() {\n        let max_field_as_bytes: [u8; 32] = (-1).to_be_bytes();\n        let input = BoundedVec::<_, 32>::from_array(max_field_as_bytes);\n\n        let fields = fields_from_bytes(input);\n\n        // The result should be a largest value storable in a field (-1 since we are modulo-ing)\n        assert_eq(fields.get(0), -1);\n    }\n\n    // In this test we verify that overflow check works by taking the max allowed value, bumping a random byte\n    // and then feeding it to `fields_from_bytes` as input.\n    #[test(should_fail_with = \"Value does not fit in field\")]\n    unconstrained fn fields_from_bytes_overflow(random_value: u8) {\n        let index_of_byte_to_bump = random_value % 32;\n\n        // Obtain the byte representation of the maximum field value\n        let max_field_value_as_bytes: [u8; 32] = (-1).to_be_bytes();\n\n        let byte_to_bump = max_field_value_as_bytes[index_of_byte_to_bump as u32];\n\n        // Skip test execution if the selected byte is already at maximum value (255).\n        // This is acceptable since we are using fuzz testing to generate many test cases.\n        if byte_to_bump != 255 {\n            let mut input = BoundedVec::<_, 32>::from_array(max_field_value_as_bytes);\n\n            // Increment the selected byte to exceed the field's maximum value\n            input.set(index_of_byte_to_bump as u32, byte_to_bump + 1);\n\n            // Attempt the conversion, which should fail due to the value exceeding the field's capacity\n            let _fields = fields_from_bytes(input);\n        }\n    }\n\n}\n","path":"/Users/zac/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/utils/conversion/fields_to_bytes.nr"},"240":{"source":"use protocol_types::{point::Point, utils::field::sqrt};\n\n// I am storing the modulus minus 1 divided by 2 here because full modulus would throw \"String literal too large\" error\n// Full modulus is 21888242871839275222246405745257275088548364400416034343698204186575808495617\nglobal BN254_FR_MODULUS_DIV_2: Field =\n    10944121435919637611123202872628637544274182200208017171849102093287904247808;\n\n/// Converts a point to a byte array.\n///\n/// We don't serialize the point at infinity flag because this function is used in situations where we do not want\n/// to waste the extra byte (encrypted log).\npub fn point_to_bytes(p: Point) -> [u8; 32] {\n    // Note that there is 1 more free bit in the 32 bytes (254 bits currently occupied by the x coordinate, 1 bit for\n    // the \"sign\") so it's possible to use that last bit as an \"is_infinite\" flag if desired in the future.\n    assert(!p.is_infinite, \"Cannot serialize point at infinity as bytes.\");\n\n    let mut result: [u8; 32] = p.x.to_be_bytes();\n\n    if get_sign_of_point(p) {\n        // y is <= (modulus - 1) / 2 so we set the sign bit to 1\n        // Here we leverage that field fits into 254 bits (log2(Fr.MODULUS) < 254) and given that we serialize Fr to 32\n        // bytes and we use big-endian the 2 most significant bits are never populated. Hence we can use one of\n        // the bits as a sign bit.\n        result[0] += 128;\n    }\n\n    result\n}\n\n/**\n * Returns: true if p.y <= MOD_DIV_2, else false.\n */\npub fn get_sign_of_point(p: Point) -> bool {\n    // We store only a \"sign\" of the y coordinate because the rest can be derived from the x coordinate. To get\n    // the sign we check if the y coordinate is less or equal than the curve's order minus 1 divided by 2.\n    // Ideally we'd do `y <= MOD_DIV_2`, but there's no `lte` function, so instead we do `!(y > MOD_DIV_2)`, which is\n    // equivalent, and then rewrite that as `!(MOD_DIV_2 < y)`, since we also have no `gt` function.\n    !BN254_FR_MODULUS_DIV_2.lt(p.y)\n}\n\n/// Returns a `Point` in the Grumpkin curve given its x coordinate.\n///\n/// Because not all values in the field are valid x coordinates of points in the curve (i.e. there\n/// is no corresponding y value in the field that satisfies the curve equation), it may not be\n/// possible to reconstruct a `Point`. `Option::none()` is returned in such cases.\npub fn point_from_x_coord(x: Field) -> Option<Point> {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    sqrt(rhs).map(|y| Point { x, y, is_infinite: false })\n}\n\n/// Returns a `Point` in the Grumpkin curve given its x coordinate and sign for the y coordinate.\n///\n/// Because not all values in the field are valid x coordinates of points in the curve (i.e. there\n/// is no corresponding y value in the field that satisfies the curve equation), it may not be\n/// possible to reconstruct a `Point`. `Option::none()` is returned in such cases.\n///\n/// @param x - The x coordinate of the point\n/// @param sign - The \"sign\" of the y coordinate - determines whether y <= (Fr.MODULUS - 1) / 2\npub fn point_from_x_coord_and_sign(x: Field, sign: bool) -> Option<Point> {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n\n    sqrt(rhs).map(|y| {\n        // If there is a square root, we need to ensure it has the correct \"sign\"\n        let y_is_positive = !BN254_FR_MODULUS_DIV_2.lt(y);\n        let final_y = if y_is_positive == sign { y } else { -y };\n        Point { x, y: final_y, is_infinite: false }\n    })\n}\n\nmod test {\n    use crate::utils::point::{point_from_x_coord, point_from_x_coord_and_sign, point_to_bytes};\n    use dep::protocol_types::point::Point;\n    use dep::protocol_types::utils::field::pow;\n\n    #[test]\n    unconstrained fn test_point_to_bytes_positive_sign() {\n        let p = Point {\n            x: 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73,\n            y: 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_positive_sign = [\n            154, 244, 31, 93, 233, 100, 70, 220, 55, 118, 161, 235, 45, 152, 187, 149, 107, 122,\n            205, 153, 121, 166, 120, 84, 190, 198, 250, 124, 41, 115, 189, 115,\n        ];\n        assert_eq(expected_compressed_point_positive_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_to_bytes_negative_sign() {\n        let p = Point {\n            x: 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5,\n            y: 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_negative_sign = [\n            36, 115, 113, 101, 46, 85, 221, 116, 201, 175, 141, 190, 159, 180, 73, 49, 186, 41, 169,\n            34, 153, 148, 56, 75, 215, 7, 119, 150, 193, 78, 226, 181,\n        ];\n\n        assert_eq(expected_compressed_point_negative_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_from_x_coord_and_sign() {\n        // Test positive y coordinate\n        let x = 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73;\n        let sign = true;\n        let p = point_from_x_coord_and_sign(x, sign).unwrap();\n\n        assert_eq(p.x, x);\n        assert_eq(p.y, 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a);\n        assert_eq(p.is_infinite, false);\n\n        // Test negative y coordinate\n        let x2 = 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5;\n        let sign2 = false;\n        let p2 = point_from_x_coord_and_sign(x2, sign2).unwrap();\n\n        assert_eq(p2.x, x2);\n        assert_eq(p2.y, 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0);\n        assert_eq(p2.is_infinite, false);\n    }\n\n    #[test]\n    unconstrained fn test_point_from_x_coord_valid() {\n        // x = 8 is a known quadratic residue - should give a valid point\n        let result = point_from_x_coord(Field::from(8));\n        assert(result.is_some());\n\n        let point = result.unwrap();\n        assert_eq(point.x, Field::from(8));\n        // Check curve equation y^2 = x^3 - 17\n        assert_eq(pow(point.y, 2), pow(point.x, 3) - 17);\n    }\n\n    #[test]\n    unconstrained fn test_point_from_x_coord_invalid() {\n        // x = 3 is a non-residue for this curve - should give None\n        let x = Field::from(3);\n        let maybe_point = point_from_x_coord(x);\n        assert(maybe_point.is_none());\n    }\n\n}\n","path":"/Users/zac/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/utils/point.nr"},"251":{"source":"use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n","path":"/Users/zac/nargo/github.com/noir-lang/poseidon/v0.1.1/src/poseidon2.nr"},"271":{"source":"use crate::traits::{Deserialize, Empty, FromField, Serialize, ToField};\nuse std::meta::derive;\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct FunctionSelector {\n    // 1st 4-bytes (big-endian leftmost) of abi-encoding of an event.\n    pub inner: u32,\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        FunctionSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n\n#[test]\nfn test_is_valid_selector() {\n    let selector = FunctionSelector::from_signature(\"IS_VALID()\");\n    assert_eq(selector.to_field(), 0x73cdda47);\n}\n\n#[test]\nfn test_long_selector() {\n    let selector =\n        FunctionSelector::from_signature(\"foo_and_bar_and_baz_and_foo_bar_baz_and_bar_foo\");\n    assert_eq(selector.to_field(), 0x7590a997);\n}\n","path":"/Users/zac/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.6-patch.1/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr"},"309":{"source":"use crate::{\n    address::{\n        partial_address::PartialAddress, salted_initialization_hash::SaltedInitializationHash,\n    },\n    constants::{\n        AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1, MAX_FIELD_VALUE,\n        MAX_PROTOCOL_CONTRACTS,\n    },\n    contract_class_id::ContractClassId,\n    hash::poseidon2_hash_with_separator,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, ToPoint, TpkM},\n    traits::{Deserialize, Empty, FromField, Packable, Serialize, ToField},\n    utils::field::{pow, sqrt},\n};\n\n// We do below because `use crate::point::Point;` does not work\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\nuse crate::public_keys::AddressPoint;\nuse std::{\n    embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul as derive_public_key},\n    ops::Add,\n};\nuse std::meta::derive;\n\n// Aztec address\n#[derive(Deserialize, Eq, Packable, Serialize)]\npub struct AztecAddress {\n    pub inner: Field,\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    /// Returns an address's `AddressPoint`, which can be used to create shared secrets with the owner\n    /// of the address. If the address is invalid (i.e. it is not a properly derived Aztec address), then this\n    /// returns `Option::none()`, and no shared secrets can be created.\n    pub fn to_address_point(self) -> Option<AddressPoint> {\n        // We compute the address point by taking our address, setting it to x, and then solving for y in the\n        // equation which defines our bn curve:\n        // y^2 = x^3 - 17; x = address\n        let x = self.inner;\n        let y_squared = pow(x, 3) - 17;\n\n        // An invalid AztecAddress is one for which no y coordinate satisfies the curve equation, which we'll\n        // identify by proving that the square root of y_squared does not exist.\n        let mut y_opt = sqrt(y_squared);\n        if y_opt.is_none() {\n            Option::none()\n        } else {\n            let mut y = y_opt.unwrap();\n\n            // If we get a negative y coordinate (any y where y > MAX_FIELD_VALUE / 2), we pin it to the\n            // positive one (any value where y <= MAX_FIELD_VALUE / 2) by subtracting it from the Field modulus\n            // note: The field modulus is MAX_FIELD_VALUE + 1\n            if (!(y.lt(MAX_FIELD_VALUE / 2) | y.eq(MAX_FIELD_VALUE / 2))) {\n                y = (MAX_FIELD_VALUE + 1) - y;\n            }\n\n            Option::some(\n                AddressPoint { inner: Point { x: self.inner, y, is_infinite: false } },\n            )\n        }\n    }\n\n    pub fn compute(public_keys: PublicKeys, partial_address: PartialAddress) -> AztecAddress {\n        let public_keys_hash = public_keys.hash();\n\n        let pre_address = poseidon2_hash_with_separator(\n            [public_keys_hash.to_field(), partial_address.to_field()],\n            GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        );\n\n        let address_point = derive_public_key(EmbeddedCurveScalar::from_field(pre_address)).add(\n            public_keys.ivpk_m.to_point(),\n        );\n\n        // Note that our address is only the x-coordinate of the full address_point. This is okay because when people want to encrypt something and send it to us\n        // they can recover our full point using the x-coordinate (our address itself). To do this, they recompute the y-coordinate according to the equation y^2 = x^3 - 17.\n        // When they do this, they may get a positive y-coordinate (a value that is less than or equal to MAX_FIELD_VALUE / 2) or\n        // a negative y-coordinate (a value that is more than MAX_FIELD_VALUE), and we cannot dictate which one they get and hence the recovered point may sometimes be different than the one\n        // our secret can decrypt. Regardless though, they should and will always encrypt using point with the positive y-coordinate by convention.\n        // This ensures that everyone encrypts to the same point given an arbitrary x-coordinate (address). This is allowed because even though our original point may not have a positive y-coordinate,\n        // with our original secret, we will be able to derive the secret to the point with the flipped (and now positive) y-coordinate that everyone encrypts to.\n        AztecAddress::from_field(address_point.x)\n    }\n\n    pub fn compute_from_class_id(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash,\n        public_keys: PublicKeys,\n    ) -> Self {\n        let partial_address = PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            salted_initialization_hash,\n        );\n\n        AztecAddress::compute(public_keys, partial_address)\n    }\n\n    pub fn is_protocol_contract(self) -> bool {\n        self.inner.lt(MAX_PROTOCOL_CONTRACTS as Field)\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys() {\n    let public_keys = PublicKeys {\n        npk_m: NpkM {\n            inner: Point {\n                x: 0x22f7fcddfa3ce3e8f0cc8e82d7b94cdd740afa3e77f8e4a63ea78a239432dcab,\n                y: 0x0471657de2b6216ade6c506d28fbc22ba8b8ed95c871ad9f3e3984e90d9723a7,\n                is_infinite: false,\n            },\n        },\n        ivpk_m: IvpkM {\n            inner: Point {\n                x: 0x111223493147f6785514b1c195bb37a2589f22a6596d30bb2bb145fdc9ca8f1e,\n                y: 0x273bbffd678edce8fe30e0deafc4f66d58357c06fd4a820285294b9746c3be95,\n                is_infinite: false,\n            },\n        },\n        ovpk_m: OvpkM {\n            inner: Point {\n                x: 0x09115c96e962322ffed6522f57194627136b8d03ac7469109707f5e44190c484,\n                y: 0x0c49773308a13d740a7f0d4f0e6163b02c5a408b6f965856b6a491002d073d5b,\n                is_infinite: false,\n            },\n        },\n        tpk_m: TpkM {\n            inner: Point {\n                x: 0x00d3d81beb009873eb7116327cf47c612d5758ef083d4fda78e9b63980b2a762,\n                y: 0x2f567d22d2b02fe1f4ad42db9d58a36afd1983e7e2909d1cab61cafedad6193a,\n                is_infinite: false,\n            },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(\n        0x0a7c585381b10f4666044266a02405bf6e01fa564c8517d4ad5823493abd31de,\n    );\n\n    let address = AztecAddress::compute(public_keys, partial_address);\n\n    // The following value was generated by `derivation.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_computed_address_from_partial_and_pubkeys =\n        0x24e4646f58b9fbe7d38e317db8d5636c423fbbdfbe119fc190fe9c64747e0c62;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkeys);\n}\n\n#[test]\nfn compute_preaddress_from_partial_and_pub_keys() {\n    let pre_address = poseidon2_hash_with_separator([1, 2], GENERATOR_INDEX__CONTRACT_ADDRESS_V1);\n    let expected_computed_preaddress_from_partial_and_pubkey =\n        0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(pre_address == expected_computed_preaddress_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    // We use the AZTEC_ADDRESS_LENGTH constant to ensure that there is a match between the derived trait\n    // implementation and the constant.\n    let serialized: [Field; AZTEC_ADDRESS_LENGTH] = address.serialize();\n    let deserialized = AztecAddress::deserialize(serialized);\n    assert_eq(address, deserialized);\n}\n\n#[test]\nfn to_address_point_valid() {\n    // x = 8 where x^3 - 17 = 512 - 17 = 495, which is a residue in this field\n    let address = AztecAddress { inner: 8 };\n    let maybe_point = address.to_address_point();\n    assert(maybe_point.is_some());\n\n    let point = maybe_point.unwrap().inner;\n    // check that x is preserved\n    assert_eq(point.x, Field::from(8));\n\n    // check that the curve equation holds: y^2 == x^3 - 17\n    assert_eq(pow(point.y, 2), pow(point.x, 3) - 17);\n}\n\n#[test]\nunconstrained fn to_address_point_invalid() {\n    // x = 3 where x^3 - 17 = 27 - 17 = 10, which is a non-residue in this field\n    let address = AztecAddress { inner: 3 }; //\n    let maybe_point = address.to_address_point();\n    assert(maybe_point.is_none());\n}\n","path":"/Users/zac/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.6-patch.1/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr"},"330":{"source":"// TODO: Expose other wrapped functions than debug (info, warn)\n// ['silent', 'fatal', 'error', 'warn', 'info', 'verbose', 'debug', 'trace']\n\npub global SILENT_LOG_LEVEL: u8 = 0;\npub global FATAL_LOG_LEVEL: u8 = 1;\npub global ERROR_LOG_LEVEL: u8 = 2;\npub global WARN_LOG_LEVEL: u8 = 3;\npub global INFO_LOG_LEVEL: u8 = 4;\npub global VERBOSE_LOG_LEVEL: u8 = 5;\npub global DEBUG_LOG_LEVEL: u8 = 6;\npub global TRACE_LOG_LEVEL: u8 = 7;\n\n/// Utility function to console.log data in the acir simulator.\n/// Example:\n///   debug_log(\"blah blah this is a debug string\");\npub fn debug_log<let N: u32>(msg: str<N>) {\n    debug_log_format(msg, []);\n}\n\n/// Same as debug_log, but allows to customize the log level.\n/// Consider changing just to 'log'\npub fn debug_log_with_level<let N: u32>(log_level: u8, msg: str<N>) {\n    debug_log_format_with_level(log_level, msg, []);\n}\n\n/// Utility function to console.log data in the acir simulator. This variant receives a format string in which the\n/// `${k}` tokens will be replaced with the k-eth value in the `args` array.\n/// Examples:\n///   debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n///   debug_log_format(\"whole array: {}\", [e1, e2, e3, e4]);\npub fn debug_log_format<let M: u32, let N: u32>(msg: str<M>, args: [Field; N]) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { debug_log_array_oracle_wrapper(DEBUG_LOG_LEVEL, msg, args) };\n}\n\n/// Same as debug_log_format, but allows to customize the log level.\n/// Consider changing just to 'log_format'\npub fn debug_log_format_with_level<let M: u32, let N: u32>(\n    log_level: u8,\n    msg: str<M>,\n    args: [Field; N],\n) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { debug_log_array_oracle_wrapper(log_level, msg, args) };\n}\n\n/// Utility function to console.log data in the acir simulator. This variant receives a format string in which the\n/// `${k}` tokens will be replaced with the k-eth value in the `args` slice.\n/// Examples:\n///   debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n///   debug_log_format(\"whole slice: {}\", [e1, e2, e3, e4]);\npub fn debug_log_format_slice<let M: u32>(log_level: u8, msg: str<M>, args: [Field]) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { debug_log_slice_oracle_wrapper(log_level, msg, args) };\n}\n\n// We provide two versions of the debug log oracle: one that takes args as a slice and another one that takes args as an array.\n// We do this since conversion from array to slice generates overhead in public functions, since opcodes need to be emitted for the conversion.\n// By exposing the two flavors, we avoid conversions since the AVM is able to handle both arrays an slices in this oracle.\n\nunconstrained fn debug_log_slice_oracle_wrapper<let M: u32>(\n    log_level: u8,\n    msg: str<M>,\n    args: [Field],\n) {\n    debug_log_slice_oracle(log_level, msg, args);\n}\n\n// WARNING: sometimes when using debug logs the ACVM errors with: `thrown: \"solver opcode resolution error: cannot solve opcode: expression has too many unknowns x155\"`\n#[oracle(utilityDebugLog)]\nunconstrained fn debug_log_slice_oracle<let M: u32>(log_level: u8, msg: str<M>, args: [Field]) {}\n\nunconstrained fn debug_log_array_oracle_wrapper<let M: u32, let N: u32>(\n    log_level: u8,\n    msg: str<M>,\n    args: [Field; N],\n) {\n    debug_log_array_oracle(log_level, msg, N, args);\n}\n\n#[oracle(utilityDebugLog)]\nunconstrained fn debug_log_array_oracle<let M: u32, let N: u32>(\n    log_level: u8,\n    msg: str<M>,\n    length: u32,\n    args: [Field; N],\n) {}\n","path":"/Users/zac/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.6-patch.1/noir-projects/noir-protocol-circuits/crates/types/src/debug_log.nr"},"340":{"source":"mod poseidon2_chunks;\n\nuse crate::{\n    abis::{\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n        function_selector::FunctionSelector,\n        note_hash::NoteHash,\n        nullifier::Nullifier,\n        private_log::{PrivateLog, PrivateLogData},\n        transaction::tx_request::TxRequest,\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        CONTRACT_CLASS_LOG_SIZE_IN_FIELDS, FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__NOTE_HASH_NONCE,\n        GENERATOR_INDEX__OUTER_NULLIFIER, GENERATOR_INDEX__SILOED_NOTE_HASH,\n        GENERATOR_INDEX__UNIQUE_NOTE_HASH, NULL_MSG_SENDER_CONTRACT_ADDRESS, TWO_POW_64,\n    },\n    merkle_tree::root_from_sibling_path,\n    messaging::l2_to_l1_message::L2ToL1Message,\n    poseidon2::Poseidon2Sponge,\n    side_effect::{Counted, Scoped},\n    traits::{FromField, Hash, ToField},\n    utils::field::{field_from_bytes, field_from_bytes_32_trunc},\n};\n\npub use poseidon2_chunks::poseidon2_absorb_in_chunks_existing_sponge;\nuse poseidon2_chunks::poseidon2_absorb_in_chunks;\nuse std::embedded_curve_ops::EmbeddedCurveScalar;\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256::digest(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(\n        function_leaf,\n        function_leaf_index,\n        function_leaf_sibling_path,\n    )\n}\n\npub fn compute_note_hash_nonce(first_nullifier_in_tx: Field, note_index_in_tx: u32) -> Field {\n    // Hashing the first nullifier with note index in tx is guaranteed to be unique (because all nullifiers are also\n    // unique).\n    poseidon2_hash_with_separator(\n        [first_nullifier_in_tx, note_index_in_tx as Field],\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\n    )\n}\n\npub fn compute_unique_note_hash(note_nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [note_nonce, siloed_note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_nonce_and_unique_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    let note_nonce = compute_note_hash_nonce(first_nullifier, note_index_in_tx);\n    compute_unique_note_hash(note_nonce, siloed_note_hash)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), note_hash],\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\n    )\n}\n\n/// Computes unique note hashes from siloed note hashes\npub fn compute_unique_siloed_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    if siloed_note_hash == 0 {\n        0\n    } else {\n        compute_nonce_and_unique_note_hash(siloed_note_hash, first_nullifier, note_index_in_tx)\n    }\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: Scoped<Counted<NoteHash>>) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_note_hash(note_hash.contract_address, note_hash.innermost())\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), nullifier],\n        GENERATOR_INDEX__OUTER_NULLIFIER,\n    )\n}\n\npub fn silo_nullifier(nullifier: Scoped<Counted<Nullifier>>) -> Field {\n    let value = nullifier.innermost().value;\n    // Q: shouldn't we be checking whether the _whole_ nullifier is empty?\n    // A: We don't have to. The init and inner circuits add contract address to non-empty nullifiers.\n    // So we know we should silo it if the contract address is not empty.\n    if nullifier.contract_address.is_zero() {\n        value // Return `value` instead of 0 because an already-siloed nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, value)\n    }\n}\n\npub fn create_protocol_nullifier(tx_request: TxRequest) -> Scoped<Counted<Nullifier>> {\n    Nullifier { value: tx_request.hash(), note_hash: 0 }.count(1).scope(\n        NULL_MSG_SENDER_CONTRACT_ADDRESS,\n    )\n}\n\npub fn compute_siloed_private_log_field(contract_address: AztecAddress, field: Field) -> Field {\n    poseidon2_hash([contract_address.to_field(), field])\n}\n\npub fn silo_private_log(private_log: Scoped<Counted<PrivateLogData>>) -> PrivateLog {\n    let log = private_log.innermost().log;\n    if private_log.contract_address.is_zero() {\n        log\n    } else {\n        let mut fields = log.fields;\n        fields[0] = compute_siloed_private_log_field(private_log.contract_address, fields[0]);\n        PrivateLog::new(fields, log.length)\n    }\n}\n\npub fn compute_contract_class_log_hash(log: [Field; CONTRACT_CLASS_LOG_SIZE_IN_FIELDS]) -> Field {\n    poseidon2_hash(log)\n}\n\npub fn compute_app_secret_key(\n    master_secret_key: EmbeddedCurveScalar,\n    app_address: AztecAddress,\n    app_secret_generator: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [master_secret_key.hi, master_secret_key.lo, app_address.to_field()],\n        app_secret_generator,\n    )\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    let contract_address_bytes: [u8; 32] = contract_address.to_field().to_be_bytes();\n    let recipient_bytes: [u8; 20] = recipient.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let rollup_version_id_bytes: [u8; 32] = rollup_version_id.to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n\n    let mut bytes: [u8; 148] = std::mem::zeroed();\n    for i in 0..32 {\n        bytes[i] = contract_address_bytes[i];\n        bytes[i + 32] = rollup_version_id_bytes[i];\n        // 64 - 84 are for recipient.\n        bytes[i + 84] = chain_id_bytes[i];\n        bytes[i + 116] = content_bytes[i];\n    }\n\n    for i in 0..20 {\n        bytes[64 + i] = recipient_bytes[i];\n    }\n\n    sha256_to_field(bytes)\n}\n\npub fn silo_l2_to_l1_message(\n    msg: Scoped<L2ToL1Message>,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.inner.recipient,\n            msg.inner.content,\n            rollup_version_id,\n            chain_id,\n        )\n    }\n}\n\n/// Computes sha256 hash of 2 input fields.\n///\n/// @returns A truncated field (i.e., the first byte is always 0).\npub fn accumulate_sha256(v0: Field, v1: Field) -> Field {\n    // Concatenate two fields into 32 x 2 = 64 bytes\n    let v0_as_bytes: [u8; 32] = v0.to_be_bytes();\n    let v1_as_bytes: [u8; 32] = v1.to_be_bytes();\n    let hash_input_flattened = v0_as_bytes.concat(v1_as_bytes);\n\n    sha256_to_field(hash_input_flattened)\n}\n\n#[inline_always]\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    poseidon::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let inputs_with_separator = [separator.to_field()].concat(inputs);\n    poseidon2_hash(inputs_with_separator)\n}\n\n/// Computes a Poseidon2 hash over a dynamic-length subarray of the given input.\n/// Only the first `in_len` fields of `input` are absorbed; any remaining fields are ignored.\n/// The caller is responsible for ensuring that the input is padded with zeros if required.\n#[no_predicates]\npub fn poseidon2_hash_subarray<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_in_chunks(input, in_len);\n    sponge.squeeze()\n}\n\n// NB the below is the same as poseidon::poseidon2::Poseidon2::hash(), but replacing a range check with a bit check,\n// and absorbing in chunks of 3 below.\n#[no_predicates]\npub fn poseidon2_cheaper_variable_hash<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_in_chunks(input, in_len);\n    // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n    // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n    // fixed-length and variable-length hashes do not collide)\n    if in_len != N {\n        sponge.absorb(1);\n    }\n    sponge.squeeze()\n}\n\n// This function is  unconstrained because it is intended to be used in unconstrained context only as\n// in constrained contexts it would be too inefficient.\npub unconstrained fn poseidon2_hash_with_separator_bounded_vec<let N: u32, T>(\n    inputs: BoundedVec<Field, N>,\n    separator: T,\n) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs.get(i));\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    let mut fields = [0; (N + 30) / 31];\n    let mut field_index = 0;\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            fields[field_index] = field_from_bytes(current_field, false);\n            current_field = [0; 31];\n            field_index += 1;\n        }\n    }\n    if field_index != fields.len() {\n        fields[field_index] = field_from_bytes(current_field, false);\n    }\n    poseidon2_hash(fields)\n}\n\n#[test]\nfn poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let sub_chunk_hash = poseidon2_hash_subarray(input, in_len);\n    let fixed_len_hash = poseidon::poseidon2::Poseidon2::hash(fixed_input, fixed_input.len());\n    assert(sub_chunk_hash == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_matches_variable() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let variable_chunk_hash = poseidon2_cheaper_variable_hash(input, in_len);\n    let variable_len_hash = poseidon::poseidon2::Poseidon2::hash(input, in_len);\n    assert(variable_chunk_hash == variable_len_hash);\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = sha256::digest(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result =\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0x3b18c58c739716e76429634a61375c45b3b5cd470c22ab6d3e14cee23dd992);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(\n        AztecAddress::from_field(1),\n        EthAddress::from_field(3),\n        5,\n        2,\n        4,\n    );\n    assert(hash_result == 0xaab2a5828156782b12a1dc6f336e2bc627eb1b9514b02d511f66296990c050);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        L2ToL1Message { recipient: EthAddress::from_field(1), content: 2 }.scope(\n            AztecAddress::from_field(3),\n        ),\n        version,\n        chainId,\n    );\n\n    // The following value was generated by `yarn-project/stdlib/src/hash/hash.test.ts`\n    let hash_from_typescript = 0x0081edf209e087ad31b3fd24263698723d57190bd1d6e9fe056fc0c0a68ee661;\n\n    assert_eq(hash, hash_from_typescript);\n}\n\n#[test]\nunconstrained fn poseidon2_hash_with_separator_bounded_vec_matches_non_bounded_vec_version() {\n    let inputs = BoundedVec::<Field, 4>::from_array([1, 2, 3]);\n    let separator = 42;\n\n    // Hash using bounded vec version\n    let bounded_result = poseidon2_hash_with_separator_bounded_vec(inputs, separator);\n\n    // Hash using regular version\n    let regular_result = poseidon2_hash_with_separator([1, 2, 3], separator);\n\n    // Results should match\n    assert_eq(bounded_result, regular_result);\n}\n","path":"/Users/zac/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.6-patch.1/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr"},"353":{"source":"use utils::derive_serialization_quotes;\n\npub mod utils;\n\n/// Generates the generic parameter declarations for a struct's trait implementation.\n///\n/// This function takes a struct type definition and generates the generic parameter declarations\n/// that go after the `impl` keyword. For example, given a struct with generics `N: u32` and `T`,\n/// it generates `<let N: u32, T>`.\n///\n/// # Parameters\n/// - `s`: The struct type definition to generate generic declarations for\n///\n/// # Returns\n/// A quoted code block containing the generic parameter declarations, or an empty quote if the struct\n/// has no generic parameters\n///\n/// # Example\n/// For a struct defined as:\n/// ```\n/// struct Container<T, let N: u32> {\n///     items: [T; N],\n///     count: u32\n/// }\n/// ```\n///\n/// This function generates:\n/// ```\n/// <let N: u32, T>\n/// ```\ncomptime fn get_generics_declarations(s: TypeDefinition) -> Quoted {\n    let generics = s.generics();\n\n    if generics.len() > 0 {\n        let generics_declarations_items = generics\n            .map(|(name, maybe_integer_typ)| {\n                // The second item in the generics tuple is an Option of an integer type that is Some only if\n                // the generic is numeric.\n                if maybe_integer_typ.is_some() {\n                    // The generic is numeric, so we return a quote defined as e.g. \"let N: u32\"\n                    let integer_type = maybe_integer_typ.unwrap();\n                    quote {let $name: $integer_type}\n                } else {\n                    // The generic is not numeric, so we return a quote containing the name of the generic (e.g. \"T\")\n                    quote {$name}\n                }\n            })\n            .join(quote {,});\n        quote {<$generics_declarations_items>}\n    } else {\n        // The struct doesn't have any generics defined, so we just return an empty quote.\n        quote {}\n    }\n}\n\n/// Generates the `where` clause for a trait implementation that constrains non-numeric generic type parameters.\n///\n/// This function takes a struct type definition and a trait name, and generates a `where` clause that\n/// requires all non-numeric generic type parameters to implement the specified trait.\n///\n/// # Parameters\n/// - `s`: The struct type definition to generate the where clause for\n/// - `trait_name`: The name of the trait that non-numeric generic parameters must implement\n///\n/// # Returns\n/// A quoted code block containing the where clause, or an empty quote if the struct has no non-numeric\n/// generic parameters\n///\n/// # Example\n/// For a struct defined as:\n/// ```\n/// struct Container<T, let N: u32> {\n///     items: [T; N],\n///     count: u32\n/// }\n/// ```\n///\n/// And trait name \"Serialize\", this function generates:\n/// ```\n/// where T: Serialize\n/// ```\ncomptime fn get_where_trait_clause(s: TypeDefinition, trait_name: Quoted) -> Quoted {\n    let generics = s.generics();\n\n    // The second item in the generics tuple is an Option of an integer type that is Some only if the generic is\n    // numeric.\n    let non_numeric_generics =\n        generics.filter(|(_, maybe_integer_typ)| maybe_integer_typ.is_none());\n\n    if non_numeric_generics.len() > 0 {\n        let non_numeric_generics_declarations =\n            non_numeric_generics.map(|(name, _)| quote {$name: $trait_name}).join(quote {,});\n        quote {where $non_numeric_generics_declarations}\n    } else {\n        // There are no non-numeric generics, so we return an empty quote.\n        quote {}\n    }\n}\n\n/// Generates a `Serialize` trait implementation for a struct type.\n///\n/// # Parameters\n/// - `s`: The struct type definition to generate the implementation for\n///\n/// # Returns\n/// A quoted code block containing the trait implementation\n///\n/// # Example\n/// For a struct defined as:\n/// ```\n/// struct Log<N> {\n///     fields: [Field; N],\n///     length: u32\n/// }\n/// ```\n///\n/// This function generates code equivalent to:\n/// ```\n/// impl<let N: u32> Serialize for Log<N> {\n///     let N: u32 = <[Field; N] as Serialize>::N + <u32 as Serialize>::N;\n///\n///     #[inline_always]\n///     fn serialize(self) -> [Field; Self::N] {\n///         let mut serialized_params = [0; _];\n///         let mut offset = 0;\n///\n///         let serialized_member = Serialize::serialize(self.fields);\n///         let serialized_member_len = <[Field; N] as Serialize>::N;\n///         for i in 0..serialized_member_len {\n///             serialized_params[i + offset] = serialized_member[i];\n///         }\n///         offset += serialized_member_len;\n///\n///         let serialized_member = Serialize::serialize(self.length);\n///         let serialized_member_len = <u32 as Serialize>::N;\n///         for i in 0..serialized_member_len {\n///             serialized_params[i + offset] = serialized_member[i];\n///         }\n///         offset += serialized_member_len;\n///\n///         serialized_params\n///     }\n/// }\n/// ```\npub comptime fn derive_serialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let nested_struct = typ.as_data_type().unwrap();\n\n    // We care only about the name and type so we drop the last item of the tuple\n    let params = nested_struct.0.fields(nested_struct.1).map(|(name, typ, _)| (name, typ));\n\n    // Generates the generic parameter declarations (to be placed after the `impl` keyword) and the `where` clause\n    // for the `Serialize` trait.\n    let generics_declarations = get_generics_declarations(s);\n    let where_serialize_clause = get_where_trait_clause(s, quote {Serialize});\n\n    let (function_body, params_len_quote, serialized_params_name) =\n        derive_serialization_quotes(params, true);\n\n    quote {\n        impl$generics_declarations $crate::traits::Serialize for $typ\n            $where_serialize_clause\n        {\n            let N: u32 = $params_len_quote;\n\n            #[inline_always]\n            fn serialize(self) -> [Field; Self::N] {\n                $function_body\n\n                $serialized_params_name\n            }\n        }\n    }\n}\n\n/// Generates a `Deserialize` trait implementation for a given struct `s`.\n///\n/// # Arguments\n/// * `s` - The struct type definition to generate the implementation for\n///\n/// # Returns\n/// A `Quoted` block containing the generated trait implementation\n///\n/// # Requirements\n/// Each struct member type must implement the `Deserialize` trait (it gets used in the generated code).\n///\n/// # Example\n/// For a struct like:\n/// ```\n/// struct MyStruct {\n///     x: AztecAddress,\n///     y: Field,\n/// }\n/// ```\n///\n/// This generates:\n/// ```\n/// impl Deserialize for MyStruct {\n///     let N: u32 = <AztecAddress as Deserialize>::N + <Field as Deserialize>::N;\n///\n///     fn deserialize(serialized: [Field; Self::N]) -> Self {\n///         let mut offset = 0;\n///         let mut member_fields = [0; <AztecAddress as Deserialize>::N];\n///         for i in 0..<AztecAddress as Deserialize>::N {\n///             member_fields[i] = serialized[i + offset];\n///         }\n///         let x = <AztecAddress as Deserialize>::deserialize(member_fields);\n///         offset += <AztecAddress as Deserialize>::N;\n///\n///         let mut member_fields = [0; <Field as Deserialize>::N];\n///         for i in 0..<Field as Deserialize>::N {\n///             member_fields[i] = serialized[i + offset];\n///         }\n///         let y = <Field as Deserialize>::deserialize(member_fields);\n///         offset += <Field as Deserialize>::N;\n///\n///         Self { x, y }\n///     }\n/// }\n/// ```\npub(crate) comptime fn derive_deserialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let nested_struct = typ.as_data_type().unwrap();\n    let params = nested_struct.0.fields(nested_struct.1);\n\n    // Generates the generic parameter declarations (to be placed after the `impl` keyword) and the `where` clause\n    // for the `Deserialize` trait.\n    let generics_declarations = get_generics_declarations(s);\n    let where_deserialize_clause = get_where_trait_clause(s, quote {Deserialize});\n\n    // The following will give us:\n    // <type_of_struct_member_1 as Deserialize>::N + <type_of_struct_member_2 as Deserialize>::N + ...\n    // (or 0 if the struct has no members)\n    let right_hand_side_of_definition_of_n = if params.len() > 0 {\n        params\n            .map(|(_, param_type, _): (Quoted, Type, Quoted)| {\n                quote {\n            <$param_type as $crate::traits::Deserialize>::N\n        }\n            })\n            .join(quote {+})\n    } else {\n        quote {0}\n    };\n\n    // For structs containing a single member, we can enhance performance by directly deserializing the input array,\n    // bypassing the need for loop-based array construction. While this optimization yields significant benefits in\n    // Brillig where the loops are expected to not be optimized, it is not relevant in ACIR where the loops are\n    // expected to be optimized away.\n    let function_body = if params.len() > 1 {\n        // This generates deserialization code for each struct member and concatenates them together.\n        let deserialization_of_struct_members = params\n            .map(|(param_name, param_type, _): (Quoted, Type, Quoted)| {\n                quote {\n                    let mut member_fields = [0; <$param_type as Deserialize>::N];\n                    for i in 0..<$param_type as Deserialize>::N {\n                        member_fields[i] = serialized[i + offset];\n                    }\n                    let $param_name = <$param_type as Deserialize>::deserialize(member_fields);\n                    offset += <$param_type as Deserialize>::N;\n                }\n            })\n            .join(quote {});\n\n        // We join the struct member names with a comma to be used in the `Self { ... }` syntax\n        // This will give us e.g. `a, b, c` for a struct with three fields named `a`, `b`, and `c`.\n        let struct_members = params\n            .map(|(param_name, _, _): (Quoted, Type, Quoted)| quote { $param_name })\n            .join(quote {,});\n\n        quote {\n            let mut offset = 0;\n\n            $deserialization_of_struct_members\n\n            Self { $struct_members }\n        }\n    } else if params.len() == 1 {\n        let param_name = params[0].0;\n        quote {\n            Self { $param_name: $crate::traits::Deserialize::deserialize(serialized) }\n        }\n    } else {\n        quote {\n            Self {}\n        }\n    };\n\n    quote {\n        impl$generics_declarations $crate::traits::Deserialize for $typ\n            $where_deserialize_clause\n        {\n            let N: u32 = $right_hand_side_of_definition_of_n;\n\n            #[inline_always]\n            fn deserialize(serialized: [Field; Self::N]) -> Self {\n                $function_body\n            }\n        }\n    }\n}\n\n/// Generates a `Packable` trait implementation for a given struct `s`.\n///\n/// # Arguments\n/// * `s` - The struct type definition to generate the implementation for\n///\n/// # Returns\n/// A `Quoted` block containing the generated trait implementation\n///\n/// # Requirements\n/// Each struct member type must implement the `Packable` trait (it gets used in the generated code).\n///\n/// # Example\n/// For a struct like:\n/// ```\n/// struct MyStruct {\n///     x: AztecAddress,\n///     y: Field,\n/// }\n/// ```\n///\n/// This generates:\n/// ```\n/// impl Packable for MyStruct {\n///     let N: u32 = 2;\n///\n///     fn pack(self) -> [Field; 2] {\n///         let mut result: [Field; 2] = [0_Field; 2];\n///         let mut offset: u32 = 0_u32;\n///         let packed_member: [Field; 1] = self.x.pack();\n///         let packed_member_len: u32 = <Field as Packable>::N;\n///         for i in 0_u32..packed_member_len {\n///             {\n///                 result[i + offset] = packed_member[i];\n///             }\n///         }\n///         offset = offset + packed_member_len;\n///         let packed_member: [Field; 1] = self.y.pack();\n///         let packed_member_len: u32 = <Field as Packable>::N;\n///         for i in 0_u32..packed_member_len {\n///             {\n///                 result[i + offset] = packed_member[i];\n///             }\n///         }\n///         offset = offset + packed_member_len;\n///         result\n///     }\n///\n///     fn unpack(packed: [Field; 2]) -> Self {\n///         let mut offset: u32 = 0_u32;\n///         let mut member_fields: [Field; 1] = [0_Field; 1];\n///         for i in 0_u32..<AztecAddress as Packable>::N {\n///             member_fields[i] = packed[i + offset];\n///         }\n///         let x: AztecAddress = <AztecAddress as Packable>::unpack(member_fields);\n///         offset = offset + <AztecAddress as Packable>::N;\n///         let mut member_fields: [Field; 1] = [0_Field; 1];\n///         for i in 0_u32..<Field as Packable>::N {\n///             member_fields[i] = packed[i + offset];\n///         }\n///         let y: Field = <Field as Packable>::unpack(member_fields);\n///         offset = offset + <Field as Packable>::N;\n///         Self { x: x, y: y }\n///     }\n/// }\n/// ```\npub comptime fn derive_packable(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let nested_struct = typ.as_data_type().unwrap();\n    let params = nested_struct.0.fields(nested_struct.1);\n\n    // Generates the generic parameter declarations (to be placed after the `impl` keyword) and the `where` clause\n    // for the `Packable` trait.\n    let generics_declarations = get_generics_declarations(s);\n    let where_packable_clause = get_where_trait_clause(s, quote {Packable});\n\n    // The following will give us:\n    // <type_of_struct_member_1 as Packable>::N + <type_of_struct_member_2 as Packable>::N + ...\n    // (or 0 if the struct has no members)\n    let right_hand_side_of_definition_of_n = if params.len() > 0 {\n        params\n            .map(|(_, param_type, _): (Quoted, Type, Quoted)| {\n                quote {\n            <$param_type as $crate::traits::Packable>::N\n        }\n            })\n            .join(quote {+})\n    } else {\n        quote {0}\n    };\n\n    // For structs containing a single member, we can enhance performance by directly returning the packed member,\n    // bypassing the need for loop-based array construction. While this optimization yields significant benefits in\n    // Brillig where the loops are expected to not be optimized, it is not relevant in ACIR where the loops are\n    // expected to be optimized away.\n    let pack_function_body = if params.len() > 1 {\n        // For multiple struct members, generate packing code that:\n        // 1. Packs each member\n        // 2. Copies the packed fields into the result array at the correct offset\n        // 3. Updates the offset for the next member\n        let packing_of_struct_members = params\n            .map(|(param_name, param_type, _): (Quoted, Type, Quoted)| {\n                quote {\n                    let packed_member = $crate::traits::Packable::pack(self.$param_name);\n                    let packed_member_len = <$param_type as $crate::traits::Packable>::N;\n                    for i in 0..packed_member_len {\n                        result[i + offset] = packed_member[i];\n                    }\n                    offset += packed_member_len;\n                }\n            })\n            .join(quote {});\n\n        quote {\n            let mut result = [0; Self::N];\n            let mut offset = 0;\n\n            $packing_of_struct_members\n\n            result\n        }\n    } else if params.len() == 1 {\n        let param_name = params[0].0;\n        quote {\n            $crate::traits::Packable::pack(self.$param_name)\n        }\n    } else {\n        quote {\n            [0; Self::N]\n        }\n    };\n\n    // For structs containing a single member, we can enhance performance by directly unpacking the input array,\n    // bypassing the need for loop-based array construction. While this optimization yields significant benefits in\n    // Brillig where the loops are expected to not be optimized, it is not relevant in ACIR where the loops are\n    // expected to be optimized away.\n    let unpack_function_body = if params.len() > 1 {\n        // For multiple struct members, generate unpacking code that:\n        // 1. Unpacks each member\n        // 2. Copies packed fields into member array at correct offset\n        // 3. Updates offset for next member\n        let unpacking_of_struct_members = params\n            .map(|(param_name, param_type, _): (Quoted, Type, Quoted)| {\n                quote {\n                    let mut member_fields = [0; <$param_type as $crate::traits::Packable>::N];\n                    for i in 0..<$param_type as $crate::traits::Packable>::N {\n                        member_fields[i] = packed[i + offset];\n                    }\n                    let $param_name = <$param_type as $crate::traits::Packable>::unpack(member_fields);\n                    offset += <$param_type as $crate::traits::Packable>::N;\n                }\n            })\n            .join(quote {});\n\n        // We join the struct member names with a comma to be used in the `Self { ... }` syntax\n        let struct_members = params\n            .map(|(param_name, _, _): (Quoted, Type, Quoted)| quote { $param_name })\n            .join(quote {,});\n\n        quote {\n            let mut offset = 0;\n            $unpacking_of_struct_members\n            Self { $struct_members }\n        }\n    } else if params.len() == 1 {\n        let param_name = params[0].0;\n        quote {\n            Self { $param_name: $crate::traits::Packable::unpack(packed) }\n        }\n    } else {\n        quote {\n            Self {}\n        }\n    };\n\n    quote {\n        impl$generics_declarations $crate::traits::Packable for $typ\n            $where_packable_clause\n        {\n            let N: u32 = $right_hand_side_of_definition_of_n;\n\n            #[inline_always]\n            fn pack(self) -> [Field; Self::N] {\n                $pack_function_body\n            }\n\n            #[inline_always]\n            fn unpack(packed: [Field; Self::N]) -> Self {\n                $unpack_function_body\n            }\n        }\n    }\n}\n\nmod test {\n    use crate::traits::{Deserialize, Packable, Serialize};\n\n    #[derive(Deserialize, Eq, Packable, Serialize)]\n    pub struct Empty {}\n\n    #[derive(Deserialize, Eq, Packable, Serialize)]\n    pub struct Smol {\n        a: Field,\n        b: Field,\n    }\n\n    #[derive(Deserialize, Eq, Serialize)]\n    pub struct HasArray {\n        a: [Field; 2],\n        b: bool,\n    }\n\n    #[derive(Deserialize, Eq, Serialize)]\n    pub struct Fancier {\n        a: Smol,\n        b: [Field; 2],\n        c: [u8; 3],\n        d: str<16>,\n    }\n\n    #[derive(Deserialize, Eq, Packable, Serialize)]\n    pub struct HasArrayWithGenerics<T, let N: u32> {\n        pub fields: [T; N],\n        pub length: u32,\n    }\n\n    #[test]\n    fn serde_on_empty() {\n        let original = Empty {};\n        let serialized = original.serialize();\n        assert_eq(serialized, [], \"Serialized does not match empty array\");\n        let deserialized = Empty::deserialize(serialized);\n        assert_eq(deserialized, original, \"Deserialized does not match original\");\n    }\n\n    #[test]\n    fn packable_on_empty() {\n        let original = Empty {};\n        let packed = original.pack();\n        assert_eq(packed, [], \"Packed does not match empty array\");\n        let unpacked = Empty::unpack(packed);\n        assert_eq(unpacked, original, \"Unpacked does not match original\");\n    }\n\n    #[test]\n    fn serde_on_smol() {\n        let smol = Smol { a: 1, b: 2 };\n        let serialized = smol.serialize();\n        assert(serialized == [1, 2], serialized);\n        let deserialized = Smol::deserialize(serialized);\n        assert(deserialized == smol);\n\n        // None of the struct members implements the `Packable` trait so the packed and serialized data should be the same\n        let packed = smol.pack();\n        assert_eq(packed, serialized, \"Packed does not match serialized\");\n    }\n\n    #[test]\n    fn serde_on_has_array() {\n        let has_array = HasArray { a: [1, 2], b: true };\n        let serialized = has_array.serialize();\n        assert(serialized == [1, 2, 1], serialized);\n        let deserialized = HasArray::deserialize(serialized);\n        assert(deserialized == has_array);\n    }\n\n    #[test]\n    fn serde_on_fancier() {\n        let fancier =\n            Fancier { a: Smol { a: 1, b: 2 }, b: [0, 1], c: [1, 2, 3], d: \"metaprogramming!\" };\n        let serialized = fancier.serialize();\n        assert(\n            serialized\n                == [\n                    1, 2, 0, 1, 1, 2, 3, 0x6d, 0x65, 0x74, 0x61, 0x70, 0x72, 0x6f, 0x67, 0x72, 0x61,\n                    0x6d, 0x6d, 0x69, 0x6e, 0x67, 0x21,\n                ],\n            serialized,\n        );\n        let deserialized = Fancier::deserialize(serialized);\n        assert(deserialized == fancier);\n    }\n\n    #[test]\n    fn serde_on_contains_array_with_generics() {\n        let struct_with_array_of_generics = HasArrayWithGenerics { fields: [1, 2, 3], length: 3 };\n        let serialized = struct_with_array_of_generics.serialize();\n        assert(serialized == [1, 2, 3, 3], serialized);\n        let deserialized = HasArrayWithGenerics::deserialize(serialized);\n        assert(deserialized == struct_with_array_of_generics);\n    }\n\n    #[test]\n    fn packable_on_contains_array_with_generics() {\n        let struct_with_array_of_generics = HasArrayWithGenerics { fields: [1, 2, 3], length: 3 };\n        let packed = struct_with_array_of_generics.pack();\n        assert(packed == [1, 2, 3, 3], packed);\n\n        let unpacked = HasArrayWithGenerics::unpack(packed);\n        assert(unpacked == struct_with_array_of_generics);\n    }\n\n}\n","path":"/Users/zac/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.6-patch.1/noir-projects/noir-protocol-circuits/crates/types/src/meta/mod.nr"},"354":{"source":"/// Generates serialization code for a list of parameters and the total length of the serialized array\n///\n/// # Parameters\n/// - `params`: A list of (name, type) tuples to serialize\n/// - `use_self_prefix`: If true, parameters are accessed as `self.$param_name` (for struct members).\n///                      If false, parameters are accessed directly as `$param_name` (for function parameters).\n///\n/// # Returns\n/// A tuple containing:\n/// - Quoted code that serializes the parameters into an array named `serialized_params`\n/// - Quoted code that evaluates to the total length of the serialized array\n/// - Quoted code containing the name of the serialized array\npub comptime fn derive_serialization_quotes(\n    params: [(Quoted, Type)],\n    use_self_prefix: bool,\n) -> (Quoted, Quoted, Quoted) {\n    let prefix_quote = if use_self_prefix {\n        quote { self. }\n    } else {\n        quote {}\n    };\n\n    let params_len_quote = get_params_len_quote(params);\n    let serialized_params_name = quote { serialized_params };\n\n    let body = if params.len() == 0 {\n        quote {\n            let $serialized_params_name: [Field; 0] = [];\n        }\n    } else if params.len() == 1 {\n        // When we have only a single parameter on the input, we can enhance performance by directly returning\n        // the serialized member, bypassing the need for loop-based array construction. While this optimization yields\n        // significant benefits in Brillig where the loops are expected to not be optimized, it is not relevant in ACIR\n        // where the loops are expected to be optimized away.\n\n        let param_name = params[0].0;\n        quote {\n            let $serialized_params_name = $crate::traits::Serialize::serialize($prefix_quote$param_name);\n        }\n    } else {\n        // For multiple struct members, generate serialization code that:\n        // 1. Serializes each member\n        // 2. Copies the serialized fields into the serialize array at the correct offset\n        // 3. Updates the offset for the next member\n        let serialization_of_struct_members = params\n            .map(|(param_name, param_type): (Quoted, Type)| {\n                quote {\n                let serialized_member = $crate::traits::Serialize::serialize($prefix_quote$param_name);\n                let serialized_member_len = <$param_type as $crate::traits::Serialize>::N;\n                for i in 0..serialized_member_len {\n                    $serialized_params_name[i + offset] = serialized_member[i];\n                }\n                offset += serialized_member_len;\n            }\n            })\n            .join(quote {});\n\n        quote {\n            let mut $serialized_params_name = [0; $params_len_quote];\n            let mut offset = 0;\n\n            $serialization_of_struct_members\n        }\n    };\n\n    (body, params_len_quote, serialized_params_name)\n}\n\n/// Generates a quoted expression that computes the total serialized length of function parameters.\n///\n/// # Parameters\n/// * `params` - An array of tuples where each tuple contains a quoted parameter name and its Type. The type needs\n///              to implement the Serialize trait.\n///\n/// # Returns\n/// A quoted expression that evaluates to:\n/// * `0` if there are no parameters\n/// * `(<type1 as Serialize>::N + <type2 as Serialize>::N + ...)` for one or more parameters\npub comptime fn get_params_len_quote(params: [(Quoted, Type)]) -> Quoted {\n    if params.len() == 0 {\n        quote { 0 }\n    } else {\n        let params_quote_without_parentheses = params\n            .map(|(_, param_type): (Quoted, Type)| {\n                quote {\n                    <$param_type as $crate::traits::Serialize>::N\n                }\n            })\n            .join(quote {+});\n        quote { ($params_quote_without_parentheses) }\n    }\n}\n","path":"/Users/zac/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.6-patch.1/noir-projects/noir-protocol-circuits/crates/types/src/meta/utils.nr"},"356":{"source":"use crate::constants::TWO_POW_64;\nuse crate::traits::{Deserialize, Serialize};\nuse std::meta::derive;\n// NB: This is a clone of noir/noir-repo/noir_stdlib/src/hash/poseidon2.nr\n// It exists as we sometimes need to perform custom absorption, but the stdlib version\n// has a private absorb() method (it's also designed to just be a hasher)\n// Can be removed when standalone noir poseidon lib exists: See noir#6679\n\ncomptime global RATE: u32 = 3;\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct Poseidon2Sponge {\n    pub cache: [Field; 3],\n    pub state: [Field; 4],\n    pub cache_size: u32,\n    pub squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2Sponge {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2Sponge::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2Sponge {\n        let mut result =\n            Poseidon2Sponge { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = std::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    pub fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    pub fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let iv: Field = (in_len as Field) * TWO_POW_64;\n        let mut sponge = Poseidon2Sponge::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n","path":"/Users/zac/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.6-patch.1/noir-projects/noir-protocol-circuits/crates/types/src/poseidon2.nr"},"368":{"source":"use crate::{hash::poseidon2_hash, traits::ToField};\n\npub fn derive_storage_slot_in_map<K>(storage_slot: Field, key: K) -> Field\nwhere\n    K: ToField,\n{\n    poseidon2_hash([storage_slot, key.to_field()])\n}\n\nmod test {\n    use crate::{address::AztecAddress, storage::map::derive_storage_slot_in_map, traits::FromField};\n\n    #[test]\n    fn test_derive_storage_slot_in_map_matches_typescript() {\n        let map_slot = 0x132258fb6962c4387ba659d9556521102d227549a386d39f0b22d1890d59c2b5;\n        let key = AztecAddress::from_field(\n            0x302dbc2f9b50a73283d5fb2f35bc01eae8935615817a0b4219a057b2ba8a5a3f,\n        );\n\n        let slot = derive_storage_slot_in_map(map_slot, key);\n\n        // The following value was generated by `map_slot.test.ts`\n        let slot_from_typescript =\n            0x15b9fe39449affd8b377461263e9d2b610b9ad40580553500b4e41d9cbd887ac;\n\n        assert_eq(slot, slot_from_typescript);\n    }\n}\n","path":"/Users/zac/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.6-patch.1/noir-projects/noir-protocol-circuits/crates/types/src/storage/map.nr"},"384":{"source":"use crate::meta::{derive_deserialize, derive_packable, derive_serialize};\nuse crate::utils::field::field_from_bytes;\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic\n// if a value can actually be zero. In a future refactor, we can\n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\npub trait Empty: Eq {\n    fn empty() -> Self;\n\n    fn is_empty(self) -> bool {\n        self.eq(Self::empty())\n    }\n\n    // Requires this Noir fix: https://github.com/noir-lang/noir/issues/9002\n    // fn assert_not_empty<let U: u32>(self, msg: str<U>) { // This msg version was failing with weird compiler errors.\n    //     // We provide a default impl but it's likely inefficient.\n    //     // The reason we include this function is because there's a lot of\n    //     // opportunity for optimisation on a per-struct basis.\n    //     // You only need to show one element is not empty to know that the whole thing\n    //     // is not empty.\n    //     // If you know an element of your struct which should always be nonempty,\n    //     // you can write an impl that solely checks that that element is nonempty.\n    //     assert(!self.is_empty(), msg);\n    // }\n\n    // This default impl is overwritten by types like arrays, because there's a much\n    // more efficient approach.\n    fn assert_empty<let S: u32>(self, msg: str<S>) {\n        assert(self.is_empty(), msg);\n    }\n}\n\nimpl Empty for Field {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl Empty for bool {\n    #[inline_always]\n    fn empty() -> Self {\n        false\n    }\n}\n\nimpl Empty for u1 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u8 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u16 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u32 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u64 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u128 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl<T, let N: u32> Empty for [T; N]\nwhere\n    T: Empty,\n{\n    #[inline_always]\n    fn empty() -> Self {\n        [T::empty(); N]\n    }\n\n    fn is_empty(self) -> bool {\n        self.all(|elem| elem.is_empty())\n    }\n\n    fn assert_empty<let S: u32>(self, msg: str<S>) -> () {\n        self.for_each(|elem| elem.assert_empty(msg))\n    }\n}\n\nimpl<T> Empty for [T]\nwhere\n    T: Empty,\n{\n    #[inline_always]\n    fn empty() -> Self {\n        [T::empty()]\n    }\n\n    fn is_empty(self) -> bool {\n        self.all(|elem| elem.is_empty())\n    }\n\n    fn assert_empty<let S: u32>(self, msg: str<S>) -> () {\n        self.for_each(|elem| elem.assert_empty(msg))\n    }\n}\nimpl<A, B> Empty for (A, B)\nwhere\n    A: Empty,\n    B: Empty,\n{\n    #[inline_always]\n    fn empty() -> Self {\n        (A::empty(), B::empty())\n    }\n}\n\nimpl<T> Empty for Option<T>\nwhere\n    T: Eq,\n{\n    #[inline_always]\n    fn empty() -> Self {\n        Option::none()\n    }\n}\n\n// pub fn is_empty<T>(item: T) -> bool\n// where\n//     T: Empty,\n// {\n//     item.eq(T::empty())\n// }\n\n// pub fn is_empty_array<T, let N: u32>(array: [T; N]) -> bool\n// where\n//     T: Empty,\n// {\n//     array.all(|elem| is_empty(elem))\n// }\n\n// pub fn assert_empty<T>(item: T) -> ()\n// where\n//     T: Empty,\n// {\n//     assert(item.eq(T::empty()))\n// }\n\n// pub fn assert_empty_array<T, let N: u32>(array: [T; N]) -> ()\n// where\n//     T: Empty,\n// {\n//     // A cheaper option than `is_empty_array` for if you don't need to gracefully\n//     // handle a bool result.\n//     // Avoids the `&` operator of `is_empty_array`'s `.all()` call.\n//     for i in 0..N {\n//         assert(is_empty(array[i]));\n//     }\n// }\n\npub trait Hash {\n    fn hash(self) -> Field;\n}\n\npub trait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u1 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u8 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u16 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u32 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u64 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u128 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl<let N: u32> ToField for str<N> {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\npub trait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value != 0\n    }\n}\nimpl FromField for u1 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u1\n    }\n}\nimpl FromField for u8 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u8\n    }\n}\nimpl FromField for u16 {\n    fn from_field(value: Field) -> Self {\n        value as u16\n    }\n}\nimpl FromField for u32 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u32\n    }\n}\nimpl FromField for u64 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u64\n    }\n}\nimpl FromField for u128 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u128\n    }\n}\n\n// docs:start:serialize\n/// Trait for serializing Noir types into arrays of Fields.\n///\n/// An implementation of the Serialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait (and Deserialize) are\n/// typically used to communicate between Noir and TypeScript (via oracles and function arguments).\n///\n/// # On Following Noir's Intrinsic Serialization\n/// When calling a Noir function from TypeScript (TS), first the function arguments are serialized into an array\n/// of fields. This array is then included in the initial witness. Noir's intrinsic serialization is then used\n/// to deserialize the arguments from the witness. When the same Noir function is called from Noir this Serialize trait\n/// is used instead of the serialization in TS. For this reason we need to have a match between TS serialization,\n/// Noir's intrinsic serialization and the implementation of this trait. If there is a mismatch, the function calls\n/// fail with an arguments hash mismatch error message.\n///\n/// # Associated Constants\n/// * `N` - The length of the output Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let N: u32> Serialize for str<N> {\n///     let N: u32 = N;\n///\n///     fn serialize(self) -> [Field; Self::N] {\n///         let bytes = self.as_bytes();\n///         let mut fields = [0; Self::N];\n///         for i in 0..bytes.len() {\n///             fields[i] = bytes[i] as Field;  // Each byte gets its own Field\n///         }\n///         fields\n///     }\n/// }\n/// ```\n#[derive_via(derive_serialize)]\npub trait Serialize {\n    let N: u32;\n\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<let M: u32> Serialize for str<M> {\n    let N: u32 = M;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        let bytes = self.as_bytes();\n        let mut fields = [0; Self::N];\n        for i in 0..bytes.len() {\n            fields[i] = bytes[i] as Field;\n        }\n        fields\n    }\n}\n\n/// Implementation of Deserialize for BoundedVec.\n///\n/// This implementation deserializes a BoundedVec from an array of Fields. The array contains:\n/// 1. The serialized items, each taking up T::N Fields\n/// 2. The length of the BoundedVec as the last Field\n///\n/// # Type Parameters\n/// * `T` - The type of items stored in the BoundedVec, must implement Deserialize\n/// * `M` - The maximum length of the BoundedVec\n///\n/// # Fields Array Layout\n/// [item1_field1, item1_field2, ..., item2_field1, item2_field2, ..., length]\n/// Where:\n/// - itemN_fieldM: The M-th Field of the N-th item (T::N Fields per item)\n/// - length: The number of items in the BoundedVec (1 Field)\n///\n/// Total length N = T::N * M + 1, where:\n/// - T::N is the number of Fields needed to deserialize one item\n/// - M is the maximum length of the BoundedVec\n/// - +1 is for storing the length\n///\n/// # Note\n/// Not deriving this because it's not supported to call derive_deserialize on a \"remote\" struct (and it will never\n/// be supported).\nimpl<T, let M: u32> Deserialize for BoundedVec<T, M>\nwhere\n    T: Deserialize,\n{\n    let N: u32 = <T as Deserialize>::N * M + 1;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        let mut new_bounded_vec: BoundedVec<T, M> = BoundedVec::new();\n\n        // Length is stored in the last field as we need to match intrinsic Noir serialization and the `len` struct\n        // field is after `storage` struct field (see `bounded_vec.nr` in noir-stdlib)\n        let len = fields[<T as Deserialize>::N * M] as u32;\n\n        for i in 0..len {\n            let mut nested_fields = [0; <T as Deserialize>::N];\n            for j in 0..<T as Deserialize>::N {\n                nested_fields[j] = fields[i * <T as Deserialize>::N + j];\n            }\n\n            let item = T::deserialize(nested_fields);\n            new_bounded_vec.push(item);\n        }\n\n        new_bounded_vec\n    }\n}\n\n// This may cause issues if used as program input, because noir disallows empty arrays for program input.\n// I think this is okay because I don't foresee a unit type being used as input. But leaving this comment as a hint\n// if someone does run into this in the future.\nimpl Deserialize for () {\n    let N: u32 = 0;\n\n    fn deserialize(_fields: [Field; Self::N]) -> Self {\n        ()\n    }\n}\n\n// Note: Not deriving this because it's not supported to call derive_serialize on a \"remote\" struct (and it will never\n// be supported).\nimpl<T, let M: u32> Serialize for BoundedVec<T, M>\nwhere\n    T: Serialize,\n{\n    let N: u32 = <T as Serialize>::N * M + 1; // +1 for the length of the BoundedVec\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        let mut fields = [0; Self::N];\n\n        let storage = self.storage();\n\n        for i in 0..M {\n            let serialized_item = storage[i].serialize();\n\n            for j in 0..<T as Serialize>::N {\n                fields[i * <T as Serialize>::N + j] = serialized_item[j];\n            }\n        }\n\n        // Length is stored in the last field as we need to match intrinsic Noir serialization and the `len` struct\n        // field is after `storage` struct field (see `bounded_vec.nr` in noir-stdlib)\n        fields[<T as Serialize>::N * M] = self.len() as Field;\n\n        fields\n    }\n}\n\n// docs:start:deserialize\n/// Trait for deserializing Noir types from arrays of Fields.\n///\n/// An implementation of the Deserialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait is typically used when\n/// deserializing return values from function calls in Noir. Since the same function could be called from TypeScript\n/// (TS), in which case the TS deserialization would get used, we need to have a match between the 2.\n///\n/// # Associated Constants\n/// * `N` - The length of the input Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let M: u32> Deserialize for str<M> {\n///     let N: u32 = M;\n///\n///     #[inline_always]\n///     fn deserialize(fields: [Field; Self::N]) -> Self {\n///         str::<Self::N>::from(fields.map(|value| value as u8))\n///     }\n/// }\n/// ```\n#[derive_via(derive_deserialize)]\npub trait Deserialize {\n    let N: u32;\n\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl<let M: u32> Deserialize for str<M> {\n    let N: u32 = M;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        str::<Self::N>::from(fields.map(|value| value as u8))\n    }\n}\n\n/// Trait for efficiently packing and unpacking Noir types into and from arrays of Fields.\n///\n/// The `Packable` trait allows types to be serialized and deserialized with a focus on minimizing the size of\n/// the resulting Field array. This trait is used when storage efficiency is critical (e.g. when storing data\n/// in the contract's public storage).\n///\n/// # Associated Constants\n/// * `N` - The length of the Field array, known at compile time\n#[derive_via(derive_packable)]\npub trait Packable {\n    let N: u32;\n\n    /// Packs the current value into a compact array of `Field` elements.\n    fn pack(self) -> [Field; N];\n\n    /// Unpacks a compact array of `Field` elements into the original value.\n    fn unpack(fields: [Field; N]) -> Self;\n}\n\n#[test]\nunconstrained fn bounded_vec_serialization() {\n    // Test empty BoundedVec\n    let empty_vec: BoundedVec<Field, 3> = BoundedVec::from_array([]);\n    let serialized = empty_vec.serialize();\n    let deserialized = BoundedVec::<Field, 3>::deserialize(serialized);\n    assert_eq(empty_vec, deserialized);\n    assert_eq(deserialized.len(), 0);\n\n    // Test partially filled BoundedVec\n    let partial_vec: BoundedVec<[u32; 2], 3> = BoundedVec::from_array([[1, 2]]);\n    let serialized = partial_vec.serialize();\n    let deserialized = BoundedVec::<[u32; 2], 3>::deserialize(serialized);\n    assert_eq(partial_vec, deserialized);\n    assert_eq(deserialized.len(), 1);\n    assert_eq(deserialized.get(0), [1, 2]);\n\n    // Test full BoundedVec\n    let full_vec: BoundedVec<[u32; 2], 3> = BoundedVec::from_array([[1, 2], [3, 4], [5, 6]]);\n    let serialized = full_vec.serialize();\n    let deserialized = BoundedVec::<[u32; 2], 3>::deserialize(serialized);\n    assert_eq(full_vec, deserialized);\n    assert_eq(deserialized.len(), 3);\n    assert_eq(deserialized.get(0), [1, 2]);\n    assert_eq(deserialized.get(1), [3, 4]);\n    assert_eq(deserialized.get(2), [5, 6]);\n}\n","path":"/Users/zac/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.6-patch.1/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr"},"386":{"source":"use crate::traits::Packable;\n\nglobal BOOL_PACKED_LEN: u32 = 1;\nglobal U8_PACKED_LEN: u32 = 1;\nglobal U16_PACKED_LEN: u32 = 1;\nglobal U32_PACKED_LEN: u32 = 1;\nglobal U64_PACKED_LEN: u32 = 1;\nglobal U128_PACKED_LEN: u32 = 1;\nglobal FIELD_PACKED_LEN: u32 = 1;\nglobal I8_PACKED_LEN: u32 = 1;\nglobal I16_PACKED_LEN: u32 = 1;\nglobal I32_PACKED_LEN: u32 = 1;\nglobal I64_PACKED_LEN: u32 = 1;\n\nimpl Packable for bool {\n    let N: u32 = BOOL_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> bool {\n        (fields[0] as u1) != 0\n    }\n}\n\nimpl Packable for u8 {\n    let N: u32 = U8_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Packable for u16 {\n    let N: u32 = U16_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Packable for u32 {\n    let N: u32 = U32_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Packable for u64 {\n    let N: u32 = U64_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Packable for u128 {\n    let N: u32 = U128_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Packable for Field {\n    let N: u32 = FIELD_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Packable for i8 {\n    let N: u32 = I8_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as u8 as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u8 as i8\n    }\n}\n\nimpl Packable for i16 {\n    let N: u32 = I16_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as u16 as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u16 as i16\n    }\n}\n\nimpl Packable for i32 {\n    let N: u32 = I32_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as u32 as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u32 as i32\n    }\n}\n\nimpl Packable for i64 {\n    let N: u32 = I64_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as u64 as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u64 as i64\n    }\n}\n\nimpl<T, let M: u32> Packable for [T; M]\nwhere\n    T: Packable,\n{\n    let N: u32 = M * <T as Packable>::N;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        let mut result: [Field; Self::N] = std::mem::zeroed();\n        for i in 0..M {\n            let serialized = self[i].pack();\n            for j in 0..<T as Packable>::N {\n                result[i * <T as Packable>::N + j] = serialized[j];\n            }\n        }\n        result\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; M] = std::mem::zeroed();\n        reader.read_struct_array::<T, <T as Packable>::N, M>(Packable::unpack, result)\n    }\n}\n\n#[test]\nfn test_u16_packing() {\n    let a: u16 = 10;\n    assert_eq(a, u16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i8_packing() {\n    let a: i8 = -10;\n    assert_eq(a, i8::unpack(a.pack()));\n}\n\n#[test]\nfn test_i16_packing() {\n    let a: i16 = -10;\n    assert_eq(a, i16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i32_packing() {\n    let a: i32 = -10;\n    assert_eq(a, i32::unpack(a.pack()));\n}\n\n#[test]\nfn test_i64_packing() {\n    let a: i64 = -10;\n    assert_eq(a, i64::unpack(a.pack()));\n}\n","path":"/Users/zac/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.6-patch.1/noir-projects/noir-protocol-circuits/crates/types/src/type_packing.nr"},"387":{"source":"use crate::traits::{Deserialize, Serialize};\n\nglobal U1_SERIALIZED_LEN: u32 = 1;\nglobal BOOL_SERIALIZED_LEN: u32 = 1;\nglobal U8_SERIALIZED_LEN: u32 = 1;\nglobal U16_SERIALIZED_LEN: u32 = 1;\nglobal U32_SERIALIZED_LEN: u32 = 1;\nglobal U64_SERIALIZED_LEN: u32 = 1;\nglobal U128_SERIALIZED_LEN: u32 = 1;\nglobal FIELD_SERIALIZED_LEN: u32 = 1;\nglobal I8_SERIALIZED_LEN: u32 = 1;\nglobal I16_SERIALIZED_LEN: u32 = 1;\nglobal I32_SERIALIZED_LEN: u32 = 1;\nglobal I64_SERIALIZED_LEN: u32 = 1;\n\nimpl Serialize for bool {\n    let N: u32 = BOOL_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for bool {\n    let N: u32 = BOOL_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> bool {\n        fields[0] != 0\n    }\n}\n\nimpl Serialize for u1 {\n    let N: u32 = U1_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u1 {\n    let N: u32 = U1_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u1\n    }\n}\n\nimpl Serialize for u8 {\n    let N: u32 = U8_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u8 {\n    let N: u32 = U8_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize for u16 {\n    let N: u32 = U16_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u16 {\n    let N: u32 = U16_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Serialize for u32 {\n    let N: u32 = U32_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u32 {\n    let N: u32 = U32_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize for u64 {\n    let N: u32 = U64_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u64 {\n    let N: u32 = U64_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize for u128 {\n    let N: u32 = U128_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u128 {\n    let N: u32 = U128_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Serialize for Field {\n    let N: u32 = FIELD_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self]\n    }\n}\n\nimpl Deserialize for Field {\n    let N: u32 = FIELD_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Serialize for i8 {\n    let N: u32 = I8_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as u8 as Field]\n    }\n}\n\nimpl Deserialize for i8 {\n    let N: u32 = I8_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u8 as i8\n    }\n}\n\nimpl Serialize for i16 {\n    let N: u32 = I16_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as u16 as Field]\n    }\n}\n\nimpl Deserialize for i16 {\n    let N: u32 = I16_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u16 as i16\n    }\n}\n\nimpl Serialize for i32 {\n    let N: u32 = I32_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as u32 as Field]\n    }\n}\n\nimpl Deserialize for i32 {\n    let N: u32 = I32_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u32 as i32\n    }\n}\n\nimpl Serialize for i64 {\n    let N: u32 = I64_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as u64 as Field]\n    }\n}\n\nimpl Deserialize for i64 {\n    let N: u32 = I64_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u64 as i64\n    }\n}\n\nimpl<T, let M: u32> Serialize for [T; M]\nwhere\n    T: Serialize,\n{\n    let N: u32 = <T as Serialize>::N * M;\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        let mut result: [Field; _] = std::mem::zeroed();\n        for i in 0..M {\n            let serialized_t = self[i].serialize();\n            for j in 0..<T as Serialize>::N {\n                result[i * <T as Serialize>::N + j] = serialized_t[j];\n            }\n        }\n        result\n    }\n}\n\nimpl<T, let M: u32> Deserialize for [T; M]\nwhere\n    T: Deserialize,\n{\n    let N: u32 = <T as Deserialize>::N * M;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; M] = std::mem::zeroed();\n        reader.read_struct_array::<T, <T as Deserialize>::N, M>(Deserialize::deserialize, result)\n    }\n}\n\nimpl<T> Serialize for Option<T>\nwhere\n    T: Serialize,\n{\n    let N: u32 = <T as Serialize>::N + 1;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        let mut result: [Field; Self::N] = std::mem::zeroed();\n\n        result[0] = if self.is_some() { 1 } else { 0 };\n\n        let value_serialized = self.unwrap_unchecked().serialize();\n        for i in 0..<T as Serialize>::N {\n            result[1 + i] = value_serialized[i];\n        }\n\n        result\n    }\n}\n\nimpl<T> Deserialize for Option<T>\nwhere\n    T: Deserialize,\n{\n    let N: u32 = <T as Deserialize>::N + 1;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        if fields[0] == 1 {\n            let mut value_fields = [0; <T as Deserialize>::N];\n            for i in 0..<T as Deserialize>::N {\n                value_fields[i] = fields[1 + i];\n            }\n\n            Option::some(T::deserialize(value_fields))\n        } else {\n            Option::none()\n        }\n    }\n}\n\nmod test {\n    use crate::traits::{Deserialize, Serialize};\n\n    #[test]\n    fn u16_serialization() {\n        let a: u16 = 10;\n        assert_eq(a, u16::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i8_serialization() {\n        let a: i8 = -10;\n        assert_eq(a, i8::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i16_serialization() {\n        let a: i16 = -10;\n        assert_eq(a, i16::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i32_serialization() {\n        let a: i32 = -10;\n        assert_eq(a, i32::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i64_serialization() {\n        let a: i64 = -10;\n        assert_eq(a, i64::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn option_field_serialization() {\n        let opt_some = Option::some(5);\n        assert_eq(Option::<_>::deserialize(opt_some.serialize()), opt_some);\n\n        let opt_none = Option::none();\n        assert_eq(Option::<Field>::deserialize(opt_none.serialize()), opt_none);\n    }\n\n    #[test]\n    fn array_serialization() {\n        let array = [1, 2, 3, 4];\n\n        let serialized: [Field; 4] = array.serialize();\n        let deserialized: [Field; 4] = Deserialize::deserialize(serialized);\n        assert_eq(deserialized, array);\n    }\n\n    #[test]\n    fn nested_array_serialization() {\n        let nested_array = [[1, 2, 3, 4], [5, 6, 7, 8]];\n\n        let serialized: [Field; 8] = nested_array.serialize();\n        let deserialized: [[Field; 4]; 2] = Deserialize::deserialize(serialized);\n\n        assert_eq(deserialized, nested_array);\n    }\n\n    #[test]\n    fn option_array_serialization() {\n        let opt_some = Option::some([2, 5]);\n        assert_eq(Option::<_>::deserialize(opt_some.serialize()), opt_some);\n\n        let opt_none = Option::none();\n        assert_eq(Option::<Field>::deserialize(opt_none.serialize()), opt_none);\n    }\n}\n","path":"/Users/zac/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.6-patch.1/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr"},"392":{"source":"global KNOWN_NON_RESIDUE: Field = 5; // This is a non-residue in Noir's native Field.\n\npub fn field_from_bytes<let N: u32>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}\n\n// Convert a 32 byte array to a field element by truncating the final byte\npub fn field_from_bytes_32_trunc(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..15 {\n        // covers bytes 16..30 (31 is truncated and ignored)\n        low = low + (bytes32[15 + 15 - i] as Field) * v;\n        v = v * 256;\n        // covers bytes 0..14\n        high = high + (bytes32[14 - i] as Field) * v;\n    }\n    // covers byte 15\n    low = low + (bytes32[15] as Field) * v;\n\n    low + high * v\n}\n\n// TODO to radix returns u8, so we cannot use bigger radixes. It'd be ideal to use a radix of the maximum range-constrained integer noir supports\npub fn full_field_less_than(lhs: Field, rhs: Field) -> bool {\n    lhs.lt(rhs)\n}\n\npub fn full_field_greater_than(lhs: Field, rhs: Field) -> bool {\n    rhs.lt(lhs)\n}\n\npub fn min(f1: Field, f2: Field) -> Field {\n    if f1.lt(f2) {\n        f1\n    } else {\n        f2\n    }\n}\n\nglobal C1: u32 = 28;\nglobal C3: Field = 40770029410420498293352137776570907027550720424234931066070132305055;\nglobal C5: Field = 19103219067921713944291392827692070036145651957329286315305642004821462161904;\n\npub fn pow(x: Field, y: Field) -> Field {\n    let mut r = 1 as Field;\n    let b: [u1; 254] = y.to_le_bits();\n\n    for i in 0..254 {\n        r *= r;\n        r *= (b[254 - 1 - i] as Field) * x + (1 - b[254 - 1 - i] as Field);\n    }\n\n    r\n}\n\n/// Returns Option::some(sqrt) if there is a square root, and Option::none() if there isn't.\npub fn sqrt(x: Field) -> Option<Field> {\n    // Safety: if the hint returns the square root of x, then we simply square it\n    // check the result equals x. If x is not square, we return a value that\n    // enables us to prove that fact (see the `else` clause below).\n    let (is_sq, maybe_sqrt) = unsafe { __sqrt(x) };\n\n    if is_sq {\n        let sqrt = maybe_sqrt;\n        validate_sqrt_hint(x, sqrt);\n        Option::some(sqrt)\n    } else {\n        let not_sqrt_hint = maybe_sqrt;\n        validate_not_sqrt_hint(x, not_sqrt_hint);\n        Option::none()\n    }\n}\n\n// Boolean indicating whether Field element is a square, i.e. whether there exists a y in Field s.t. x = y*y.\nunconstrained fn is_square(x: Field) -> bool {\n    let v = pow(x, -1 / 2);\n    v * (v - 1) == 0\n}\n\n// Tonelli-Shanks algorithm for computing the square root of a Field element.\n// Requires C1 = max{c: 2^c divides (p-1)}, where p is the order of Field\n// as well as C3 = (C2 - 1)/2, where C2 = (p-1)/(2^c1),\n// and C5 = ZETA^C2, where ZETA is a non-square element of Field.\n// These are pre-computed above as globals.\nunconstrained fn tonelli_shanks_sqrt(x: Field) -> Field {\n    let mut z = pow(x, C3);\n    let mut t = z * z * x;\n    z *= x;\n    let mut b = t;\n    let mut c = C5;\n\n    for i in 0..(C1 - 1) {\n        for _j in 1..(C1 - i - 1) {\n            b *= b;\n        }\n\n        z *= if b == 1 { 1 } else { c };\n\n        c *= c;\n\n        t *= if b == 1 { 1 } else { c };\n\n        b = t;\n    }\n\n    z\n}\n\n// NB: this doesn't return an option, because in the case of there _not_ being a square root, we still want to return a field element that allows us to then assert in the _constrained_ sqrt function that there is no sqrt.\nunconstrained fn __sqrt(x: Field) -> (bool, Field) {\n    let is_sq = is_square(x);\n    if is_sq {\n        let sqrt = tonelli_shanks_sqrt(x);\n        (true, sqrt)\n    } else {\n        // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n        // Facts:\n        // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n        // - If x is a square, LS(x) = 1\n        // - If x is not a square, LS(x) = -1\n        // - If x = 0, LS(x) = 0.\n        //\n        // Hence:\n        // sq * sq = sq // 1 * 1 = 1\n        // non-sq * non-sq = sq // -1 * -1 = 1\n        // sq * non-sq = non-sq // -1 * 1 = -1\n        //\n        // See: https://en.wikipedia.org/wiki/Legendre_symbol\n        let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n        let not_sqrt = tonelli_shanks_sqrt(demo_x_not_square);\n        (false, not_sqrt)\n    }\n}\n\nfn validate_sqrt_hint(x: Field, hint: Field) {\n    assert(hint * hint == x, f\"The claimed_sqrt {hint} is not the sqrt of x {x}\");\n}\n\nfn validate_not_sqrt_hint(x: Field, hint: Field) {\n    // We need this assertion, because x = 0 would pass the other assertions in this\n    // function, and we don't want people to be able to prove that 0 is not square!\n    assert(x != 0, \"0 has a square root; you cannot claim it is not square\");\n    // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n    //\n    // Facts:\n    // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n    // - If x is a square, LS(x) = 1\n    // - If x is not a square, LS(x) = -1\n    // - If x = 0, LS(x) = 0.\n    //\n    // Hence:\n    // 1. sq * sq = sq // 1 * 1 = 1\n    // 2. non-sq * non-sq = sq // -1 * -1 = 1\n    // 3. sq * non-sq = non-sq // -1 * 1 = -1\n    //\n    // See: https://en.wikipedia.org/wiki/Legendre_symbol\n    //\n    // We want to demonstrate that this below multiplication falls under bullet-point (2):\n    let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n    // I.e. we want to demonstrate that `demo_x_not_square` has Legendre symbol 1\n    // (i.e. that it is a square), so we prove that it is square below.\n    // Why do we want to prove that it has LS 1?\n    // Well, since it was computed with a known-non-residue, its squareness implies we're\n    // in case 2 (something multiplied by a known-non-residue yielding a result which\n    // has a LS of 1), which implies that x must be a non-square. The unconstrained\n    // function gave us the sqrt of demo_x_not_square, so all we need to do is\n    // assert its squareness:\n    assert(\n        hint * hint == demo_x_not_square,\n        f\"The hint {hint} does not demonstrate that {x} is not a square\",\n    );\n}\n\n#[test]\nunconstrained fn bytes_field_test() {\n    // Tests correctness of field_from_bytes_32_trunc against existing methods\n    // Bytes representing 0x543e0a6642ffeb8039296861765a53407bba62bd1c97ca43374de950bbe0a7\n    let inputs = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167,\n    ];\n    let field = field_from_bytes(inputs, true);\n    let return_bytes: [u8; 31] = field.to_be_bytes();\n    assert_eq(inputs, return_bytes);\n    // 32 bytes - we remove the final byte, and check it matches the field\n    let inputs2 = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167, 158,\n    ];\n    let field2 = field_from_bytes_32_trunc(inputs2);\n    let return_bytes2: [u8; 31] = field.to_be_bytes();\n\n    assert_eq(return_bytes2, return_bytes);\n    assert_eq(field2, field);\n}\n\n#[test]\nunconstrained fn max_field_test() {\n    // Tests the hardcoded value in constants.nr vs underlying modulus\n    // NB: We can't use 0-1 in constants.nr as it will be transpiled incorrectly to ts and sol constants files\n    let max_value = crate::constants::MAX_FIELD_VALUE;\n    assert_eq(max_value, 0 - 1);\n    // modulus == 0 is tested elsewhere, so below is more of a sanity check\n    let max_bytes: [u8; 32] = max_value.to_be_bytes();\n    let mod_bytes = std::field::modulus_be_bytes();\n    for i in 0..31 {\n        assert_eq(max_bytes[i], mod_bytes[i]);\n    }\n    assert_eq(max_bytes[31], mod_bytes[31] - 1);\n}\n\n#[test]\nunconstrained fn sqrt_valid_test() {\n    let x = 16; // examples: 16, 9, 25, 81\n    let result = sqrt(x);\n    assert(result.is_some());\n    assert_eq(result.unwrap() * result.unwrap(), x);\n}\n\n#[test]\nunconstrained fn sqrt_invalid_test() {\n    let x = KNOWN_NON_RESIDUE; // has no square root in the field\n    let result = sqrt(x);\n    assert(result.is_none());\n}\n","path":"/Users/zac/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.6-patch.1/noir-projects/noir-protocol-circuits/crates/types/src/utils/field.nr"},"396":{"source":"pub struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_u64(&mut self) -> u64 {\n        self.read() as u64\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() != 0\n    }\n\n    pub fn read_array<let K: u32>(&mut self) -> [Field; K] {\n        let mut result = [0; K];\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array());\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(\n        &mut self,\n        deserialise: fn([Field; K]) -> T,\n        mut result: [T; C],\n    ) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert_eq(self.offset, self.data.len(), \"Reader did not read all data\");\n    }\n}\n","path":"/Users/zac/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.6-patch.1/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr"},"481":{"source":"use aztec::macros::aztec;\n\n// ============ Hat Type Constants ============\n// Based on ELO delta (loser_elo - winner_elo)\n// Positive = underdog victory (impressive), Negative = expected win (less impressive)\nglobal HAT_CROWN: u8 = 0;         // delta > +200 (major upset)\nglobal HAT_LAUREL_WREATH: u8 = 1; // delta +100 to +200 (underdog victory)\nglobal HAT_WIZARD_HAT: u8 = 2;    // delta -100 to +100 (fair match)\nglobal HAT_TOP_HAT: u8 = 3;       // delta -200 to -100 (slight favorite)\nglobal HAT_BOWLER_HAT: u8 = 4;    // delta -300 to -200 (clear favorite)\nglobal HAT_BASEBALL_CAP: u8 = 5;  // delta -400 to -300 (strong favorite)\nglobal HAT_DUNCE_CAP: u8 = 6;     // delta < -400 (crushing weaker opponent)\n\n// ============ Quality Constants ============\n// Based on winner's ELO rating\nglobal QUALITY_TATTERED: u8 = 0;  // ELO < 800\nglobal QUALITY_SHODDY: u8 = 1;    // ELO 800-1000\nglobal QUALITY_PLAIN: u8 = 2;     // ELO 1000-1200\nglobal QUALITY_FINE: u8 = 3;      // ELO 1200-1400\nglobal QUALITY_ELEGANT: u8 = 4;   // ELO 1400-1600\nglobal QUALITY_MAJESTIC: u8 = 5;  // ELO 1600-1800\nglobal QUALITY_LEGENDARY: u8 = 6; // ELO 1800-2000\nglobal QUALITY_MYTHIC: u8 = 7;    // ELO 2000+\n\n/// Compute hat type from ELO delta (loser_elo - winner_elo)\n/// Positive delta = underdog victory = more impressive hat\n/// Negative delta = expected win = less impressive hat\npub fn compute_hat_type(winner_elo: u32, loser_elo: u32) -> u8 {\n    let delta: i32 = loser_elo as i32 - winner_elo as i32;\n\n    if delta > 200 {\n        HAT_CROWN\n    } else if delta > 100 {\n        HAT_LAUREL_WREATH\n    } else if delta >= -100 {\n        HAT_WIZARD_HAT\n    } else if delta >= -200 {\n        HAT_TOP_HAT\n    } else if delta >= -300 {\n        HAT_BOWLER_HAT\n    } else if delta >= -400 {\n        HAT_BASEBALL_CAP\n    } else {\n        HAT_DUNCE_CAP\n    }\n}\n\n/// Compute hat quality from winner's ELO rating\npub fn compute_hat_quality(winner_elo: u32) -> u8 {\n    if winner_elo >= 2000 {\n        QUALITY_MYTHIC\n    } else if winner_elo >= 1800 {\n        QUALITY_LEGENDARY\n    } else if winner_elo >= 1600 {\n        QUALITY_MAJESTIC\n    } else if winner_elo >= 1400 {\n        QUALITY_ELEGANT\n    } else if winner_elo >= 1200 {\n        QUALITY_FINE\n    } else if winner_elo >= 1000 {\n        QUALITY_PLAIN\n    } else if winner_elo >= 800 {\n        QUALITY_SHODDY\n    } else {\n        QUALITY_TATTERED\n    }\n}\n\n#[aztec]\npub contract HatNFT {\n    use aztec::{\n        macros::{events::event, functions::{external, initializer}, storage::storage},\n        protocol_types::address::AztecAddress,\n        state_vars::{Map, public_mutable::PublicMutable},\n    };\n    use crate::{compute_hat_type, compute_hat_quality};\n\n    /// Emitted when a new hat NFT is minted\n    #[event]\n    struct HatMinted {\n        token_id: u32,\n        owner: AztecAddress,\n        game_id: u32,\n        hat_type: u8,\n        hat_quality: u8,\n    }\n\n    /// Emitted when a hat NFT is transferred\n    #[event]\n    struct HatTransferred {\n        token_id: u32,\n        from: AztecAddress,\n        to: AztecAddress,\n    }\n\n    #[storage]\n    struct Storage<Context> {\n        /// Auto-incrementing token ID counter\n        token_counter: PublicMutable<u32, Context>,\n        /// Map from token_id to owner address\n        public_owners: Map<u32, PublicMutable<AztecAddress, Context>, Context>,\n        /// Map from token_id to existence flag\n        nft_exists: Map<u32, PublicMutable<bool, Context>, Context>,\n        /// Map from token_id to game_id\n        hat_game_ids: Map<u32, PublicMutable<u32, Context>, Context>,\n        /// Map from token_id to hat type (0-6, see HAT_* constants)\n        hat_types: Map<u32, PublicMutable<u8, Context>, Context>,\n        /// Map from token_id to hat quality (0-7, see QUALITY_* constants)\n        hat_qualities: Map<u32, PublicMutable<u8, Context>, Context>,\n        /// Authorized minter (chess contract address) - set once in constructor\n        minter: PublicMutable<AztecAddress, Context>,\n    }\n\n    #[initializer]\n    #[external(\"public\")]\n    fn constructor(chess_contract: AztecAddress) {\n        assert(chess_contract != AztecAddress::zero(), \"Minter cannot be zero address\");\n        self.storage.minter.write(chess_contract);\n        self.storage.token_counter.write(0);\n    }\n\n    /// Mint a new hat NFT to the winner. Only callable by the authorized minter (chess contract).\n    #[external(\"public\")]\n    fn mint_hat(to: AztecAddress, game_id: u32, winner_elo: u32, loser_elo: u32) {\n        // Only the authorized minter can call this\n        let minter = self.storage.minter.read();\n        let caller = self.context.msg_sender().expect(f\"msg_sender must be set\");\n        assert(caller == minter, \"Only minter can mint\");\n        assert(to != AztecAddress::zero(), \"Cannot mint to zero address\");\n\n        // Get next token ID\n        let token_id = self.storage.token_counter.read();\n\n        // Compute hat attributes from ELO ratings\n        let hat_type = compute_hat_type(winner_elo, loser_elo);\n        let hat_quality = compute_hat_quality(winner_elo);\n\n        // Store NFT data\n        self.storage.public_owners.at(token_id).write(to);\n        self.storage.nft_exists.at(token_id).write(true);\n        self.storage.hat_game_ids.at(token_id).write(game_id);\n        self.storage.hat_types.at(token_id).write(hat_type);\n        self.storage.hat_qualities.at(token_id).write(hat_quality);\n\n        // Increment counter\n        self.storage.token_counter.write(token_id + 1);\n\n        // Emit event\n        self.emit(HatMinted {\n            token_id,\n            owner: to,\n            game_id,\n            hat_type,\n            hat_quality,\n        });\n    }\n\n    /// Transfer a hat NFT from one address to another. Caller must be the current owner.\n    #[external(\"public\")]\n    fn transfer(from: AztecAddress, to: AztecAddress, token_id: u32) {\n        // Check token exists\n        let exists = self.storage.nft_exists.at(token_id).read();\n        assert(exists, \"Token does not exist\");\n\n        // Check caller is the owner\n        let owner = self.storage.public_owners.at(token_id).read();\n        assert(owner == from, \"From address is not the owner\");\n        let caller = self.context.msg_sender().expect(f\"msg_sender must be set\");\n        assert(caller == from, \"Only owner can transfer\");\n        assert(to != AztecAddress::zero(), \"Cannot transfer to zero address\");\n\n        // Update owner\n        self.storage.public_owners.at(token_id).write(to);\n\n        // Emit event\n        self.emit(HatTransferred { token_id, from, to });\n    }\n\n    /// Get the owner of a token\n    #[external(\"utility\")]\n    unconstrained fn owner_of(token_id: u32) -> AztecAddress {\n        let exists = self.storage.nft_exists.at(token_id).read();\n        assert(exists, \"Token does not exist\");\n        self.storage.public_owners.at(token_id).read()\n    }\n\n    /// Get metadata for a hat NFT\n    /// Returns (game_id, hat_type, hat_quality)\n    /// Hat types: 0=Crown, 1=Laurel Wreath, 2=Wizard Hat, 3=Top Hat, 4=Bowler Hat, 5=Baseball Cap, 6=Dunce Cap\n    /// Qualities: 0=Tattered, 1=Shoddy, 2=Plain, 3=Fine, 4=Elegant, 5=Majestic, 6=Legendary, 7=Mythic\n    #[external(\"utility\")]\n    unconstrained fn get_hat_metadata(token_id: u32) -> (u32, u8, u8) {\n        let exists = self.storage.nft_exists.at(token_id).read();\n        assert(exists, \"Token does not exist\");\n\n        let game_id = self.storage.hat_game_ids.at(token_id).read();\n        let hat_type = self.storage.hat_types.at(token_id).read();\n        let hat_quality = self.storage.hat_qualities.at(token_id).read();\n\n        (game_id, hat_type, hat_quality)\n    }\n\n    /// Get total number of minted tokens\n    #[external(\"utility\")]\n    unconstrained fn total_supply() -> u32 {\n        self.storage.token_counter.read()\n    }\n\n    /// Get the authorized minter address\n    #[external(\"utility\")]\n    unconstrained fn get_minter() -> AztecAddress {\n        self.storage.minter.read()\n    }\n\n    /// Check if a token exists\n    #[external(\"utility\")]\n    unconstrained fn exists(token_id: u32) -> bool {\n        self.storage.nft_exists.at(token_id).read()\n    }\n}\n","path":"/Users/zac/aztec-chess-mods/contracts/hat_nft/src/main.nr"}}}