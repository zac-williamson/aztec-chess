{"noir_version":"1.0.0-beta.18+13ce5c89c1edbfbf5e92c4cbf2258ea6e63f46b5","name":"HatNFT","functions":[{"name":"__aztec_nr_internals__constructor","hash":"3353473586263284857","is_unconstrained":true,"custom_attributes":["abi_public","abi_initializer"],"abi":{"parameters":[{"name":"chess_contract","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":null,"error_types":{"772947778646992575":{"error_kind":"string","string":"Minter cannot be zero address"},"9967937311635654895":{"error_kind":"string","string":"Initialization hash does not match"},"14415304921900233953":{"error_kind":"string","string":"Initializer address is not the contract deployer"},"14990209321349310352":{"error_kind":"string","string":"attempt to add with overflow"},"15764276373176857197":{"error_kind":"string","string":"Stack too deep"},"16431471497789672479":{"error_kind":"string","string":"Index out of bounds"}}},"bytecode":"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","debug_symbols":"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"},{"name":"__aztec_nr_internals__exists","hash":"17724491352684099770","is_unconstrained":true,"custom_attributes":["abi_utility"],"abi":{"parameters":[{"name":"token_id","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"private"}],"return_type":{"abi_type":{"kind":"boolean"},"visibility":"public"},"error_types":{"361444214588792908":{"error_kind":"string","string":"attempt to multiply with overflow"},"992401946138144806":{"error_kind":"string","string":"Attempted to read past end of BoundedVec"},"1998584279744703196":{"error_kind":"string","string":"attempt to subtract with overflow"},"2967937905572420042":{"error_kind":"fmtstring","length":61,"item_types":[{"kind":"field"},{"kind":"field"}]},"3330370348214585450":{"error_kind":"fmtstring","length":48,"item_types":[{"kind":"field"},{"kind":"field"}]},"3670003311596808700":{"error_kind":"fmtstring","length":77,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"4261968856572588300":{"error_kind":"string","string":"Value does not fit in field"},"4440399188109668273":{"error_kind":"string","string":"Input length must be a multiple of 32"},"8494938221169433674":{"error_kind":"fmtstring","length":132,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"9791669845391776238":{"error_kind":"string","string":"0 has a square root; you cannot claim it is not square"},"9885968605480832328":{"error_kind":"string","string":"Attempted to read past the length of a CapsuleArray"},"10135509984888824963":{"error_kind":"fmtstring","length":58,"item_types":[{"kind":"field"}]},"10791800398362570014":{"error_kind":"string","string":"extend_from_bounded_vec out of bounds"},"11021520179822076911":{"error_kind":"string","string":"Attempted to delete past the length of a CapsuleArray"},"11220776034976816114":{"error_kind":"fmtstring","length":128,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"11692359521570349358":{"error_kind":"fmtstring","length":40,"item_types":[]},"12327971061804302172":{"error_kind":"fmtstring","length":98,"item_types":[]},"12469291177396340830":{"error_kind":"string","string":"call to assert_max_bit_size"},"12913276134398371456":{"error_kind":"string","string":"push out of bounds"},"13455385521185560676":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"13782432182790537927":{"error_kind":"fmtstring","length":144,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"14990209321349310352":{"error_kind":"string","string":"attempt to add with overflow"},"15764276373176857197":{"error_kind":"string","string":"Stack too deep"},"16431471497789672479":{"error_kind":"string","string":"Index out of bounds"}}},"bytecode":"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","debug_symbols":"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llHLqBXUCmoFtYJaQa2gVlArqBXUCmoVtYpaRY1c0sklnVzSySWdXNLJJZ1c0sklnVzSySWdXNLJJZ1c0sklnVzSySWdXNLJJZ1c0sklnVzSySWdXNLJJZ1c0sklnVzSySWdXNLJJZ1c0sklnVzSySWdXNLJJZ1c0sklnVzSySWdXNLJJZ1c0sklnVzSySWdXNLJJZ1c0sklnVzSySWdXNLJJZ1c0sklnVwyyCWDXDLIJYNcMsglg1wyyCWDXDLIJYNcMsglg1wyyCWDXDLIJYNcMsglg1wyyCWDXDLIJYNcMlYuyYYFrKCACjawgyNw5ZKFCUStoFZQK6gV1ApqBbWCWkWtolZRq6hV1CpqFbWKWkWtoiaoCWqCmqAmqAlqgpqgJqgJaoqaoqaoKWqKmqKmqClqipqi1lBrqDXUGmoNtYZaQ62h1lBrqHXUOmodtZVLqmEFBTQ1NWxgB0fgyiULE5jBAlZQQNQGagO14Wpl1b1emMAMFrCCAirYwA6illBLqCXUEmoJtYRaQi2hllBLqGXUMmoZtYxaRi2jllHLqGXUMmoFtYJaQa2gVlArqBXUCmoFtYJaRa2iVlGrqFXUKmoVtYpaRa2iJqgJaoKaoCaoCWqCmqAmqAlqipqipqgpaoqaoqaoKWqKmqLWUGuoNdQaag21hlpDraHWUGuoddQ6ah21jlpHraPWUeuoddQ6agO1gdpAbaA2UBuoDdQGagM1ckkilyRySSKXJHJJIpckckkilyRySSKXJHJJIpckckkilyRySSKXJHJJIpckckkilyRySSKXJHJJIpckckkilyRySSKXJHJJIpckckkilyRySSKXJHJJIpckckkilyRySSKXJHJJIpckckkilyRySSKXJHJJIpckckkilyRySSKXJHJJIpckckkilyRySSKXJHJJIpckckkilyRySSKXJHJJIpckckkilyRySSKXJHJJIpckckkilyRySSKXJHJJIpckckkilyRySSKXJHJJIpckckkilyRySSKXJHJJIpckckkilyRySSKXJHJJIpckckkilyRySSKXJHJJJpdkckkml2RySSaXZHJJJpdkckkml2RySSaXZHJJJpdkckkml2RySSaXZHJJJpdkckkml2RySSaXZHJJJpdkckkml2RySSaXZHJJJpdkckkml2RySSaXZHJJJpdkckkml2Ry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"},{"name":"__aztec_nr_internals__get_hat_metadata","hash":"13276055750072535560","is_unconstrained":true,"custom_attributes":["abi_utility"],"abi":{"parameters":[{"name":"token_id","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"private"}],"return_type":{"abi_type":{"kind":"tuple","fields":[{"kind":"integer","sign":"unsigned","width":32},{"kind":"integer","sign":"unsigned","width":8},{"kind":"integer","sign":"unsigned","width":8}]},"visibility":"public"},"error_types":{"361444214588792908":{"error_kind":"string","string":"attempt to multiply with overflow"},"992401946138144806":{"error_kind":"string","string":"Attempted to read past end of BoundedVec"},"1998584279744703196":{"error_kind":"string","string":"attempt to subtract with overflow"},"2967937905572420042":{"error_kind":"fmtstring","length":61,"item_types":[{"kind":"field"},{"kind":"field"}]},"3330370348214585450":{"error_kind":"fmtstring","length":48,"item_types":[{"kind":"field"},{"kind":"field"}]},"3670003311596808700":{"error_kind":"fmtstring","length":77,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"4261968856572588300":{"error_kind":"string","string":"Value does not fit in field"},"4440399188109668273":{"error_kind":"string","string":"Input length must be a multiple of 32"},"8494938221169433674":{"error_kind":"fmtstring","length":132,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"9791669845391776238":{"error_kind":"string","string":"0 has a square root; you cannot claim it is not square"},"9885968605480832328":{"error_kind":"string","string":"Attempted to read past the length of a CapsuleArray"},"10135509984888824963":{"error_kind":"fmtstring","length":58,"item_types":[{"kind":"field"}]},"10791800398362570014":{"error_kind":"string","string":"extend_from_bounded_vec out of bounds"},"10826617868182774729":{"error_kind":"string","string":"Token does not exist"},"11021520179822076911":{"error_kind":"string","string":"Attempted to delete past the length of a CapsuleArray"},"11220776034976816114":{"error_kind":"fmtstring","length":128,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"11692359521570349358":{"error_kind":"fmtstring","length":40,"item_types":[]},"12327971061804302172":{"error_kind":"fmtstring","length":98,"item_types":[]},"12469291177396340830":{"error_kind":"string","string":"call to assert_max_bit_size"},"12913276134398371456":{"error_kind":"string","string":"push out of bounds"},"13455385521185560676":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"13782432182790537927":{"error_kind":"fmtstring","length":144,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"14990209321349310352":{"error_kind":"string","string":"attempt to add with overflow"},"15764276373176857197":{"error_kind":"string","string":"Stack too deep"},"16431471497789672479":{"error_kind":"string","string":"Index out of bounds"}}},"bytecode":"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","debug_symbols":"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c8o8p8xzyjynzHPKPKfMc8o8p8xzyjynzHPKPKfMc8o8p8xzyjynzHPKPKfMc8o8p8xzyjynzHPKPKfMc8o8p8xzyjynzHPKPKfMc8o8p8xzyjynzHPKPKfMc8o8p8xzyjynzHPKPKfMc8o8p8xzyjynzHPKPKfMc8o8p8xzyjynzHPKPKfMc8o8p8xzyjynzHPKPKfMc8o8p8xzyjznzHPOPOfMc84858xzzjznzHPOPOfMc84858xzzjznzHPOPOfMc84858xzzjznzHPOPOfMc84858xzzjznzHPOPOfMc84858xzzjznzHPOPOfMc84858xzzjznzHPOPOfMc84858xzzjznzHPOPOfMc84858xzzjznzHPOPOfMc84858xzzjznzHPOPOfMc84858xzzjznzHPOPOfMc84858xzzjznzHPOPOfMc84858xzzjznzHPOPOfMc84858xzzjznzHPOPOfMc84858xzzjznzHPOPOfMc84858xzzjznzHPOPOfMc84858xzzjznzHPOPOfMc848b5nnLfO8ZZ63zPOWed4yz1vmecs8b5nnLfO8ZZ63zPOWed4yz1vmecs8b5nnLfO8ZZ63zPOWed4yz1vmecs8b5nnLfO8ZZ63zPOWed4yz1vmecs8b5nnLfO8ZZ63zPOWed4yz1vmecs8b5nnLfO8ZZ63zPOWed4yz1vmecs89yIkNacZ5Hm+6KkxvIb4yvNNLaknSZImjSRLmkFXnm9KDU0NTQ1NDU0NTQ1NDU0NTY2RGiM1RmqM1BipMVJjpMZIjZEaIzUsNSw1LDUsNSw1LDUsNSw1LDUsNWZqzNSYqTFTY6bGTI2ZGjM1ZmrM0PDCpU2UxEktqSdJkiaNJEtKDUoNSg1KDUoNSg1KDUoNSg1KDUoNTg1ODU4NTg1ODU4NTg1ODU4NTo2WGi01Wmq01Gip0VKjpUZLjZYaLTV6avTU6KnRU6OnRk+Nnho9NXpq9NSQ1Mg875nnPfO8Z573zHMveBrsNJIsaQZ5ni+iJE5qST1JklJDU0NTQ1NjpMZIjZEaIzVGaozUGKkxUmOkxkgNSw1LDUsNSw1LDUsNSw1LDUsNS42ZGjM1ZmrM1JipMVNjpsZMjZkaMzS8OGoTJXFSS+pJkqRJI8mSUoNSg1KDUoNSg1KDUoNSg1KDUoNSg1ODU4NTg1ODU4NT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"},{"name":"__aztec_nr_internals__get_minter","hash":"4736303381094500957","is_unconstrained":true,"custom_attributes":["abi_utility"],"abi":{"parameters":[],"return_type":{"abi_type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"public"},"error_types":{"361444214588792908":{"error_kind":"string","string":"attempt to multiply with overflow"},"992401946138144806":{"error_kind":"string","string":"Attempted to read past end of BoundedVec"},"1998584279744703196":{"error_kind":"string","string":"attempt to subtract with overflow"},"2967937905572420042":{"error_kind":"fmtstring","length":61,"item_types":[{"kind":"field"},{"kind":"field"}]},"3330370348214585450":{"error_kind":"fmtstring","length":48,"item_types":[{"kind":"field"},{"kind":"field"}]},"3670003311596808700":{"error_kind":"fmtstring","length":77,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"4261968856572588300":{"error_kind":"string","string":"Value does not fit in field"},"4440399188109668273":{"error_kind":"string","string":"Input length must be a multiple of 32"},"8494938221169433674":{"error_kind":"fmtstring","length":132,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"9791669845391776238":{"error_kind":"string","string":"0 has a square root; you cannot claim it is not square"},"9885968605480832328":{"error_kind":"string","string":"Attempted to read past the length of a CapsuleArray"},"10135509984888824963":{"error_kind":"fmtstring","length":58,"item_types":[{"kind":"field"}]},"10791800398362570014":{"error_kind":"string","string":"extend_from_bounded_vec out of bounds"},"11021520179822076911":{"error_kind":"string","string":"Attempted to delete past the length of a CapsuleArray"},"11220776034976816114":{"error_kind":"fmtstring","length":128,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"11692359521570349358":{"error_kind":"fmtstring","length":40,"item_types":[]},"12327971061804302172":{"error_kind":"fmtstring","length":98,"item_types":[]},"12469291177396340830":{"error_kind":"string","string":"call to assert_max_bit_size"},"12913276134398371456":{"error_kind":"string","string":"push out of bounds"},"13782432182790537927":{"error_kind":"fmtstring","length":144,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"14990209321349310352":{"error_kind":"string","string":"attempt to add with overflow"},"15764276373176857197":{"error_kind":"string","string":"Stack too deep"},"16431471497789672479":{"error_kind":"string","string":"Index out of bounds"}}},"bytecode":"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","debug_symbols":"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"},{"name":"__aztec_nr_internals__mint_hat","hash":"14597654687426636519","is_unconstrained":true,"custom_attributes":["abi_public"],"abi":{"parameters":[{"name":"to","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"game_id","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"private"},{"name":"winner_elo","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"private"},{"name":"loser_elo","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"private"}],"return_type":null,"error_types":{"459713770342432051":{"error_kind":"string","string":"Not initialized"},"1998584279744703196":{"error_kind":"string","string":"attempt to subtract with overflow"},"5197614757850103533":{"error_kind":"string","string":"Only minter can mint"},"7721587900423544575":{"error_kind":"fmtstring","length":22,"item_types":[]},"13455385521185560676":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"14990209321349310352":{"error_kind":"string","string":"attempt to add with overflow"},"15764276373176857197":{"error_kind":"string","string":"Stack too deep"},"15978124792480278163":{"error_kind":"string","string":"Cannot mint to zero address"}}},"bytecode":"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","debug_symbols":"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"},{"name":"__aztec_nr_internals__owner_of","hash":"4233430615500584481","is_unconstrained":true,"custom_attributes":["abi_utility"],"abi":{"parameters":[{"name":"token_id","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"private"}],"return_type":{"abi_type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"public"},"error_types":{"361444214588792908":{"error_kind":"string","string":"attempt to multiply with overflow"},"992401946138144806":{"error_kind":"string","string":"Attempted to read past end of BoundedVec"},"1998584279744703196":{"error_kind":"string","string":"attempt to subtract with overflow"},"2967937905572420042":{"error_kind":"fmtstring","length":61,"item_types":[{"kind":"field"},{"kind":"field"}]},"3330370348214585450":{"error_kind":"fmtstring","length":48,"item_types":[{"kind":"field"},{"kind":"field"}]},"3670003311596808700":{"error_kind":"fmtstring","length":77,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"4261968856572588300":{"error_kind":"string","string":"Value does not fit in field"},"4440399188109668273":{"error_kind":"string","string":"Input length must be a multiple of 32"},"8494938221169433674":{"error_kind":"fmtstring","length":132,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"9791669845391776238":{"error_kind":"string","string":"0 has a square root; you cannot claim it is not square"},"9885968605480832328":{"error_kind":"string","string":"Attempted to read past the length of a CapsuleArray"},"10135509984888824963":{"error_kind":"fmtstring","length":58,"item_types":[{"kind":"field"}]},"10791800398362570014":{"error_kind":"string","string":"extend_from_bounded_vec out of bounds"},"10826617868182774729":{"error_kind":"string","string":"Token does not exist"},"11021520179822076911":{"error_kind":"string","string":"Attempted to delete past the length of a CapsuleArray"},"11220776034976816114":{"error_kind":"fmtstring","length":128,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"11692359521570349358":{"error_kind":"fmtstring","length":40,"item_types":[]},"12327971061804302172":{"error_kind":"fmtstring","length":98,"item_types":[]},"12469291177396340830":{"error_kind":"string","string":"call to assert_max_bit_size"},"12913276134398371456":{"error_kind":"string","string":"push out of bounds"},"13455385521185560676":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"13782432182790537927":{"error_kind":"fmtstring","length":144,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"14990209321349310352":{"error_kind":"string","string":"attempt to add with overflow"},"15764276373176857197":{"error_kind":"string","string":"Stack too deep"},"16431471497789672479":{"error_kind":"string","string":"Index out of bounds"}}},"bytecode":"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","debug_symbols":"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g1qDWoNag1qDWoNag1qDWodah1qHWodah1qHWodah1qHWoeaQE2gJlATqAnUBGoCNYGaQE2gplBTqCnUFGoKNYWaQk2hplBTqBnUDGoGNYOaQc2gZlAzqBnUDGoONYeaQ82h5lBzqDnUHGoONYfagNqA2oDagNqA2oDagNqA2oDaKLWo60wkIAMbsAMFqEADOhBqyCWCXCLIJYJcIsglglwiyCWCXCLIJYJcIsglglwiyCWCXCLIJYJcIsglglwiyCWCXCLIJYJcIsglglwiyCWCXCLIJYJcIsglglwiyCWCXCLIJYJcIsglglwiyCWCXCLIJYJcIsglglwiyCWCXCLIJYJcIsglglwiyCWCXCLIJYJcIsglglwiyCWCXCLIJYJcIsglglwiyCWCXCLIJYJcIsglglwiyCWCXCLIJYJcIsglglwiyCWCXCLIJYJcIsglglwiyCWCXCLIJYJcIsglglwiyCWCXCLIJYJcIsglglyiyCWKXKLIJYpcosglilyiyCWKXKLIJYpcosglilyiyCWKXKLIJYpcosglilyiyCWKXKLIJYpcosglilyiyCWKXKLIJYpcosglilyiyCWKXKLIJYpcosglilyiyCWKXKLIJYpcosglilyiyCWKXKLIJYpcosglilyiyCWKXKLIJYpcosglilyiyCWKXKLIJYpcosglilyiyCWKXKLIJYpcosglilyiyCWKXKLIJYpcosglilyiyCWKXKLIJYpcosglilyiyCWKXKLIJYpcosglilyiyCWKXKLIJYpcosglilyiyCWKXKLIJYpcosglilyiyCWKXKLIJYpcYsglqzSVLZCBDdiBAlSgAR04ClcuWQg1ghpBjaBGUCOoEdQIagQ1hhpDjaHGUItcsr4xELnkQgUa0IGjMHLJhQRkYANCrUGtQa1BrUGtQa1DrUOtQy1ySXsEdqAAFWhAB47CyCUXEpCBUBOoCdQEagI1gZpATaGmUFOoKdQUago1hZpCTaGmUDOoGdQMagY1g5pBzaBmUDOoGdQcag41h5pDzaHmUHOoOdQcag61AbUBtQG1AbUBtQG1AbUBtQG1UWqrNPVCAjKwATtQgAo0oAOhRlAjqBHUCGoENYIaQY2gRlAjqDHUGGoMNYYaQ42hxlBjqDHUGGoNag1qDWoNag1qDWoNag1qDWoNah1qHWodasgljlzi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"},{"name":"__aztec_nr_internals__total_supply","hash":"8182885715199449159","is_unconstrained":true,"custom_attributes":["abi_utility"],"abi":{"parameters":[],"return_type":{"abi_type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"},"error_types":{"361444214588792908":{"error_kind":"string","string":"attempt to multiply with overflow"},"992401946138144806":{"error_kind":"string","string":"Attempted to read past end of BoundedVec"},"1998584279744703196":{"error_kind":"string","string":"attempt to subtract with overflow"},"2967937905572420042":{"error_kind":"fmtstring","length":61,"item_types":[{"kind":"field"},{"kind":"field"}]},"3330370348214585450":{"error_kind":"fmtstring","length":48,"item_types":[{"kind":"field"},{"kind":"field"}]},"3670003311596808700":{"error_kind":"fmtstring","length":77,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"4261968856572588300":{"error_kind":"string","string":"Value does not fit in field"},"4440399188109668273":{"error_kind":"string","string":"Input length must be a multiple of 32"},"8494938221169433674":{"error_kind":"fmtstring","length":132,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"9791669845391776238":{"error_kind":"string","string":"0 has a square root; you cannot claim it is not square"},"9885968605480832328":{"error_kind":"string","string":"Attempted to read past the length of a CapsuleArray"},"10135509984888824963":{"error_kind":"fmtstring","length":58,"item_types":[{"kind":"field"}]},"10791800398362570014":{"error_kind":"string","string":"extend_from_bounded_vec out of bounds"},"11021520179822076911":{"error_kind":"string","string":"Attempted to delete past the length of a CapsuleArray"},"11220776034976816114":{"error_kind":"fmtstring","length":128,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"11692359521570349358":{"error_kind":"fmtstring","length":40,"item_types":[]},"12327971061804302172":{"error_kind":"fmtstring","length":98,"item_types":[]},"12469291177396340830":{"error_kind":"string","string":"call to assert_max_bit_size"},"12913276134398371456":{"error_kind":"string","string":"push out of bounds"},"13782432182790537927":{"error_kind":"fmtstring","length":144,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"14990209321349310352":{"error_kind":"string","string":"attempt to add with overflow"},"15764276373176857197":{"error_kind":"string","string":"Stack too deep"},"16431471497789672479":{"error_kind":"string","string":"Index out of bounds"}}},"bytecode":"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","debug_symbols":"tf3djiQ9cqWN3ksf6yCMP0ZStzIYCD2ankEDjdagJW1gQ9C9f+FGmj2sLATTMyPfE9Wjt6tsuZNcK9zpdPp//el//+V//ef//Ze//v3//Nu//+mf/8d//el//eOvf/vbX//vv/zt3/71z//x13/7+/O//tefHtf/yfVP/5z/6U9Z//TP+vyj/emf+/OPPv8Y9kd5zD9k/pHmH3n+UeYfdf6h849ZpcwqZVaps0qdVeqsUmeVOqvUWaXOKnVWqbNKnVV0VtFZRWcVnVV0VtFZRWcVnVV0VtFZpc0qbVZps0qbVdqs0maVNqu0WaXNKm1W6bNKn1X6rNJnlT6r9Fmlzyp9VumzSp9VxqwyZpUxq4xZZcwqY1YZs8qYVcasMmYVeTzWn7L+TOvPvP4s68+6/tT1Z1t/9vXnqiernqx6surJqifPevK4oDqoQ3N41pR8wViQHg7PsqIXPOum6y+n7FAcqoM6NIdn5VQuGAvyw0Ecrsr1guxQHK5jvs7iGvYTmsOzcpYLxoJr+E8Qh+SQHYpDdVCH5uCVi1euXrl65csW+WqfyxgTikN1UIfm0B3GgssmE8TBK6tXVq+sXlm9snpl9crqlZtXbl65eeXmlZtXbl65eeXmlS8r5asvLjMZXHaaIA7JITsUh+qgDs3BK3evPLzy8MrDKw+vPLzy8MrDKw+vPLzyWJXT4+EgDskhOxSH6qAOzaE7eGXxyuKVxSuLVxavLF5ZvLJ4ZfHK4pWTV05eOXnl5JWTV05eOXnl5JWTV05eOXvl7JWzV85eOXvl7JWzV85eOXvl7JWLVy5euXjl4pXNg/2C6qAOzaE7jAXmQQNxSA7ZwStXr1y98uXBIhd0h7Hg8mDRC8QhOWSH4lAd1KE5dIexoHnl5pWbV24rkVIrDtVBHZpDd1iJlPrDQRySg1fuXrl75cuDZVzQHLrDWHB5cII4JIfsUByqg1ceXnl45bEq58uD9XGBOCSH7FAcqoM6NIfuMBaIVxavLF758mBtFxSH6qAOzaE7jAWXByeIQ3LwyskrJ6+cvHLyyskrJ6+cvXL2ytkrZ6+cvXL2ytkrZ6+cvXL2ysUrF69cvHLxysUrF69cvHLxysUrF69cvXL1ytUrV69cvXL1ytUrV69cvXL1yuqV1SurV1avrF5ZvbJ6ZfXK6pXVKzev3Lxy88rNKzev3Lxy88rNKzev3Lxy98rdK3ev3L1y98rdK3ev3L1y98rdKw+vPLzy8MrDKw+vPLzy8MrDKw+vPFbl8ng4iENyyA7FoTqoQ3PoDl5ZvLJ4ZfHK7sHiHizuweIeLO7B4h4s7sHiHizuweIeLO7B4h4s7sHiHizuweIeLO7B4h4s7sHiHizuweIeLO7B4h4s7sHiHizuweIeLO7B4h4s7sHiHizuweIeLO7B4h4s7sHiHizuweIeLO7B4h4s7sHiHizuweIeLO7B4h4s7sHiHizuweIeLO7B4h4s7sHiHizuweIeLO7B4h4s7sHiHizuweIeLO7B4h4s7sHiHizuweIeLO7B4h4s7sHiHizuweIeLO7B4h4s7sHiHizuweIeLO7B4h4s7sHiHizuweoerO7B6h6s7sHqHqzuweoerO7B6h6s7sHqHqzuweoerO7B6h6s7sHqHqzuweoerO7B6h6s7sHqHqzuweoerO7B6h6s7sHqHqzuweoerO7B6h6s7sHqHqzuweoerO7B6h6s7sHqHqzuweoerO7B6h6s7sHqHqzuweoerO7B6h6s7sHqHqzuweoerO7B6h6s7sHqHqzuweoerO7B6h6s7sHqHqzuweoerO7B6h6s7sHqHqzuweoerO7B6h6s7sHqHqzuweoerO7B6h6s7sHqHqzuweoerO7B6h6s7sHqHqzuweoerO7B6h6s7sHqHqzuweoerO7B6h6s7kF1D6p7UN2D6h5U96C6B9U9qO5BdQ+qe1Ddg+oeVPegugfVPajuQXUPqntQ3YPqHlT3oLoH1T2o7kF1D6p7UN2D6h5U96C6B9U9qO5BdQ+qe1Ddg+oeVPegugfVPajuQXUPqntQ3YPqHlT3oLoH1T2o7kF1D6p7UN2D6h5U96C6B9U9qO5BdQ+qe1Ddg+oeVPegugfVPajuQXUPqntQ3YPqHlT3oLoH1T2o7kF1D6p7UN2D6h5U96C6B9U9qO5BdQ+qe1Ddg+oeVPegugfVPajuQXUPqntQ3YPqHlT3oLoH1T2o7kF1D6p7UN2D6h5s7sHmHmzuweYebO7B5h5s7sHmHmzuweYebO7B5h5s7sHmHmzuweYebO7B5h5s7sHmHmzuweYebO7B5h5s7sHmHmzuweYebO7B5h5s7sHmHmzuweYebO7B5h5s7sHmHmzuweYebO7B5h5s7sHmHmzuweYebO7B5h5s7sHmHmzuweYebO7B5h5s7sHmHmzuweYebO7B5h5s7sHmHmzuweYebO7B5h5s7sHmHmzuweYebO7B5h5s7sHmHmzuweYebO7B5h5s7sHmHmzuweYebO7B5h5s7sHmHmzuweYebO7B5h5s7sHmHmzuweYebO7B5h5s7sHmHmzuweYe7O7B7h7s7sHuHuzuwe4e7O7B7h7s7sHuHuzuwe4e7O7B7h7s7sHuHuzuwe4e7O7B7h7s7sHuHuzuwe4e7O7B7h7s7sHuHuyXB/VxwVhweXDCs7KWC5JDdigO1UEdmkN3GAsuD07wysUrF69cvHLxysUrF69cvHLxytUrV69cvXL1ytUrV69cvXL1ytUrV6+sXlm9snpl9crqldUrq1dWr6xeWb1y88rNKzev3Lxy88rNKzev3Lxy88rNK3ev3L1y98rdK3ev3L1y98rdK3ev3L3y8MrDKw+vPLzy8MrDKw+vPLzy8MpjVR6Ph4M4JIfsUByqgzo0h+7glcUri1cWryxeWbyyeGXxyuKVxSuLV05eOXnl5JWTV05eOXnl5JWTV05eOXnl7JXdg8M9ONyDwz043IPDPTjcg8M9ONyDwz043IPDPTjcg8M9ONyDwz043IPDPTjcg8M9ONyDwz043IPDPTjcg8M9ONyDwz043IPDPTjcg8M9ONyDwz043IPDPTjcg8M9ONyDwz043IPDPTjcg8M9ONyDwz043IPDPTjcg8M9ONyDwz043IPDPTjcg8M9ONyDwz043IPDPTjcg8M9ONyDwz043IPDPTjcg8M9ONyDz6fyjyAJSkE5qATVIA1qQT0oNCQ0JDQkNCQ0JDQkNCQ0JDQkNCQ0Umik0EihkUIjhUYKjRQaKTRSaKTQyKGRQyOHRg6NHBo5NHJo5NDIoZFDo4RGCY0SGiU0SmiU0CihUUKjhEYJjRoaNTRqaNTQqKFRQ6OGRg2NGho1NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0Wmi00Gih0UKjhUYLjRYaLTRaaLTQ6KHRQ6OHRg+NHho9NHpo9NDoodFDY4TGCI0RGiM0RmiM0BihMUJjhEb4XMLnEj6X8LmEzyV8LuFzCZ9L+FzC5xI+l/C5hM8lfC7hcwmfS/hcwucSPpfwuYTPJXwu4XMJn0v4XMLnEj6X8LmEzyV8LuFzCZ9L+FzC5xI+l/C5hM8lfC7hcwmfS/hcwucSPpfwuYTPJXwu4XMJn0v4XMLnEj6X8LmEzyV8LuFzCZ9L+FzC5xI+l/C5hM8lfC7hcwmfS/hcwucSPpfwuYTPJXwu4XMJn0v4XMLnEj6X8LmEzyV8LuFzCZ9L+FzC5xI+l/C5hM8lfC7hcwmfS/hcwucSPpfwuYTPJXwu4XMJn0v4XMLnEj6X8LmEz1P4PIXPU/g8hc9T+DyFz1P4PIXPU/g8hc9T+DyFz1P4PIXPU/g8hc9T+DyFz1P4PIXPU/g8hc9T+DyFz1P4PIXPU/g8hc9T+DyFz1P4PIXPU/g8hc9T+DyFz1P4PIXPU/g8hc9T+DyFz1P4PIXPU/g8hc9T+DyFz1P4PIXPU/g8hc9T+DyFz1P4PIXPU/g8hc9T+DyFz1P4PIXPU/g8hc9T+DyFz1P4PIXPU/g8hc9T+DyFz1P4PIXPU/g8hc9T+DyFz1P4PIXPU/g8hc9T+DyFz1P4PIXPU/g8hc9T+DyFz1P4PIXPU/g8hc9T+DyFz1P4PIXPU/g8hc9z+DyHz3P4PIfPc/g8h89z+DyHz3P4PIfPc/g8h89z+DyHz3P4PIfPc/g8h89z+DyHz3P4PIfPc/g8h89z+DyHz3P4PIfPc/g8h89z+DyHz3P4PIfPc/g8h89z+DyHz3P4PIfPc/g8h89z+DyHz20Bkto6XvP5JA16arSHUQ8aTpfPF0lQCspBJagGaVBo1NCooaGhoaGhoaGhoaGhoaGhoaGhoaGh0UKjhUYLjRYaLTRaaLTQaKHRQqOFRg+NHho9NHpo9NDoodFDo4dGD40eGiM0RmiM0BihMUJjhMYIjREaIzSGa9jCpUUSlIJyUAmqQRrUgnpQaEhoSGhIaEhoSGhIaEhoSGhIaEhopNBIoZFCI4VGCo0UGik0Umik0EihkUMjh0YOjRwaOTRyaOTQyKGRQyOHRgmNEholNEpolNAooVFCI3xewuclfF7C5yV8boudWjLKQSWoBmlQC+pBw8l8PkmCQkNDQ0NDQ0NDQ0NDQ0NDo4VGC40WGi00Wmi00Gih0UKjhUYLjR4aPTR6aPTQ6KHRQ6OHRg+NHho9NEZojNAYoTFCY4TGCI0RGiM0RmgM17DFUYskKAXloBJUgzSoBfWg0JDQkNCQ0JDQkNCQ0JDQkNCQ0JDQSKGRQiOFRgqNFBopNFJopNBIoZFCI4dGDo0cGjk0cmjk0MihkUMjh0YOjRIaJTRKaJTQKKFRQqOERgmNEholNGpo1NAIn9fweQ2f1/B5DZ/X8HkNn9fweQ2f1/B5DZ/X8HkNn9fweQ2f1/B5DZ/X8HkNn9fweQ2f1/B5DZ/X8HkNn9fweQ2f1/C5LbZqzUiCUlAOKkE1SINaUA8aTiM0RmiM0BihMUJjhMYIjREaIzSGa9gCrEUSlIJyUAl6avT5zpQGtaAeNJzs1bhJEpSCclAJCo3L570YtaAeNJwuny+SoBSUg0pQDQqNFBopNFJoXD4fDyMJSkFPjSFGJagGPTVGMmpBPeipMUzj8vkiCUpBOagE1SANakE9KDRqaNTQuHw+1CgHlaAapEEtqAcNp8vniyQoNDQ0NDQ0NDQ0NDQ0NDQ0Wmi00Gih0UKjhUYLjRYaLTRaaLTQ6KHRQ6OHRg+NHho9NHpoXD4f5p7L54uG0+Xz0Y0kKAXl6+1QG0SX0R0rqGADOzgcba2Xo4AJzGABK6hgAzuImqAmqAlqgpqgJqgJaoKaoCaoJdQSagm1hFpCLaGWUEuoJdQSahm1jFpGLaOWUcuoZdQyahm1jFpBraBWUCuoFdQKagW1glpBraBWUauoVdQqahW1ilpFraJWUauoKWqKmqKmqClqipqipqgpaopaQ62h1lBrqDXUGmoNtYZaQ62h1lHrqHXUOmodtY5aR62j1lHrqA3UBmoDNbKkkSWNLGlkSSNLGlnSyJJOlnSypJMlnSzpZEknSzpZ0smSTpZ0sqSTJZ0s6WRJJ0s6WdLJkk6WdLKkkyWdLOlkSSdLOlnSyZJOlnSypJMlnSzpZEknSzpZ0smSTpZ0sqSTJZ0s6WRJJ0s6WdLJkk6WdLKkkyWdLOlkSSdLOlnSyZJOlnSypJMlnSzpZEknSzpZ0smSTpZ0sqSTJZ0s6WRJJ0s6WdJnlhTDAlZQwQZ2cATOLJkoYAJRa6g11OwyZBi1oB40nOwyZJIEpaAcVIJqUGj00Oih0UNjhMYIjREaIzRGaIzQGKExQmOExnANW2O3SIJSUA4qQTVIg1pQDwoNCQ0JDQkNCQ0JDQkNCQ0JDQkNCY0UGik0Umik0EihkUIjhUYKjRQaKTRyaOTQyKGRQyOHRg6NHBo5NHJo5NAooVFCo4RGCY0SGiU0SmiU0CihUUKjhkYNjRoaNTRqaNTQqKFRQ6OGRg0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ2NaffrKn5Mu08U0OzeDDNYwAoq2MAOjsB56TBRQNQ6ah21jlpHraPWUeuoDdQGagO1gdpAbaA2UBuoDdSGq6XH4wEKmMAMFrCCCjawg6gJaoKaoCaoCWqCmqAmqAlqglpCLaGWUEuoJdQSagm1hFpCLaGWUcuozUuHYZjBAl5qkgwVbGAHR6BdOiwUMIEZLCBqBbWCWkGtoFZRq6hV1CpqFbWKWkWtolZRq6gpaoqaoqaoKWqKmqKmqClqilpDraHWUGuoNdQaag21hlpDraHWUeuoddQ6ah21jlpHraPWUeuoDdQGagO1gdpAbaA2UBuoDdRGqNlKQkcBE5jBAlZQwQZ2EDVBTVAT1AQ1QU1QE9QENUFNUEuoJdQSagm1hFpCLaGWUEuoJdQyahm1jFpGLaNGlghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVCliSyJJEliSxJZEkiSxJZksiSRJYksiSRJYksSWRJIksSWZLIkkSWJLIkkSWJLElkSSJLElmSyJJEliSyJJEliSxJZEkiSxJZksiSRJYksiSRJYksSWRJIksSWZLIkkSWJLIkkSWJLElkSSJLElmSyJJEliSyJJEliSxJZEkiSxJZksiSRJYksiSRJYksSWRJIksSWZLIkkSWJLIkkSWJLElkSSJLElmSyJJEliSyJJEliSxJZEkiSxJZksiSRJYksiSRJYksSWRJIksSWZLIkkSWJLIkkSWJLElkSSJLElmSyJJEliSyJJEliSxJZEmeWTK3+RMwgRksYAUVbGAHR6CgJqgJaoKaoCaoCWqCmqAmqCXUEmoJtYRaQm1mSTdUsIGmNgxH4MySiQImMIMFrKCCDUQto1ZQK6gV1ApqBbWCWkGtoFZQK6hV1CpqFbWKWkWtolZRq6hV1CpqipqipqgpaoqaoqaoKWqKmqLWUGuoNdQaag21hlpDraHWUGuoddQ6ah21jlpHraPWUeuoddQ6agO1gdpAbaA2UBuoDdQGagO1EWrl8QAFTOCllsSwgBW81K5tfpMtvnTs4Ai0LFkoYAIzWMAKoiaoCWqCWkItoZZQS6gl1BJqCbWEWkItoZZRy6hl1DJqGbWMWkYto5ZRy6gV1ApqBbWCWkGtoFZQK6gV1ApqFbWKWkWtolZRq6hV1CpqFbWKmqKmqClqipqipqgpaoqaoqaoNdQaag21hlpDraHWUGuoNdQaah21jlpHraPWUeuoddQ6ah21jtpAbaA2UBuoDdQGagO1gdpAbYSarex0FDCBGSxgBRVsYAdRI0sqWVLJkkqWVLKkkiWVLKlkSSVLKllSyZJKllSypJIllSypZEklSypZUsmSSpZUsqSSJZUsqWRJJUsqWVLJkkqWVLKkkiWVLKlkSSVLKllSyZJKllSypJIllSypZEklSypZUsmSSpZUsqSSJZUsqWRJJUsqWVLJkkqWVLKkkiWVLKlkSSVLKllSyZJKllSypJIllSypZEklSypZUsmSSpZUsqSSJZUsqWRJJUsqWVLJkkqWVLKkkiWVLKlkSSVLKllSyZJKllSypJIllSypZEklSypZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlsylqel6ZjmXpi4UMIEZLGAFFWxgB1ET1AQ1QU1QE9QENUFNUBPUBLWEWkLNsmR+T8CyZGEBK6hgAzs4Ai1LFgqIWkYto5ZRy6hl1DJqGbWCmmVJfhgmMIMFrKCCDezgCLQsWYhaRa2iVlGrqFXUKmoVtYqaoqaoKWqKmqKmqClqipqipqg11BpqDbWGWkOtodZQa6g11BpqHbWOWketo9ZR66h11DpqHbWO2kBtoDZQG6gN1AZqA7WB2kBthNpcmrpQwARmsIAVVLCBHURNUBPUBDVBTVAT1AQ1QU1QE9QSagm1hFpCLaGWUEuoJdQSagm1jFpGLaOWUcuoZdQyahm1jFpGraBGlnSypJMlnSzpZEknSzpZ0smSTpZ0sqSTJZ0s6WRJJ0s6WdLJkk6WdLKkkyWdLOlkSSdLOlnSyZJOlnSypJMlnSzpZEknSzpZ0smSTpZ0sqSTJZ0s6WRJJ0s6WdLJkk6WdLKkkyWdLOlkSSdLOlnSyZJOlnSypJMlnSzpZEknSzpZ0smSTpZ0sqSTJYMsGWTJIEsGWTLIkkGWDLJkkCWDLBlkySBLBlkyyJJBlgyyZJAlgywZZMkgSwZZMmaWJEMBE5jBAlZQwQZ2cARm1DJqGbWMWkYto5ZRy6hl1DJqBbWCWkGtoFZQK6gV1ApqBbWCWkWtolZRq6hV1CpqFbWKWkWtoqaoKWqKmqKmqClqipqipqgpag21hlpDraHWUGuoNdQaag21hlpHbWZJMUxgBk1NDSuoYAM7OAJnlkwUMIEZRG2gNlAbqA3Uhqvlue51oYAJzGABK6hgAzuImqAmqAlqgpqgJqgJaoKaoCaoJdQSagm1hFpCLaGWUEuoJdQSahm1jFpGLaOWUcuoZdQyahm1jFpBraBWUCuoFdQKagW1glpBraBWUauoVdQqahW1ilpFraJWUauoKWqKmqKmqClqipqipqgpaopaQ62h1lBrqDXUGmoNtYZaQ62h1lHrqHXUOmodtY5aR62j1lHrqA3UBmoDtYHaQG2gNlAbqA3UyBIhS4QsEbJEyBIhS4QsEbJEyBIhS4QsEbJEyBIhS4QsEbJEyBIhS4QsEbJEyBIhS4QsEbJEyBIhS4QsEbJEyBIhS4QsEbJEyBIhS4QsEbJEyBIhS4QsEbJEyBIhS4QsEbJEyBIhS4QsEbJEyBIhS4QsEbJEyBIhS4QsEbJEyBIhS4QsEbJEyBIhS4QsEbJEyBIhS4QsEbJEyBIhS4QsEbJEyBIhS4QsEbJEyBIhS4QsEbJEyBIhS4QsEbJEyBIhS4QsEbJEyBIhS4QsEbJEyBIhS4QsEbJEyBIhS4QsEbJEyJJEliSyJJEliSxJZEkiSxJZksiSRJYksiSRJYksSWRJIksSWZLIkkSWJLIkkSWJLElkSSJLElmSyJJEliSyJJEliSxJZEkiSxJZksiSRJYksiSRJYksSWRJIksSWZLIkkSWJLIkkSWJLElkSSJLElmSyJJEliSyJJEliSxJZMlc95qHYQErqGADOzgCZ5ZMFDCBqClqM0uqoYIN7OAInFkyUcAEZrCAqDXUGmoNtYZaR62j1lHrqHXUOmodtY5aR62jNlAbqA3UBmoDtYHaQG2gNlAboTbXvS4UMIEZLGAFFWxgB1ET1AQ1QU1QE9QENUFNULMsuT5Lnee614mWJQsFTGAGC1hBBRuIWkIto2ZZYh9SnuteF2bwUqvz71ZQQVNLhh0cgZYlCwVMYAYLWEEFUSuoFdQqahW1ilpFraJWUauoVdQqahU1RU1RU9QUNUVNUVPUFDVFTVFrqDXUGmoNtYZaQ62h1lBrqDXUOmodtY5aR62j1lHrqHXUOmodtYHaQG2gNlAbqA3UBmoDtYHaCLW57nWhgAnMYAErqGADO4iaoCaoCWqCmqAmqAlqgpqgJqgl1BJqCbWEWkItoZZQS6jN9SXDcATO9SUTBUxgBgtYQQUbiFpGraBWUCuoFdQKagW1glpBraBWUKuoVdQqahW1ilpFraJWUauoVdQUNUVNUVPUFDVFTVFT1BQ1Ra2h1lBrqDXUGmoNtYZaQ62h1lDrqHXUOmodtY5aR62j1lHrqHXUBmoDtYHaQG2gNlAbqA3UBmoj1Na614kCJjCDBayggg3sIGqCmqAmqAlqgpqgJqgJaoKaZUktF1qWLBTQrhSqYQYLWEEFG9jBEWhZslBA1DJqGbWMWkYto5ZRy6gV1ApqBbWCWkGtoFZQK6gV1ApqFbWKWkWtolZRq6hV1CpqFbWKmqKmqClqipqipqgpaoqaoqaoNdQaag21hlpDraHWUGuoNdQaah21jlpHraPWUeuoddQ6ah21jtpAbaA2UBuoDdQGagO1gdpAbYTaXPe6UMAEZrCAFVSwgR1ETVAT1AQ1QU1Qsyy5PqOZ57rXhQ281DQbjkDLkoUCJjCDBayggg1ELaGWUbMsUTt0y5KFGSxgBRVsYAdHoGXJQtQKagW1glpBraBWUCuoFdQqahW1ilpFraJWUauoVdQqahU1RU1RU9QUNUVNUVPUFDVFTVFrqDXUGmoNtYZaQ62h1lBrqDXUOmodtY5aR62j1lHrqHXUOmodtYHaQG2gNlAbqA3UBmoDtYHaCLW57nWhgAnMYAErqGADO4iaoCaoCWqCmqAmqFmWXJtg57nudWEHL7V2WXque10o4KXWxTCDBayggg3s4Ai0LFkoIGoZtYyaZUlvhgo28FK7tknOc93rRMuShZfasNaxLFmYA23QdiP739XQ/ndTsDG7sIIKNrCDI9BG57VjWZ4rKRcWsIIKNrCDw3GupFwoYAIzWMAKKtjADqImqAlqgpqgJqgJaoKaoCaoCWoJtYRaQi2hllBLqCXUEmoJtYRaRi2jllHLqGXUMmoZtYxaRi2jVlArqBXUCmoFteuX7vncx1DBBnZwBF6/dI5yoRomMIMFNLVmqKCpdcMOjkB9gAImMIOXmohhBRW81CQbdnAEXr90zwdOhgImMIMFrOCllh6GDezgCLx+6VKyI7tCwzGBl1qyhrpSw7GCl1qexRrYA4edRTG86mare+XD8+GUoVWwQx8N7OBwtNWRjgJedcvDMIMFrOClZrPctjrS8VIrxXAEXvngKGACM2hq3bCCCjbQ1IbhCLzyIdn0uq2OdExgBi81u+221ZGOCjawgyMwm5odThYwgRk0NTvIXEEFTS0ZdnAElgJeFeyOwNY2Jrsat7WNzwdkF5q7FwqYwAwW8Krb7NzM3QuvI2s2SszdC0egWfr61ES2BY2OGSxgBS8J+0G3BY2OHRyBZumFAl5qvRpmsIAVNDU7XrP0wg6amh2ZWXqhgKZmDWWWHtYBZulh3WKWXqhgAzs4As3SdtVhSxcdC1hBBdvCYusK0/XtgWLrCh1NYlx4+S1f2ykXW0HoWMAKKtgCk/3XZNjADo7AyxeOAiYwgwWsIGoZtYxaRq2gVlArVjcbWoViaBXUcATWB2gVmmECM1jACipoda0D1CpYB1xmyGJHdpnBsYJXBbGmvszg2MEReJnBUcBLTeyMWwZNzU6+VVBBq2vDqFsFa4eeQavwMLQKdppdwQZ20OpaO4wHKKCpWeuMDBYQtYHaQG2gNoajrbKbfWGr7BwTmMECVrB7F9rKudmFtnJudpatnHMsYPW+sJVzjg3sYPSmrZxzFO83WznnmL2zbOWcYwW7d6Gthpv9ZqvhHLN3oa2GWw2VK6hgA7t3lq2GW1geoHhn2Wo4xwyiVlArqBXUSvSmLSnLyZrEzLCwg9fhJDs3M8NCAROYwQJeh5OtScwMCxvYwUstm/D1y+Ao4KWWbRCYcRYW0NSsN804CxvYQVOzjjWLZOtYs8jCAlbQ6lrzmUWy9ZBZJFtfmEUMbfGYo4CX2nWFV2zxmGMBK3ipXU8vi60Yy9cFXLEVY88nbxde133PB1WGl0S1f2YeWpjBAlZQwQZeatf6iGIrxhaah6oJm4cWJjCDBaygqVk72O/bwg6OQPt9Uzsc89vCBF5qakdmfltYwUvtumortmIsqx2D+W3hCDS/LRQwgVa3GyrYAq8LuOckj2EHL4lmXXjdnjkKmMAMFrCCCpqanZs5ttnQMMdONMcuFDCBGbS6dprmwuuCs9hirOech6GACbQKdvLmwoUVVLCBHbzUuvWm/XwtvNS6NZ95c2EGr7rd2sH8dn0SrdgCK0c73maYvKFsgZVjAStodYthAzsYvWkLrBwFRE1QE9QENbPeRPPFdYFcbPWTYwfNFyZhvlgoYAIzWMBLuFuTmC8WNrCDI9B8sVDAq27vhhVUsIEdHIF2NbhQwARmELWKWkWtolZRq6gpaoqaoqaoKWqKmqKmqClqilpDraHWUGuoNdQaag21hlpDraHWUeuoddQ6ah21jlpHraPWUeuoDdQGagO1gdpAbaA2UBuoDdRGqJXHAxQwgRksYAUVbGAHURPUBDVBTVAT1AQ1QU1QE9QEtYRaQi2hllBLqCXUEmoJtYRaQi2jllHLqGXUMmoZtYxaRi2jllErqBXUCmoFNbKkkCWFLClkSSFLCllSyJJClhSypJAlhSwpZEkhSwpZYuuc8jX/UGyd00LLkoXJE7HMAJlYwAoq2MAORuiW9gAFRK2h1lBrqDXUGmoNtYZaR62j1lHrqHXUOmodtY5aR62jNlAbqA3UBmoDtYHaQG2gNlAboVYfD1DABGawgBVUsIEdRE1QE9QENUFNUBPUBDVBTVAT1BJqCbWEWkItoZZQS6gl1BJqCbWMWkYto5ZRy6hx2VG57KhcdlQuOyqXHZXLjsplRy2oFdQKagW1glpBraBWUKuoVdQqahW1ilpFraJWUauoVdQUNUWNLKlkSSVLKllSyZJKltjipufPr+EItCxZeKnZXKYtbnLM4KV2PbottrjJUcEGdnAEWpbYxKgtbnJMYAYLWEEFG9jBEThQG6gN1AZqA7WB2kBtoDZQG6Fmi5scBUxgBgtoas1QwQZ2cARalix8qj0vhQwTmMFyoRhWUMEWeKVGsdlbW7BUbPbWFiw5VtAqVMMGdnBceN2h2IIlRwETaGp2QrmAFVTQ6lrzFaswDDNYQGtfkzDPL2xgB0egeX7hdbw2u2iLkBwzeKnZ5KEtQnJUsIEdHIGX54tNNNoipGJTirYIyTGDBayggg3s4AhsDxC1ZmrWvi2DBTQ1a9SmYAMvtTT/7gi8PO94qSXrt8vzjhm81Gy+zxYhOSp4qeVZrIMj8PJ8sWk3W4TkmMBLzabHbBGSYwUvtWI9f3nesTvacqN5xrawqNg0rC0sclSwgR0cgZePi03R2cIixwRex2vTbrawyLGCdryzWAM7aGr2d83dCwW0umJYQQUb2MERaO5eKGACM4haRi2jllHLqGXUCmoFtYJaQa2gVlArqBXUCmoFtYpaRa2iVlGrqFXUKmoVtYpaRU1RU9QUNUVNUVPUFDVFTVFT1BpqDbWGWkOtodZQa6g11BpqDbWOWketo9ZR66h11DpqHbWOWkdtoDZQG6gN1AZqA7WB2kBtoDZCzRZ8OQqYwAwWsIIKNrCDqAlqgpqgJqgJaoKaoCaoCWqCWkItoZZQS6iRJZ0s6WRJJ0s6WdLJkk6WdLKkzyxJhhksYAUVbGAHR+DMkommVg0TmEFTa4YVVPBS02LYwRFoWWIPDGwRV7lWfBRbxOXYwA6OQMuHhdfx2gSxLeJyzGABLzWbzbdFXI4NvNRsjt8WcS20fFhoamqYwAwW0NSsSSwJbDbflmsttCRYKOBV1+b4bblWsdl8W65VbDbflms5KtjAS83m+G3ju4WWBAsFNDU7N7O/3SXZeq5i8zu2nqvYTI6t5ypj/rMODkdbz+UoYAIzeKnZ/ZCt53JsPozG9PzEETg9P1HABGawgBVUEDVBTVBLqCXUzPN2VWyLuBwLaCc0/66CDezgCDTPLxQwgRksIGoZtcvz1e58bBGX4wi8PO8oYALzhdYtl+cdK6igqVXDDo7Aamp2ZNXUumECTW0YFvBSs+szWwbm2MAOjsArHxwFTGAGC4iaoqaoKWqKWkOtodZQa6g11BpqDbWGWkOtodZR66h11DpqHbWOWketo9ZR66gN1AZqA7WB2kBtoDZQG6gN1IarVdviztHUxDCBGSxgXb8t1ba4c2xgB0egZclCAROYQTuLZDjWz1e1bevqdcdabds6xwRmsIAVVNDawdRyinbInHHmjHMFFbT2tSMzzy8cgeb5hRISBbWSwQJWUMEG9jgG8/xE8/xCetM8P4/BPL+wgKhV1Cpq4fn6qIwdZewo56aMHaUllZZUWnJ63o5BaUmlJRW1hlpDrdGSjZZstGTj3Br9Nj0/kZZstGSn36bnJ9KSHbWOWket05Kdluy0ZOfcBuc26LdBSw5actCSg5acnlfDBppaMxyOMj0/UcBL7VrVXm2RnGMBK6hgAzs4Ai/P12vlVrUFdY52/dANq7vQls49HxUYNrCDIzBFD0kSMIEZLGAFFYwesgV1jtFDtumco4AJzGABK2hnkQ1HoOXDQmsdawfLh2RHZvmwsIAVVLCBHRyBlg8Lra4aFrCCCjawgyPQkmChgAlETVFT1BQ1RU1RU9Qaag21hlpDraHWUGuoNdQaag21jlpHraPWUeuoddQ6ah21jlpHbaA2UBuoDdQGagO1gdpAbaA2Qs3WAjoKmMAMFrCCCjawg6gJaoKaoCaoCWqCmqAmqAlqglpCLaGWUEuoJdQSagm1hFpCLaGWUcuoZdQyahm1jFpGLaOWUcuoFdQKagW1glpBraBWUCuoFdQKahW1ilpFjSxJZEkiSxJZksiSRJYksiSRJYksSWRJIksSWZLIkkSWJLIkkSWJLElkSSJLElmSyJJEliSyJJEliSxJZEkiSxJZksiSRJYksiSRJYksSWRJIksSWZLIkkSWJLIkkSWJLElkSSJLElmSyJJEliSyJJMlmSzJZEkmSzJZksmSTJZksiSTJZksyWRJJksyWZLJkkyWZLIkkyWZLMlkSSZLMlmSyZJMlmSyJJMlmSzJZEkmSzJZksmSTJZksiSTJZksyWRJJksyWZLJkkyWZLIkkyWZLMlkSSZLMlmSyZJMlmSyJJMlmSzJZEkmSzJZksmSTJZksiSTJXlmSTPs4AicWTJRwARmsIAVVBA1RU1Ra6g11BpqDbWGWkOtoRbPN6stsHQcgTaXuVDABJraxAJW8FK7nm9WW2BZr9cVqi2wdByBliULBUxgBgtYQQVRG/7sttoCy4m2wNLRn91WW2DpmMFrXs7Ggy2wdFSwgR0cgTYrsVDABGYQNUHNUuN6g6Paosl6vZVRbdFkzfYXLB8WFrCCVsFOyDx/vZVRbSGkYwYLWEEFr/a9XsytthDScQSa5xcKmMAMmpr1hXl+oYINtGfjD8MRaE8fFpqaNZR5fmEGC1hBBRvYwRFonl+ImqKmqClqipqipqgpaopaQ808P7vQPL8wgwU0tWLYo9/sSmGiXSkstLOwEWVXCgszaGdhw6gzHjrjYbp7ImodtYHaYPQNRt9g9A1G30BthIQtbqzXIoJqixsdE2iHPv9uASuo4FX3WnBQbXGj4wi0C4GFl9r12K7aMsZ6PV6rtozRUUGrmw07OALtJ3+hgAnMoKkVwwoq2MAOjkD7yV8ooBVTQ/tn1nzm44nm44UCJjCDdpDWqObjhQo2sIMj0H67F15qaq1uPl6YwQJWUMEWfWE+XjgCzccLbex0Q5rEbLqwgR28iqmNh0aTNJrEDLnQDtLU7Ed4YQOvumrd3eiATgd0OqCj1lHrqJlNFyrYQLq7ozaQsEeHD2sSe3S40A7dxo4ZcmEHh6OtG3QUMIHWm2pYwAqaWjNsYAdN7cooWzfoKKCvoqtr3eDEAlZQwQZ2cATO1YQTBbS6ybCCdhbdsIEdHIFm04UCJvBqs/YwLGAFL7XrHbxq2585dtDU7HjN3QsFtDbLhhksYAUVbGAHR6D9Si8U0M7CGsp8vFBBO4v5dzs4As3HzUaU/R4vvNqs2SCw3+OFBTQ1G2dm9IUN7OAItN/jhQKamo1Js//CAlZQwQbammk7ofnWoR3kfBvBTmi+jTCxgBVUsIEdvFaBzkYdD1DABNpbfHZutoJ4YQUVbGAHh6NtaeYooLVON6yggtY6w7CDI9A8f62rqLbG0PHqi2uJRbU1ho4FvNSudRXV1hg6NrCDI9B+sBcKaGrZMIMFrKCCDbzazB6ntLmhhZ38fMF+YgYLWEEFG9jBqy/spq3NF+wnCpjAS+0xsYAVVLCBHRyBc/OLiQLS85Wer/R8pecrPV/peaXnlZ5Xel7peaXnlZ5Xel7peaXnlZ5v9Hyj5xs93+j5Rs83er7R842eb/R8p+c7Pd/p+U7Pd3q+0/Odnu/0fKfnBz0/6PlBzw96ftDzg54f9Pyg5wc9P6Ln++MBCmitUwwrqGADrS+q4Qicnp8o4HUWD/tncwuaiQWsoIIN7OAItHeNFlofd8MCVlDBBnbwOotrV55qawEdBUzgpXYtq6q2FtCxgpfasCOz3/mFHTS1a3DZWsB6rSGqthawDjscu4pfmMECVlAD7XJ8WG/a5fjC5z/Ta5FRtQWAjnqhGLa1I1mdu7gtHIG2i9tCARNoda11LpuqXT/Mndns3n/uzLZQQKtgB2nbOC0sYAUVbKCpWaNeV+YLrytzfdjou8zrmEA7XusA25rJZpNs+d5qkvEABUxgvtBOfhSwgrTvZUjHDoaareRztGLDsIIKXsVsCYut2XMcgZcLHQVM4HXo9tzf1uw5VlBBU+uGHRyBlwvVHvbbmj21x9m2Zs8xgwWsoIIN7OAIzKZWDAU0tWqYwQJW0NTs0HMDOzgCywMUMIEZNDXroVLBS83Guq3Zc+zgCLx+jx0viWzj4fKxYwEvCZtEtYV6jg00CWudOgLVJKwdLh87JtDU1LCAFVSwgR0cgc3UbBg1AROYwQJW0NSs56e77dymu+0vTHdPTGAGC1hBBZsnoi3JcxyBMwkmmpodzkyCiRksYAUVbGAHx0K1xXd6TROqLb5zLGAFFbzqXlO2aovvHEeghcJCARN4qV1Timq7wzlWUEFTU8MOjkALhWu+T22hnmMCTW0YXmrXHJ7aQj2tdjgWCgsb2MERaKGw8LrAsIa0q/FJNUiDWlB3Mldec05qq+oWmisX2pWZUQrKQSWoBmmQVTQds9s1x6eP+YadUQmqQXYDb9SCetBwsgXzkyTIRKy3zGULra2ti8xlCxW0w7QuMj9VG13mp4XXWVq/mZ3qRAUb2MEROK90jaI5RzTniOYc0ZwjmtMsY41oa9dmI9raNb3mFdXWrjlep3rN/6mtXXO8jvSa09O5dm3+1R40nOxSdpIEpSCraAdiBlA7EDOA/e82/idJkF2bGeWgElSDNKgFmUg1HIE27q/ZOLVlaY4JtMNshlahG45Au/icJNEw9vu2MIMFtLJ2YPb7trCBPRrcnDTRnLQQtYpaRa2iVlGrqFXUKmoVNUVNUVPUFDVFzX7qFuoa6rYobQ5fW5TmGIPaFqU5SqD9ODU7BDPTwgxeY9y60m4bJ2lQC+pBw8l+lpoNQftZWphA05l/t4DX+TU7P/tZWtjADg5HWyvmKKCpdcMMFtDU1FDBBpraMByB9mO18AoJqzW3rDDKQSWoBmnQVfGafVBb+aXXPIPayi/tdvz207OwggpeR3rd8aqt/HIcgWbBhQKaWjXMYAFNrRkq2EBTsxYwu06069FhJ2R+XZhAW0FvVIJqkAa1oO5knhzWROa+YS1g7rvuatXWcTk2sIPXkQ47QXPfQgETmEF7t8aoBmmQvWhl1IOGk/30TZKgFGQidnb2y7ewgj3QzDqs8c2sC+1VM6MSVIOsReww7XdvYQefB9oe1qaXXx3lQmvey6+O+UJryMuv7WFD6fJre1g7XX5tDzvYy6+OHbQ5uCfN5ViTJMiKTrR/3g3tnw/D62Cv5cpqC6zatbZcbYFVu97EUFtK1a5bSLWlVI4K2gA26kHD6fJgu5Z6q62Natfia7W1UfZrZUujFl0HJRPtoOyo8wMUMIFXC4pp5QJWUMEGdnAElgdoda2NLgu1ZG10/Zy1ZG10Wacla6Pr58wxgwVsgWoVrOVUQKtgzXT5oSVrpmZ/15qkCZhAU7N2aAWsoEbd1vivHRyB/QFKnHFPYAYLyLn1HidkJpg4OGMb7nM02HBP1tQ23JM1tQ33hQ3s4HC0JUOOAl7He91Qqy0ZcizgpWaXlrZkqF23zmpLhprdEtiSoXbdOmuZ7rj6okx3TBTQ6k6soIJ212TUg4aTueO6b1ZbGdSuG2Atc27EqAXZQXXD66DsGsU2U3MUMIFXE9jNga0hcqyggg3s4Ag0dyy0utaI5o5iB2nuKNaI5oNiJ2k+WFhBBa2njXrQcJqGMZKgFJSDSlAN0qDQ0NDQ0Gih0UKjhUYLjRYaLTRaaLTQaKHRQqOHRg+NHho9NMxP1shmp0nDaf6iGElQCspBJagGaVBojNAYrmHLeRZJUArKQSWoBmlQC+pBoSGhIaEhoSGhcV2tNbvNt4U2zX6DbaFNs/tzW1LT7PbQFsRcU+1q62EW5aDrKOyO2Fa4NCtkI3aSBKWgHFSCapAGtaAeFBoaGtcA7nao1wBelIOeGnYpaUteFmnQU8Ou92y9y6LhdA1gu4yzvbUWpaCrEay1rgG8qAZZw1whZCtaml052IqWMf9jDipBNUiDWlAPGk7XwF0kQaExQmOExgiNERojNEZoDNewBS52CWfrWxaloEujG5WgGmStYGgj0u7mbLlKs1t5W67iWMAKKtjADo7Aa67AUUDUEmoJNbOA3d/aIhbHBnZwBNrPxEIBE5jBAqKWUcuo2ZeN7DJ0fsNvon3ZaKGACcyg1U2GdryXE+Z3+ewybH6Xb2ECrwp2/Te/y7ewggo2sAfab4nNqNgSlGbXoLYExVFBO+P5zzo4Au3nY6GACcxgASuoIGoNNfsdsakP2+bKUUBLLesW+y1ZaLll7dstuKx9uyWXnbz92izsoIWXCdsPzkKLSOsA+8mxm/X5rT27FJjf2ltYQQUb2B1tCUqzW3ZbgtL6/K/X8Voy2hIUxwZex2vhaEtQFtoPy0IBE2h1q6FVUEOrcJ2mLStxFDCBGSxgBRVsoKl1wxFo3lxoasMwgRks4KVm2W+LTRwbeLWvzZXOb+JNnN/qnXg5y3445zfxFmawgBVU8OpN+0Vt8a1ebfGtXrXFJs1+gmyxiWMCM6jg1Tr222TLShyvO3DTtXmCSc3JfgCtZewHcFIKykElqAZpUAvqQcPJjGfTF7Y6xDGBV//Yj40tCXFU0PrHOtvctnAE2pctbcLAloQ4JjCDBayggg3s4HCc3w5cKGACM1jACirYwA6iJqgJaoKaoCaoCWr2C2t9YQtFHDv4VOvz714udhTwuu6y+RZbPuJ4XXnZD5ItH3FUsIEdNLWrY235iKOpdUNTsyO7XNxtnsWWjzhW8FKz2RdbPuLYQWvJy7rz24ELBUxgBgtodS8z2fZQ3eZv7HuA3e7JbSWJYwYLaMdrJ18VbGAHR6B9+Xa2jn35dh6DXQPb77ltJdVtOsG2knK81NL8u5eazWPYVlKOl1qaEpeaTSfYqhNHu06wDrCv2dq9vq0ZEbs9tzUjjgJeR2bTCbY9lGMBK6hgAzt4HdkUvtztKGCOIzNLL6ygHbqdsVl6YQdN4jp0W1TiKKDdbjTDDF4nZLMPturEUUFTm9jBEWiWXihgAjNYwAoqiJqgJqgl1BJqCbWEWkItoZZQS6gl1BJqGTWztE2+2KoTxwxaSw7DCip4DQ2bOrFVJ44j8LK046VmV0a26qTb3IqtOuk2X2KrThwrqGADOzgCzf4LBUwgahW1iprZ3356bQGKYwdHoD5AAROYQes3azP78PVCBU3NRrXZf+EINPsvNDXrwpbADCpoFaw3u1UwtS5gAjN4VbD5CVs+0m1SwpaPOAqYwAwW8Gpfuzqz5SOODezgWNhsRydHAU3tYZjBAlbQ1KphA01NDUegPMDLhdctW3vMD1RPzGABK6ig1W0X2k/zdQPebKFIv27Amy0UcayggtfxXrejzRaKOI5A+2leKOClptZQ5uOFBayggg00NTte8/FE8/FCAU3Njtd8vLCAl1qzIzMfX7dszXZ/crzUmrWZ+Xii+bjZ4ZiPFyYwgwWsoIIN7OAIVNQUNUVNUVPUFDVFTVFT1BS1hlpDraHWUGuoNdQaag21hlpDraPWUeuoddQ6ah21jlpHraPWURuoDdQsH5pZz/JhYQEreHmom3HsmmBhB4ej7f7kKGACM1hAO4vL6LYwpjf7ryKgHW83zGABK6hgA3ugXaRfMwrNFsjMJrEVMvOMbYmMYwM7eLXvNY3QbJGMo4AJjN60vZscK6hgAzsYvWkLatYxmOcXJjCDJY7BPL9QQdQKagU1PC94XvC84HmpMXak0pKVlqy0pHl+HkOlJZWWxPOC5wXPC54XPC94XvC84HmZnrdjaLRkoyUbLdloSfP8NVXUbJ8nR2vJZNjADo5A83y3Yub5hQnMYAErqGADTc2MY56fOBjgZvRpMjP6wgJWkKFhFwIL6awRnWULdhwFTGB0li3Ycayggg3sYAzEJA9QQDuLblhBBe0shuFVd9iR2YXARLtzXyhgAjNYwAoqaHWvoWHLdhwFTKDVTYYFrKCCdplkJ2ShsHAEWigsFDCBGSyg1bXDMfsvHIFm/4V2FtnQLyKbLd5xVPCqO6yHzOgLR6AZ/ZrGarZ4Z/0zTWAGUVPUFDUz+sIOjsD2AFFrSMSVebM9lhw7aId+WcT2WHK0JrHBZT5emMFr/u9hQ8OeYS1U0J6z2THYY6yFI9AeZC28phof1gH2KGthBgtoatbU9ujqYU1tz64MbfmOo9VVwwRmsIAVVLCBptYMR6A8QAETmMECVtCKXY1qi3zGNY3VbFskxwJWUMEGXgd5TQs1W/yzMD9AAROYwQKaWjZUsIEdHIHlAUr0hT1KXpjBAlqriyFNUh+ggAm0Qy+GNEmlSWoH7SBNTR+ggNYk1t1KBygdoHSAoqaoKWr2VHnifKw8UUC6u6HWkGh9Tbs1W1+00ObaFl6Xocna7LKpYwbt0OffraCC16EnUzObLhyBNpOerH1tJn1hAjNYwAoq2MAODkdbi+QoYAIzWMAKKtjADqImqAlqgpqgJqgJatfv8bCmthVKjh20lrzMYN+HdLwGwaxgnl+YQVtfoIYVNLVq2MAOmtr1A2hLmhxNrRkmMIOX2rWqq9mSJsdL7Zo5bbakyfFSy3YW5vmJ5vmF1pJW12bSF2awgBVU0OpaO5jRs52bGT1bO9QCVlBBO147ebP/whFo9l8ooC13sX4z+y8sYAUVbOClVux4zf4Tzf4LBTQ1O16z/8ICmpodmT1au2bKmq2OcrzUbObJ1kctvPJh2JWNrZByTGAGC1hBBRvYwRE4UBuoDdQGagO1gdpAbaA2UBuhZkuqHAVMYAYLWEEFG9hB1AQ1QU1QE9QENUFNUBPULB/s+sz2TVpo+bBQQJsQfBhmsIAVVLCBHRyBNi2/0M4iG9rxFsMG2vFWwxFonl8oYAIzWECrew1wWzW2mqRyxub5hRksoLVvM1SwgR2kNxU1pTeV3lR6U+lNpTeV3jTPz8NRelPpzUZvNs7NPG93KHMx2UJTG4YVVLCBtl5rFhuB5vmFAiYwgwWsoK0Ns0EwF6BNHNFZc+GZjYe58mxiAjNYogMGnTXorEFnDTprGv3CuQRtYXSWYnTF6IrRFaMrRleMrhhdMbotTxvXKqZmy9McC2gNpYbWUHZkZumFHRyBZumFAiYwgwW0ut2wgyPQftwXWt1hmMAMFtB+LO2E5o/7xAZ2cATOH/eJAiYwg7aQwc7ClrUs7KA9frfDseVpCwW0hYbJMIMFtIUMdvK2PG1hA6+zsIl9201podl/oT88b7abkmMGC1hBBRvYwRHYHiBqDbWGWkOtodZQa6g11BpqHbWOWketo9ZRM/vbdJMtZXNsoC1DsEa1GbiJlgQ2eWhL2RwTaA/7TcIm4xbaw37zm03GLWygL0NotsfSxDYXo04UMIF2btWwgBVUsIE90H7cbS7edlMaNpNuC9yGTTTabkqODezgNc5s5tSWvTkKmMAM2gLaZFhBBe3p+vy7HRyB8+n6w1DABGawgBU0tWx4ndu1uq/ZsjfHEWhJsFDABGawgBVUELViatYBdvE/0S4PFpqadYvlw8IMKni1TrHmswUzCwVMYAYLeLWOTYTZGjnHBtqqNusA+8mfONfOTbTjtaFhP/kLM2g3QRMrqGADOzgC7SffJlFtFZ1jAm2xng1w+8lfWEFbr2ceMs8v7KCdm53xXBln0zNradzitnHfeASv5XGLLehtxmctkFucNy4bT1011o3bxlO3GQ94LpRbPHW7cdo4b1w2nrrDeC7DexgPOD02lo3nUrxkPNfiZeO5GK8Y141147bx1LV2SAPOj41l46lr55unlh2/mf1h0zm2PO7JdmzZtNL8t33jAc8lcotl47Rx3th0Lbltm6XgGGD2oUXHEWhmXyhgAqeK9U4tG9eN59nZWc8LgsV94wHPBXWLZeO0cd64bFw33nR107Vrg4dNnNjKOme7OnCWjdPGeWPTtbkN29UpWDduG09dGwltwP2x8dS14+xzyaONkJ43nosezbm9bmy6Fpa2Wi+4bzzguRx3sWycNs4bl43rxpvu2HTHpjvQHY/HxrJx2jhvXDauG+vGbeO+8aYrm65surLpyqYrm65surLpyqYrm65sumnTTZtu2nTTpps23bTppk03bbpp002bbt5086Y7E+lakdZsmV9w2bhubKsxxLCBHRyBlkwLBUxgBgs4T+cK2DEzpxnOo67GaeO8cdm4bqwbN3imi83lDd1aXbez1+3sZ4osbhvPVrfjnCkyeabIYtl46+226batt9vW223r7bb1dtt6e6bIPJ6ZIotl4623V4rY8awUmVw33nS3FBlbiowtRcaWImNLkbGlyBjbKBtbO4+tncfWzitF7HjG1s4j2rk/SJH+IEX6gxTpD1KkP0iR/iBF+oMU6Y9H9G9/rBSZPGB5bCwcz0qRyXnjTVc2Xdl0SZH+IEX6gxTpj7Sdb9rONyWOJ+WNy8Z1Y9146nbjvvHUHRevFJksG6eNTbfa8cwUWVw31o3bxn3jAc9rnMWmW+2Y5zXO4kv3urvtjznFcdm6P2aaXLOk/TEnORYPeE5zLN66sW7dWLdurGXjurFu3DbeurFu3ahbN+rWjboNW92GrW7DR7fho9vwmfFTrR1m/CyWjWezWfvM+Kl2nDN+FteNdeO2cd94wDN+FsvGZd0CdltO6KhgAzs4AmfAVBtoM2AWp43tjK6J8/6YAaPWMjNgFuvGbeO+8QieCwudZeO0cd64bGyvlD0MFWygvVImhiPQsmWh3RkPwwRmsIAVVLCBHRyBligLUUuozdi45py7zHi45l27zHi4Jl67zHhYLBunjWedbjzrWP31Wq3xeq92smycNs4bW2s3a6t5S7NYN24b940HPHNg8dRtxmnjvHHZ2B7yWJNYDCxs4BS1BpwhMHm9MjRZNk4b543LxnVj3bhtvOnqpts23bbptk23bbpt022bbtt026Y7w2F29AyHyTMcFsvGU7cYVzp3XoMsbhvP87K2ndcgk2dELJ7nZQNvbINnbINnRcTkTXdsumPTHdugHQza9HhsLBunjcvGs62acd94wPP6otnfn9cXi9PGeWOrf62A7GleXyzWjdvGpntddvc0ryOuSc2e5nXE4rzxrJ+N68a6cdu4bzzgGRSLp24xThvnjcvGdWPduG3c4Rka18rUnmY4dGvbGQ6L28Z94wHPcFg8j9nafIbD4rxx2bhurBu3jU13WL/MfJg882GxbJw2zhsX+mvmw2LduG08x9vlwdS2tpreX1w2rhtbzWHjp21t1be2mh5fPI/ZdOf9x+KysdUfNjb61kd966O+9VHfdMemOzbd6f3FeeOy8TY2xqY70MrT19cy0p6nrxfnjcvG81yqsW7cNu4bj/Vso89liwsFTGAGC1hBBVvgvHW4Jux6npZfnDbOG8/TsdOfll+sG7eN7YFUNhyBtiJ5oYAJzGABKzibyc5hXitMntcKi2XjtHHeeB73MLbnc9dq2J7nThzXFHjPcyuOxWlje451rYjtee7GsdieZD3sOOd+HIvbxvYw62HDog5YHxvLxmnjvHHZeOra0JmPPhe3jfvGA56PPxfL2nug5+n02TzT6Yu3ZpsPOx82PObTzsUDns87F8vG87RsqMxHnovLxnXjeVqm29vGfWPTFesiSwBn2dh0xc7REsC5bDx1bZhYAsgcevbrL2JNbmlgDyX7XBU5eS6LdJ711bhsXDfWjWf963zngsc5JOeKR+e0cd64btzXfh+9zE0+DOcmHxNl7QLS535sCzNYwAoq2MAOjsA827kb543LxnXj2Q7DuG3cNx6w7cxmFyy2jNExgRksYAUVbGAPtA087JrdFjc6zufz1tDT+4vrxrrxXBEwK/aNBzy9v1g2ThvntTtPL7F9Ty+xfU8vsX1Pn1u/LezgCJzb90wUMIHzbJKxbtw27hvPs7lsUtYSh8mycdo4r62Pui1sdKyggg3s4Ai0DXsWzt4pxmXjurFu3DbuG9sP8JOq77DVq++w1avvsNXnIsZJJcimNIw0qAX1oOFkv/GT5vFX43mcatw27htfrWDTHbYo0VHABGawgBVUsIEdRC2jllHLqGXUMmoZtYzaNHay1iuPjWXjtPFsJWuxUjauG+vGbeO+8YDn7/7iqWvHNn/3F+eNy8amey3S6HV6f3HbuG886MHl/cmycdo4b1w2rhtvo0W30TJ/368lKL3O9U2L08ZW/3qA2etc4nQtEO91psBi3bhtPM+rGA94psBi2Xjq2rHNH/5sbT5/+BfXjXXjtnHfeMDzh3+xbJw23nRt2ZOdia16mqRB9iaWUQ8ai2zpo9082crHRSkoB5WgGqRBLagHDScJDQkNmW01jK1Nroe9XWcylPl3BmzX+s6ysdUpdi5p1qnGfeMB58fGsnHa2NrW5rt1/tgvrhvrxm3jvvGAZybY44m5wZ5z2jhvPHW7cd14Li97GM/1ZdYOMxMWD3hmwmLZOG2cNy4b1411403Xlj/a0djqRyNb/DjJ3j8ySkE56BpTNgLshcRJGtSCetBwsncRJ0lQCspBodFCY/rdHrWsFYz2LGEtYbRnCWsN4+Kycd141rF+mT613wKdPl2cNy4b1411Y2tbtfaZv+aLR3CbF+iLZeO0cd546jbjurFu3Daeusl4wPOC3q4h27ygX5w2zhuXjevGunHbeOp24wFP7y+WjdPGeeOycd3Y3mgyakE9aDjNt5mMJGjWHMZ2zNdWt33u2Ods1xbWhHZtv1DABGawgBVUsAVOO9u0fpt2bnZ4086L88Zl47qxbtw2nqeTjQc8f+IXy8ZTtxjnjcvGdWPduG3cN566NiTmT7/Nerf50784bZw3LhvXjZVualv3ta375k//5PnTv1g2ThvnjcvGLWKhbRHR5k/85PkTv3jWt/7dIqJtEdG2iJirIKXNf9s3HsFzFaTYTPpcBTn/7VwF6Zw3LhvXjXXjtnHfeMAzIhZvurJpTfvbrH2f9l/cN7aadqkwVz46y8ZpY6tvFzxz5aNz3Vg3nrrXeJsrHMWmFeYKR+e08ayvxmXjurFu3DbuGw94XhLYbOxc7eicNs4bl43rxrpxg9cuvNbmMwfsR3muYXTWjdvGfeMBzxywSFy7Ai5OG+eNy8Z1Y9146lq/zBxYPOCZA4tl47Rxpr9mDiyuG+vGs1+uLJ3rE1dbTY8vzhuXjee52PjpW1v1ra2mxxfPYzbdeXmwOG8828rGxtj6aGx9NLY+GpvuQHeuQ3SWjdPGeeOycd0YrbnGcF5mzzWGzmnjvPGs2Yy5LB/SN+ayfK4lFJtAmGsJndPG85iHcdn+bd1YN950t9uBsd0OjO12YGy3A2O7HRjrdmDypps3LfN1srnLuVbQWTZOxsk4b1w2rhvb+nybcp8LCZ37xgOuU9fav876dmy1bFw3nvXVuG3cNx6wPjaWjdPGU9f6XcvGdWPduG3cNx5we2w8a9oYmC8tiLXtfGth8YDtd9xZNk4b2zHbvPlcPehcN9aN28Z94wHPjQxszn2uHnROG+eNy8Z1Y6W/5n4Gi/vGw3nMFYPpesQz5spAa6sxVwY668Zt43ku5WKJthpzBaBz3nges+nOXQoW68azrdS4b/92wOmx8aabNt206aaycd1YN24bb7p508qzZjOeNbtx3Vg3bvD0+OJZx9pwenmx1UmmNT2brF+mN69J5zGX3znXjU33mmgec/mdc994UH96c/736c3FaeO88XXPUUzK5t8XKtgC23auTTi/ljbe2sC2xc/W5dOiyYbUtGiyYTEtOnladLFsnDbOG5eNZ5OZ1rTo4rbx1LVunhZNdirToskOeVo0W1PaLvnZ/rp9mWVhAa+meUy02tm6ddrwmoEcc42ds2ycNs4bl43rxnZO1yzlmKvsnPvGU/dq47nQLl0vx4650i5ZP8yldskOX+ZnWrphASvY16fWxvxO5kT7UObCWXkYp43tjK55vCHTpIvrxnZGNrBkmnRx39jOqNgZTcMulo3TxnnjqWtnOo28WDduG/eNBzwNvlg2nvWtoew7msP+8/ztLdYMVTZOG9thXlN3Yy63c7bDrNY80/eL28Z2mNWaZ/p+8vT9Ytk4bZw3LhtPXRtE8zd5cdu4bzzgmQmLJZph/jxX64n5puFi3bhtPMvbeJ2ZMHlmwmLZOK3PHY75cc6FBayggg3s4AicP8vVRvf8WV5cNq4bz/Oxc54/y4v7xiN4fpTzutMY86OcCxOYwQJWUMEWOP1+TSOMuajOOW08z2cYl43rxnY+1zrjMRfVOdv56NQa8PzJXmy61wzhmIvtnPPGZeO6sW7cNp662XjAMw0Wy8Zp47xxWR/QHfOTneu/9vVF2jE/2TnRPtm5UMAEZrCAdX29dqT5id2JDeygqV0jP81P7E4UMIEZLGAFFWyB9jlP8+VcYZfWf04b543LxnVj3bhtPDumGg945sFi2fg6IfP6/MTnwgJWUMEGdnAE2oflF87TUeOycd14no55cV4bLO4bz9OxwTKvDRbP07HOnjmxOG9sus08M3NisW7cNu4bj+A8rxsWm+411TvmAj3nvHHZuG6sG1tbXqdiC/Hm4MjC4MiSNs4bl43rxrpx25jBkYXBkdNjY9k4Boct03MsYAUVbGAHY3Dk+ZX58t///U9/+tu//euf/+Ov//b3f/mPf/zlL3/65/+K//Dvf/rn//Fff/p/f/7HX/7+H3/657//59/+9k9/+v/9+W//aX/p3//fn/9uf/7Hn//x/F+f3fGXv//v55/Pgv/nr3/7y0X//U/868frf/r8sa7rXz9/b3sUeM7N/lJCXpewvUutwnP2gQJ9/FIgHY7hca0bm8fwvMR/WeJwGraJ2KrwKC/PoryuUKJC2Q6h5V/+fX397/M1xOzf55E4gJbu98R1d7J6Qvee+PUY2qEVohGkxr8vt/95tpuieQ7PhxAcQdJfSoxDiVyjFerWkeluARUfzM+n2VHg6ZhfR+NhOEpRL/Fs0v66Rjp1ZoqWeD6rfVnj1Ji2/9xqil5eNqYcxmSyC2Gr8bxq4DCeV/O/1qjv9sjxRIafSHk88usTOdSomr3GE+kTlV9L9FO3jrBHrellicPYas07te9B1R63K9i3VGaFp+6rCukwOtMj0vJ5cUzQlF/7Ix0Gp339YR7EaK8PIh+6VEoM72djMrx7+15/tNf9cRoV9hHzOSqez/Fflbis+LI5y/W4bDZnLfKyRHu7T/v7fTre7dN8+gW0ibP5M/y8naFPa75/InLNwKwTqfLqRPJhcKbuXfq8PnxV4BwVQ2NQSH7Vo7m8n96nGiWL1yi5vv4tzHr8JUphka01nnd9v9Y4NUf3HtFH3Srk+wOj1BgYdXPZx4GRx+nCoo2oMXQLjF/PpByO43mLFy7RsgXGF/okXFL2n4CPfVJO15otAuM5LbP9IOZfx1c5xKdcXxaOS7Wm25F86JdS3h8dpb47Os7nMuKKS65vZr0+l3YKjkYC9rEdyYee6W+Pj/F+BB7b49ot3dvj2v36ZXtUOf3Atrj4e84b0h7l1wSqpyTNqnHx17Yf6fFrmNbTD33PcVfSi76ucboIbcNrPGc1+usah3H6nCONi4We5XWNU5raBPqskXbP9fsD5GYU1v5+FNbx7lA/d2xPcVm/3fB+bFA9DdLEz+Rl1Jc10vsdq/ntjj01R6lxEVdqez1Gtf5Ac+gPNEd7vzlO0VHC9s8538NhHMZo0ZZjQmSL9N8sezqOWiWuzsfr42iHUaopjuN5E/k6Br8S6voy1Ft++zK/nX7zry2X40Ba6a8PpJ6aJEk0yS/XMB9qHEZqkfitLLLdOH2pRosGKb09Xtc4xOm1z5Hf+Tyf6dO9H34p2/m+3hv12qryZY1+uDrNMdOyD4/no49fK5zu7GXEYE/bj8tvNQ6Gqcnjo+bH9yqMuCLcWuJjhWOvjpiNLWMz/sde7fX9Xu36A73a3u7V/gO9Ot7u1fFH9mq115HmQUjJ3wvAe9MDI785PXDMPrpUS34d5ON016Qxsqr2b9ZoMSv6RPleDfsi+azR0+sax/tZ+8DY7JNHby/vZ8fpctQ+Gb6u8PX1PbG9+v56kMd893O8742avlCkq/8qPa8X2qFIev/G2jaLeO/O+vhb3x/bVMPul4/9aztDvHcg5+5t/gjg+ay4fG+I2CeVVo3jEDlNGQ97j2q2yLW25sWNz/lAYhI/Z+mvD0ROj9qYILzmb7YiHx8zyfFpWY6nZfuk7VeKlJZiSqs/5FAk/8CAPz1r+okBXyMC5HqR9fWAl9M91HPuJE5HmowXo0ROs8j37rDH8UkmUye5y7dck3NcIOdSHq8Ha3r8sa553iXE764eIkDS8W6u92jTX6bE+4cih7F6basUD+F6/V6RYcuV5hxM01OR+gOuOT1/uueaT8KIn4nRH68jIJ0nTyOf+77+4Lci4/iLFbHY0/6k98Njwfz4Q53Hw+Ln45vH95ynXGi2lF4P+JzfXsww7v1GjKSHwzgN1IT/8zap9OzLLxQZpXGd+DgUOa0v0e6ZOHS8vq2zbR9eH0mLyanH5rtc9f5PzbXeK0yTf7nu/WC98njbvSfPpMRUW9pX7Xz0zPEiXjkS0T2gP64VycfJtngUro90OJLTZP8jcYunr2+6pfzA3b+tQnj39l/K2/f/Un5gAsC27n1vBuBc4t4UwNE0I/FLM+rBNOfnUi0uA/ZcfP73D0Xyu78S5+Mo8eAy7RdXvx3H8ZpGY9ne9Zzr9ZXE8cnUiLmV9NjuWj8uhanHVVYxUh+vF4DI6clUslfy1kht++PPDxc0p0dTMj/Ps66+H1sUfXzAdfy5SYm58iKH3yyVH7hCOz2hupnxx2Tt8bg/y371/DFZ9eS+HL+dz9+kx9asX8j4bK9yrWdU+6zTb0dyWjPV6jbd018n6+kp1e2M1/4DGX96UHUz49vjBzL+9KDqZsYfS9zK+OONQOYH/Pm07HAjcPylqNsqmdq3QPq45PP0PPXBJfgvEfDbkZweRuhjxFPIsV22flwB29r7+Xx6TnUzn9v4gXw+Paf6qXwu0nkye7gdOD5rYtViHfXQOT2/3zm9vN05vf5E5+iPdM4x5XPapp4O9+HHB1c5nJP2+avfsvX03Ol2yo/HD6T8kLdTfqQfSPnTA6ybKX8scS/lj2tka6yRVX256vl44/p8eB/J2ve52g+DrB0nr+Odma57iQ8/E+MUrNIZ7I/H6yvwY5HMertf5mo+FEmnh0833zCwzSsOYz1mN1+/YnAscXM9+uP9lSq2FcvLw7j3lsHp0dXd1wzu98rhPYO7w6Ns7fHFMfZoXM+Uwxgbx1uaWy8npdOM8d317efTafHQ9/nzcDid03tSPcUv1fWRkpdXAJ8UifnN66sShyLlffOeXpW6ad5TibsvCLX3zXt6OeemeU+vOt027+1eaYdeOQ2PHAsAr08CvB4ex3mem+8JHR9d3evbVN7v29Nzq5t9e3pqdftdoWORm4upU/qB1dQpvb2c+pNB9oggy/m7QaaxPuraUPJ1kdMLVFILK0T31y0/PHY6hnuReDzy/Kl6fVGV8g9Ean4/UvP7kZp/IFLz+5GafyJS8/uR+snwiCXmz7up8Xp4HB9a3Rwepzvdm8OjvJ/Kp+dVd4fH6XHVzeFxfFh1d3jc7pVvD48tPZp873K5SCR72e+2fxtjp/eobr43nuoPjNP6/jit74/T+gPjtL4/TutPjNP6/jj9ZHTcmgY5TaQIb6A/n1e+nMFIp8dUqi0mdHo7/OyfHlMN1jM89nugfnv/kH2a7Tm3w+joH1+nL8epxx4TKVuDPO/zPxQ5zqUqc6nb1hcfNlNJx4dU9oHhNdZTe13j0Lsa41S39njOmn4ocUyxzCTZocTpKGJTlbZPb30scXo+lXu8E/+c6n797DCdHi4JP/oi22xdHh+LnC5xY9X7+OVdrI8lDkHIyqy2Tdb/VuI8wFjqkrau/Tg4To+n7j6P/SSBGgnUv5liN3fBOD2dSiVW7qV9buq3GuP938n+ePt38lTi7nYc6f3fydNjqZu/k8enUnd/J2/3yuF38jg68uiMDv1ejZp4lTPn16Ojnx581BrPC3V8s0astzvWOLvl3mTQeH+if7w/0T/efyMrjdOc1J1Xss5HcXf/m/evS8fph1ZicYzukx6/+e1+kfrNIiUeFTzno+RlkXx68HGzX47nEj9xT/zuuaS4ftG0/Sx8sUi8gqT7FP/XiuSYGXtOtOmhVU8/+w8eaV8sL+ctj2XuzqB+UiR21rj2o/xmkRwv3Yy87Vz4tSJ39wg6PZa6O5ebTy9E3dwF5ngcvFY5+nYP8/tx3C2yXy1/rUj80DxRv1fkeYsat7lPbocyxy6uEWxjv5D44mDrDLbdx18rooMirw34hd/wlzND+fRmVYvb1NYOsynH6/97m5WdHk2VEodRyng925ZPz6aed1zx/k8rhwN5f74/p7fn+48l7l0W5fT+fH9Ob8/35/QD8/33e6UdeuU4OmIh9dNU5Vs1MvO5z9+q9t0aj7drZK6L9gj6Wg1llqu/rnHa3O/mzcwnNW7dzJzPpTDIivb3a3xzjOU0WB7TX/dtOU1RKW+6tXRy3elAGu+6Nj1sIJnf79xzjR/o3Cacy8G4pydT8oj3dWTfF/qLjTrYSO4wysrbS6jz6SUoGTXOZbTDjVU5zumy03c+NMfpN7vG4qlSD69C5/MLTLcm7XLN7/9mnzb4u/mbfSpx8ze76vu/2acnUzd/s2v/gd/s271yyNPza3a3Ju3ONe5N2uXj+1M3Y6y+v/oq6/ujVN8fpcfHUjd3SD49ELo1sXM+ipte0fd3nG6PH5lLOZW5ez94LnL39rb9wB7anxS5OatzbpObszrtJ3Z+bu0HZnXa+3v7Ho/j7qzO7SKnWZ1zkZuzOsd30u7P6pzHyc0Jmfvx/Pri7vT+1K25lPM1FVtjlr3G7/Mgxwuz2Fyi1NNkymnXwLuL9HM/7kBycxP60+ns61PSYaObPH7ggyh5pD/6dFLf3p46nU75I0da1bh6r62Ow2GcN1D1gZb2Dc8/tunbm1SdjyIezuz3Mr8fxelFMIlXQcvz6ublUYzjLWbs/37dbo7vFWFxybUG6vG9IoMdmB9je4D3lUaNkynjddeW09tTP1Di2ZBx5f3k+upUPityq2c+KXKvZz4pcrNnjs5tvDuZyusAKccHKje3uSrvP6c6HweTTDJGORzHsUg8gUiPJN8s0jObiP7SrB+L1Pd/Zspp87+7PzPH07m7J1M5ft9IK3NNWrW/7OJzkVsbO5XTY6q7GzuV83en7m3sVI5fnrr5OnhJ57XUt14HL6enIvdeBy+n50x3Xwcvx/3/br0Ofi5x63Xw8wi5uUFNOe7+d3NB5PFI7m5QU/JprN7coKbknxir+SfGan5/rOafGKv5/bGa/9ixendzi3J6k+ru5hbltPvf7RFS5AdGyOmlnZsj5LhH1d0Rctr97+YIOZa4N0JOP993d6b4pIg0ihyuAUr/gUua8kdPBChTeaqHXTLORbih0NO2ueciGoNEe3r96KucH5DcbNha/uiG7bH9kHY9nc7pEetzGqHwwEdfXuZ9UuTWplvl9PhKR7zH3IqMw+kcP/1zb9Mt68TXNya39nUqxy9U3XpiXE6Pr+7u61SOX6i6va/TJ2Vqjlvg58PF/nrO9zRkm8Yqmqb7hggf+/i8CeCtBWPl+KWqew+fyydbAN54rHcsce+xXjluAHjvgVo5vV9174FaOb1ddffh8/1eaYdeOY6OWwvGjjVuLhj7rMbj7Rr3Fox9UuPWgrHSjhv43lpT9EmNWw/jz+dyb8HY/RrfHGM3F4yV0ytWdxeMnQ/k3oKx0t9fDfhJjR/o3HsLxko/z+bfWjD2yYHcWjBWxvs//+P4eaR7C8aOx3FvwdinF3d1u7jLry7uTt+Lun2FeCpy73HP+dKuFQnXldcDdfT3rx3GePva4VTi3rVDfcjb1w71kd69dqiP/APXDrd75ZTrxwv/+L19Ppx4Gaf18RNReNzafftczf4B09+u/E9FWgyQJ8r3isjjEdfa5XgPclzLl1mkod+/kenKjcz2q/vVG5k4o+um5vBBeD0vcaRdRL/ZLiV230hl/ybJb0XeT3g930I8iIH+LesksjnJ61/vKm+vsq7yA6usj8dxt0mPXcs+ImWf4PnakJfEvheSv33vngr37km/7ZwUF2hXSf3eFMAvLxjncpjmOU1dx0zRtllM/tLDzRhr18PNV8sCavqRJ6Ry03vyzYebbcSB9MeeRh+K1NOjK31ESutj790vPJfkEVpK28qCrz3cbBLLAtphLr+eHlz9SJFnp8ZUr24fr/takRZ7gD5nFdKhSDuN9xRTo/q9EqN4qI3av1dCHokFOfr6EUk9PboqnXTt+1cexhee90rLXAu0/Tu4j4+Hkt5KkXOTRpLtH0j7Wq/EZNVo9e2ObfWblsuP+LXK2/cuvlaEFZLPeoeBfnzB6d7oONYQYWm/lP69AxHhAz77BhRfK5Jjnkj2/X+/VqQmHjiV9t0iyt1RH989nXi4IjkdTue0E+DNKKv17Sir9QeirP7RgzWztVmu7ZsNci+IjiXuBdHNbjkF0ScrLTP9MsrLS6pPirAP8WP/5POHizs9DpB7az6PRX5kffK9FvmsyM0WGT/RIu+v2D6/fvIocUX1eOwvTH3tLZYH1xDPMofXco7fALr/MsypjLbG+oZt8Zl+oUSPT5poL+17JeKTgtrbyxLnLV9u984nZe72zvGD3Pd751TmZu8cS9zrnXOJO73zyT5UD7+W0P0tli/uiBVLNp9FXm9m9clXDW69QV6P36y6NxFfTy9M3ZuIP5a4ORF/em51dyL+9K2qmxPxx6dWNyfi7/fKYdvH9P4b5Oca994gr6cnTjefjX5S4962j+n9TbyTnhP13hvP509n3N0B61jk5hvPn3wJ5N7Lyp+czr2Xlc9fArn5fu/9Iof3ez8pcu/93k/a5N6LuV/4as3LZwr24uzLUX9rk7PjZ01KTFn3kl9/gEfl/WfGKvL2T5WeTuZeCOi5Pe78VKm8/x0glbe/A6THt61u/lTd75V26JX3nxmrvL826pPjuLVoVdPbq1Y0/cAD4+Nx3HsAd2yOm880zzXuPdPUU5jebdL2/jPN43Hca9JPvhEVzdF122Lk96+Z9Z+4P/yszM37w0/K3L0/1Jz/8DL3bjPPJW7dZn5S4s5t5vkbr/c+LaBv3x5qfv+rAFre/irAscTN39zy/lcBtLz9VQAtP/BVgPu90r43OG7eHerbN4da3v8mwCc1bn4T4N0hmn9mM6yf2DzqJ/aOGu/fjd2ucdpsabx/L3Y0yxc20H7/dvt8JLfHyHh/9uBY4wfO5vZYHe+P1foDMwf1ByYO6g/MG9QfuZY6t+rNyQd9f+6hvbvB+mndT2EVwvPae98T7MO12PGtqhSX3DnlV8/+PikRyzKuz4C/LFHefmh3qvCIofHhs4wfD+M4sXzvzVs9Pfa7/eatvtuk+fxlEr/E/mUHrny/QlxV6r6M4mOF43sdD97ISNt6nVzu1yiJi7mUX9bQ4yPUIbwKNaS93K4mvztETxWex8BiW637ZOGHRtWubzu2vz28tPe3m+M0zaexdCntb+p+fKH73TF+rHBrjJ/O4u4YP9a4O8ZPO//dHuOnPfdS7DL5nHrf1rTmL9SovBRS66HGySlte8uuyf6B3I9OOb2wc9Mp5xJ3nNJOn6r6geD4tTm2qdePzVHPj1555bjSGunjEu7bNfr7NfZ9GT/WOK2damzH1Lbd4Z5zofdr9NhY5on1mzV61BjbdeBvNc6fmItVrT2V79Yo1Kjv18iPlzXa+aPDPebltjXPH2ucXo6927fHGjf79lzjXt+eluflFFufPHG8X2Pzy9dqxF1xTq1+r0bO7E1VHt+rUSLI8i+bbn/pODSur/N+d/7tGvrNGjFlmvel119rj8Rr/vmbfcs2t09s36wRGZRL/W7farxdX7R903PK7qOnvj3WYD/WsX1D4Ive54HYI71fQ759HI0a+r0ag9X9o7T3j+OUhekHcj39QK6nH8h1+YFclx/IdfmBXJcfyHX5gVw/bqwVr7EV7eVb1x9lxLY6ZfTDddDx+nTbVqe/vj5tpxvLm8/TWjnuq/Ngb579rYvfDuT07Ka2+KJ83fdR7h9q9OOvA8m+75vWPtQ4bfT3iPvk/Ngf7X+oUU9PkeRReGVqf6nmt7M5NmvdfvvboVmPRca2b9JpkJwCscZbNU/e9hn7eFvXTtftDPnnnPjWOR8emZ7mPcu2U/5+CfHbcZx2pWCH3Jq3T6F8rHFcyNpig74n1u/VGHEZUse2POi3czm/UcvL263vW0p+qUrnnZjW6+s2kcfbs1znEremueT4noM0JqmukftqKuT0janxiP3Yh7yeTTmWkHitbuyvXur9buktbnSf3PV7ndtHTOs8+TCZ2/TtKapPStyaompvT1F9oTlK/3ajNqrU8t0qdVClvZ49bKcyN7vmXOJe1+gf3DV7c/Tx7a7h1myM15Eop6VKN8PsWOJWmB3PZfAhJBlaDvHe07sPMI4lnkFKq7aaxveKKN9CafvpfK0Io6SpfmukjcYKjnFKVqnHbelGjJIn1/a9Mimx6fduvpTbN4tI+maRGu8tp7qt0PtSkecpxHTTY78tyR8/Y3A4EJF4NpPyfn3167qFNn5ge+o2fmB76vOaRSasf/kwy29no2+uwpDT8527p3IsUkmkD1e+XziSyn5stW3f3/xYpB9P59bP3icl7vzs9dOef/d+9j5pjViBVXseh9Yopx+beKChZf8gw29Fjrc18aO37QP14Z71fBg1mkP3rw987VxqTDg9H9PUbxfZ9tof3y4S+8rrL48zP4720+eueli3jmOR/P7NVX775up0KncXEZyL3FxF0I/fqbq5ikBOLz2VElMBZf/Cm3xIxH5a4n8zh84lbuWQvL2bxLk1aozTUlt/3RrH96butca5xK3WSPmPbQ0tfJRxf1vht9ao77dGfb812rutcdo1JY/4iSr7hxM+XsGca8RyirLvzPexRj+uz795TddP2/vdvhA6vhskbB9RD8eRf+Jkyk+czClNJfpX9t0KJY0PR3KaamaH/m2iufUvHIbGVrKyr9/+eBhy3Jrv7i/DcSc5svD6dDatWh5fKKKPmALcrx6+WiTW+GuW7xaJK6qxb9/4sUg/ru7aX1fU/Y2Fjw17+ob4Iy5knvdC+VDkdDote6CNfYb3a23S6Z1+2Cm0lz+6yC8v1+7bMH9ok3ORfcPRvU0+Fjk/uGIpgIz0zSI8cnrOj5VvFinxkt4zG+uhyOky4N6udOd2zRqTZ/tHQ34bsPr+2/VyWg5w8w5A09t3AMczuXsHcG6Om3cA5x3qb+b8ccH9vQ0t+nGdxr2Xa7u+vavNscS9l2u7vr8YoJ9W4Nx7ubafvn109+Xa+71ysNz5dYxbG1r00yOrm6+1Sj/1y82PIJyL3PwIwrHI3T0tzkdy8yMIctxb6/ZHED4pc/drbp+VufkthXPL3PyWwrnIzW8pSD++6HZnk4yje27uO3KucW/fkX6qcW/fkd7PD+Ju7TtyPI67TXrs2nvfUvhkrN79lsInZe5+S+GzMje/pXC+tNlme/N3r47ik6hbKH0s8cmlbxyG/LLk+2uXvvFy0/NCSX7gIjzJd++zGvsY99dfZOjj7dcAPylxaw7s/fejjiVuTiqeGzTWfD3btrxs0PGQt6fzHsereJY46+P1OD0XUZYEaB7fLNLjs32y36J9rchoPGB9yPeK3J2ZOB8Jj2mfdySn0+nv34Wfi9y8Cz8XuXkXPo4z6ffuwj9p18GqLZHvNsm9dP6kSe6l8/3OOaVzerw7Az2kvT8DPY7fqro7A33c1nXE9FUb+yD58C2kY5HOrmF97OsKvlLkea4s3ByvvyU+0tu7VXxyHJVPGdTxzZNJEfQjjXE4mfrHnkzmSmLfy+T342h/7HGUzgczHqfjGO8exycl7lyOjPz2ZYCk45cutsuR/S2F34aYvj0veSxxb14y1R+YlzwWuTkvOX7k+dPxS7P35iXHD2z6N97f9G+8v+nf+IFN/8b7m/6Nn9j0b/zApn/n0XFvXnKcnmvcnZc87XN1e17yWOTuvOR5x62b85LHI7k7L1nHj8xLnsvcnpf8pMzdecljy9ydlzwWuTsvWdvbk2gn99ydlzzWuDcvOU4PsO7NS47jg7Sb85LH47jbpP0H5iXPY/X2vOS5zO15yU/K3J2XPF7a3JuXPF8d3ZmXlNP95s1bxfYDK69G+4mVV3IsEi/X5r1R5StFnoM+VrRlqd8sUuJVlPLrNmkfi5weC7QU1/H9IYci5e2L8GOJm+9e5h+4CD8WuXsR3n9iccD5q8ad13v643XPpPNnuDmQ/b321L5SJN5HfU5TyjeL9Hjp6dfXUD4UGccHwHdj4Lit390YON0UPDuYHz+t+rqLT8umW7zHWfru4N/aZPxAm4yfeDvnNGITNwb5sb0FJl8q0uMOJT/S62E/fuLlq/ETL1/J8WW/2iLqn6wv542OeXL7cvy492uNT4uWup3Px71fxzjeL+XK/dLrm7/x/tTA867q7bmBc417kwPPGu/PDsjj8fb0wPXJjh+YHxjvzw98MkRinKV2uDs5PjCVxu6Ho323xuPtGtuy8n3m+Gs1onfzvobzt+F+uti7+Y2Dz4rcmnU5n01hmBXt79f45ijLabAnXG+HBjlNZSnXaS0dboOPR9LiIXJumg9H0n+if/sf3L+NXYwO7pXH6SUq2XZilf3+5mvtGq+F5P56pMkjvb386lnjB9ZfnY/k5kTHJxcT8QDpOSPyyK8uJh7Hz1g9q+StSvtWlZsPgI5ffr73mEEe53eybl5MnJ5m3b2YONW4ezGR8w9cTJyu8+5eTJzehbp7MfGFvjk8bTgOkntPG54H8n4w2kXH248bjkXuPm5o4wceNxyP5PYy6MePPG745P7m7nOC4yndfU5wLHL3OUHr72d9e/85Qbv7atfpt7w+3v8FrfITv6D1/UcF5969u4T58SOPCs5l7i9hfvzIo4JPJrTYzE/3HTg+XhUcn4RqZQvcZ5WX0x2l3Bz68nrhr5y2Fm0jDqQ/Du9GXi+THqalH5GS+tib9sOBnG6H91cjt7ebU5UvFGmx2vU5A/N4XeRx2hXwZ6o8+zUm1/bXeb9YpTXWqo50qnLatzUexrT9scGXaozCoqz+zRrPa+Uwz77j6u9VjhsM3lurKsd2lcYHWeWX3cUevx3L6SPXnnDb++clf6VZHywg/HbXxEzSaPX97j3VOLovx5Olp5nlm0VYdPesdxrwxyuLm0PkWET4JJrsu4N+7VBElG2Ge/1ulRzzOLJ/H+CLVSq7t9dt9/avVlHuV7ZL/K+e0SOq5HQ6o9OjrrvJdqpxN9nO71zeTbb+hw/bXOKyK9f23Ua5mUvHGjdz6WbnnGocH5rfW95xfu5+b3lHfvsozpuD3TqK8+6R3J7/4t0vbUGp7GOpI3+zSCfox7ZJ4Rf3seSTJ4/0+nRsB+7XRe5thnkscu9j6OcStz6G/kmJWx9DP/ZLi0mgaxrmm537S5Hy3SKJIvkwzI7Lqm6+kPBJjTtvAohtiPpH1rg5m3xuVLZKafttydd6JmYbUxvfTZH9SL5dpMcDoSd+u0hcRZyLHHeSvpfv582o7+T7Jzvax8KDIeWbm+LHg7onjtcTHO//1tV32+L8/YfYgKq2XzYH/EINPrpQe318r8aIhZ1P/OZ3KHrjOL77PYweT3Gf5b77PYztCUH5dnt0arzul+NG9rwbXepIP1Dje98pKSx+Kvvipy/VaLF5XGn1tH38cRovnmY9HodpvOPWfkXjrcqio76cIf3kSO5NKB7fwb83odjl/fnEY427E4HHVP+ZKrenE89V7k4nyuk1rZs33ccaN2+65bzZ4c2bbjl9fenuTfe5YQezGSMdhlv9CROX8b6J+088FZD69lOB/gMPBfpPPBOQWv7oKvdNXH/imcDxJa27Jq7vPxM41rhvYv2BZwLnhr1p4uOXyx7xpkj99TsSv30f65BsNfW4Zkz79V7/WOQ0adWiZbXtH1HqXzibWElV5ZFOZ6M/cTbtjz0blro+8XtXjTVHqNVc9Hs1EseR2g/U6I9vnkusJ6lZxjePgw9j5Me323TQpvWbNQo1NB9Gan3/ady5xr1Z77vBeqjRf+BhXP+JZ3HS5Qei+VTk9rO4T6rcfBZ3rnL3Wdy5yt1ncZ9Uufks7pMzuvksTk7D5e4VxanG3SuK3n/iimL84cP27rO4c6PcTKVjjZupdLNzzs/i8vvncqxx81xu3n+eElZ+IGHlBxI2PX5gqB6L3E7YT6rcTNhzlbsJe65yN2E/qXIzYT85o5sJmx7vJ+yxxs2EPda4nbBJ/vBhezdhz41yL5XONe6l0t3OOdQ4LcXMWbcPkm/7J374aP39GvrNGrFONu8W/lKNwtP9sj0A/lqNzEt02yPTr9WQeHRb9s92fKmG8tl7PRzHafFxV76ae+rbY43BV1X3bVi/VIO9T8cjvV9Dvn0cjRr6vRqDH4lR2vvHUV6P9Vrf79tzjXt9e65xr29v15BvH8etvj3WuNm3t4/j0Lfnz/7ER5lSqvsD8d92xXx/IcsnNW4tQknl8cfWuLeQ5fzJHz6DnNvj0Kanu4BbH1M9HkZhJUzZr1R/P4z6/gRpOj3HujlBejybyvbaNdWXZ3OuEctH0r7hy8ca9r3z10V4AbDWx/eK3FuSdy5xa0neJyXuLMkrb6+mKW8vpjk+kL91DMcKt47hk/0jt4/bPfYfyQ/PNj+pwpsfzyr5ZRXVYxnbe3CVkabfK3NzjB5L3Buj5xJ3xujpHeaRI8F+2Ts61/yFGnGn/awhr2uMnxgjn1S5O0bqz4yR+v4Yqe+Pkfq9MfI/n//Pn//1r//4l7/927/++T/++m9///fnv/vvq9Q//vrn//W3v6z/9//859//dftf/+P////8f/lf//jr3/721//7L//vH//2r3/53//5j79cla7/7U+P9X/+x3je3P/TeN6N/s9/+lO2/79d/39vz/9f5l94Pph7/p9+/Qex//C8Cr0G4//87+sQ/z8="},{"name":"__aztec_nr_internals__transfer","hash":"468050936489314843","is_unconstrained":true,"custom_attributes":["abi_public"],"abi":{"parameters":[{"name":"from","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"to","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"token_id","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"private"}],"return_type":null,"error_types":{"459713770342432051":{"error_kind":"string","string":"Not initialized"},"792767957093445390":{"error_kind":"string","string":"Only owner can transfer"},"3056898550702170717":{"error_kind":"string","string":"Cannot transfer to zero address"},"7721587900423544575":{"error_kind":"fmtstring","length":22,"item_types":[]},"10826617868182774729":{"error_kind":"string","string":"Token does not exist"},"13455385521185560676":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"13807813574466708314":{"error_kind":"string","string":"From address is not the owner"},"15764276373176857197":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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"},{"name":"process_message","hash":"4498794222434279541","is_unconstrained":true,"custom_attributes":["abi_utility"],"abi":{"parameters":[{"name":"message_ciphertext","type":{"kind":"struct","path":"std::collections::bounded_vec::BoundedVec","fields":[{"name":"storage","type":{"kind":"array","length":17,"type":{"kind":"field"}}},{"name":"len","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"private"},{"name":"message_context","type":{"kind":"struct","path":"aztec::messages::processing::message_context::MessageContext","fields":[{"name":"tx_hash","type":{"kind":"field"}},{"name":"unique_note_hashes_in_tx","type":{"kind":"struct","path":"std::collections::bounded_vec::BoundedVec","fields":[{"name":"storage","type":{"kind":"array","length":64,"type":{"kind":"field"}}},{"name":"len","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"first_nullifier_in_tx","type":{"kind":"field"}},{"name":"recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]},"visibility":"private"}],"return_type":null,"error_types":{"361444214588792908":{"error_kind":"string","string":"attempt to multiply with overflow"},"992401946138144806":{"error_kind":"string","string":"Attempted to read past end of BoundedVec"},"1998584279744703196":{"error_kind":"string","string":"attempt to subtract with overflow"},"2967937905572420042":{"error_kind":"fmtstring","length":61,"item_types":[{"kind":"field"},{"kind":"field"}]},"3330370348214585450":{"error_kind":"fmtstring","length":48,"item_types":[{"kind":"field"},{"kind":"field"}]},"3670003311596808700":{"error_kind":"fmtstring","length":77,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"4261968856572588300":{"error_kind":"string","string":"Value does not fit in field"},"4440399188109668273":{"error_kind":"string","string":"Input length must be a multiple of 32"},"8494938221169433674":{"error_kind":"fmtstring","length":132,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"9791669845391776238":{"error_kind":"string","string":"0 has a square root; you cannot claim it is not square"},"9885968605480832328":{"error_kind":"string","string":"Attempted to read past the length of a CapsuleArray"},"10135509984888824963":{"error_kind":"fmtstring","length":58,"item_types":[{"kind":"field"}]},"10791800398362570014":{"error_kind":"string","string":"extend_from_bounded_vec out of bounds"},"11021520179822076911":{"error_kind":"string","string":"Attempted to delete past the length of a CapsuleArray"},"11220776034976816114":{"error_kind":"fmtstring","length":128,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"11692359521570349358":{"error_kind":"fmtstring","length":40,"item_types":[]},"12327971061804302172":{"error_kind":"fmtstring","length":98,"item_types":[]},"12469291177396340830":{"error_kind":"string","string":"call to assert_max_bit_size"},"12913276134398371456":{"error_kind":"string","string":"push out of bounds"},"13782432182790537927":{"error_kind":"fmtstring","length":144,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"14990209321349310352":{"error_kind":"string","string":"attempt to add with overflow"},"15764276373176857197":{"error_kind":"string","string":"Stack too deep"},"16431471497789672479":{"error_kind":"string","string":"Index out of bounds"}}},"bytecode":"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","debug_symbols":"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vFWct4rzVnHeKs5bxXmrOG8V563ivFWct4rzVnHeKs5bxXmrOG8V563ivFWct4rzVnHeKs5bxXmrOG8V563ivFWct4rzVnHeKs5bxXmrOG8V563ivFWct4rzVnHeKs5bxXmrOG8V563ivFWct4rzVnEuFedScS4V51JxLhXnUnEuFedScS4V51JxLhXnUnEuFedScS4V51JxLhXnUnEuFedScS4V51JxLhXnUnEuFedScS4V51JxLhXnUnEuFedScS4V51JxLhXnUnEuFedScS4V51JxLhXnUnEuFedScS4V51JxLhXnUnEuFedScS4V51JxLhXnUnEuFedScS4V51JxLhXnUnEuFedScS4V51JxLhXnUnEuFedScS4V51JxLhXnUnEuFedScS4V51JxLhXnUnEuFedScS4V51JxLhXnUnEuFedScS4V51JxLhXnUnEuFedScS4V51JxLhXnUnEuFedScS4V51Jx3ivOe8V5rzjvFee94rxXnPeK815x3ivOe8V5rzjvFee94rxXnPeK815x3ivOe8V5rzjvFee94rxXnPeK815x3ivOe8V5rzjvFee94rxXnPeK815x3ivOe8V5rzjvFee94rxXnPeK815x3ivOe8V5rzjvFee94rxXnPeK815x3ivOe8V5rzjvFee94rxXnPeK815x3ivOe8V5rzjvFee94rxXnPeK815x3ivOe8V5rzjvFee94rxXnPeK815x3ivOe8V5rzjvFee94rxXnPeK815x3ivOe8V5rzjvFedeqKRRQz2LtOjSWE67yJI8zoNakRT1olE0i7SoNKw0LDW8cOmmViRFvWgUzSItWkW7qDRaabTSaKXRSqOVRiuNVhqtNFpptNKQ0pDSkNKQ0pDSkNKQ0pDSkNKQ0uil0Uujl0YvjV4avTR6afTS6KXRS2OUxiiNURqjNEZpjNIYpTFKY5TGKI1ZGrM0ZmnM0pilMUtjlsYsjVkaszS0NLQ0tDS0NLQ0tDS0NLQ0tDS0NFZprNJYpbFKY5XGKo1VGqs0Vmms0tilsUtjl8YujV0auzR2aVScj4rzUXE+Ks5HxbkXRak59aJRNIu0aBXtIrvJi6NuakVS1ItG0SzSolW0i0qjlUYrjVYarTRaabTSaKXRSqOVRisNKQ0pDSkNKQ0pDSkNKQ0pDSkNKY1eGr00emn00uil0Uujl0YvjV4avTRGaYzSGKUxSmOUxiiNURqjNEZpjNKYpTFLY5bGLI1ZGrM0ZmnM0pilMUtDS0NLQ0tDS0NLQ0tDS0NLQ0tDS2OVxiqNVRqrNFZprNJYpbFKY5XGKo1dGrs0dmns0tilsUtjl8YujV0auzSsNKw0Ks5nxfmsOJ8V57PifFacz4rzWXGuFedaca4V51pxrhXnWnGuFedaca4V51pxrhXnWnGuFedaca4V51pxrhXnWnGuFedace5FWWs4tSIp6kWjaBZp0SraRZbUS6OXRi+NXhq9NHpp9NLopdFLo5fGKI1RGqM0RmmM0rjifPura1ec37SKdpElXXF+UyuSol40ikrjivPdnFbRLrKkK85vakVS1ItG0SwqDS0NLQ0tjSvOd7x+14qk6NLYTqNoFl0aPnOuOL9pF701zDWuOL+pFUlRLxpFs0iLVtEuKg0rDSuNK87N30O84vymUTSLtGgV7SK7yYu8bmpFUtSLRtEs0qJVtItKo5VGK41WGq00Wmm00mil0UqjlUYrDSkNKQ0pDSkNKQ0pDSmNK85tOO0iS7ri3PydyyvOb5KiS8NfxLzi/KZZpEWraBdZ0hXnN7UiKSqNURqjNEZpjNIYpTFKY5bGLI1ZGrM0ZmnM0pilMUtjlsYsDS0NLQ0tDS0NLQ0tDS0NLQ0tDS2NVRqrNFZprNJYpbFKY5XGKo1VGqs0dmns0tilsUtjl8YujV0auzR2aezSsNKw0rDSsNKw0rDSsNKw0rDSsNTwQrKbWpEU9aJRNIu0aBXtotJopdFKo5VGK41WGq00Wmm00mil0UpDSkNKQ0pDSkNKQ0pDSkNKQ0pDSqOXRi+NXhoV57vifFec74rzXXG+K853xfmuON8V57vifFec74rzXXG+K853xfmuON8V57vifFec74rzXXG+K853xfmuON8V57vifFec74rzXXG+K853xfmuON8V57vifFec74rzXXG+K853xfmuON8V57vifFec74rzXXG+K853xfmuON8V57vifFec74rzXXG+K853xfmuON8V57vifFec74rzXXG+K853xfmuON8V57vifFecW8W5VZxbxbnXq7031h0HcAIVuIAbaIVXuCc2oACh1qDWoOZBr06raBdZkgd9UCuSol40imZRaUhpSGlIafTS6KXRS6OXRi+NXhq9NHpp9NLopTFKY5TGKI1R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"},{"name":"public_dispatch","hash":"13997611858239045792","is_unconstrained":true,"custom_attributes":["abi_public"],"abi":{"parameters":[{"name":"selector","type":{"kind":"field"},"visibility":"private"}],"return_type":null,"error_types":{"459713770342432051":{"error_kind":"string","string":"Not initialized"},"772947778646992575":{"error_kind":"string","string":"Minter cannot be zero address"},"792767957093445390":{"error_kind":"string","string":"Only owner can transfer"},"1998584279744703196":{"error_kind":"string","string":"attempt to subtract with overflow"},"3056898550702170717":{"error_kind":"string","string":"Cannot transfer to zero address"},"5197614757850103533":{"error_kind":"string","string":"Only minter can mint"},"7721587900423544575":{"error_kind":"fmtstring","length":22,"item_types":[]},"9967937311635654895":{"error_kind":"string","string":"Initialization hash does not match"},"10826617868182774729":{"error_kind":"string","string":"Token does not exist"},"12511970388699677811":{"error_kind":"fmtstring","length":27,"item_types":[{"kind":"field"}]},"13455385521185560676":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"13807813574466708314":{"error_kind":"string","string":"From address is not the owner"},"14415304921900233953":{"error_kind":"string","string":"Initializer address is not the contract deployer"},"14990209321349310352":{"error_kind":"string","string":"attempt to add with overflow"},"15764276373176857197":{"error_kind":"string","string":"Stack too deep"},"15978124792480278163":{"error_kind":"string","string":"Cannot mint to zero address"},"16431471497789672479":{"error_kind":"string","string":"Index out of bounds"}}},"bytecode":"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","debug_symbols":"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"},{"name":"sync_private_state","hash":"11585261036542103853","is_unconstrained":true,"custom_attributes":["abi_utility"],"abi":{"parameters":[],"return_type":null,"error_types":{"361444214588792908":{"error_kind":"string","string":"attempt to multiply with overflow"},"992401946138144806":{"error_kind":"string","string":"Attempted to read past end of BoundedVec"},"1998584279744703196":{"error_kind":"string","string":"attempt to subtract with overflow"},"2967937905572420042":{"error_kind":"fmtstring","length":61,"item_types":[{"kind":"field"},{"kind":"field"}]},"3330370348214585450":{"error_kind":"fmtstring","length":48,"item_types":[{"kind":"field"},{"kind":"field"}]},"3670003311596808700":{"error_kind":"fmtstring","length":77,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"4261968856572588300":{"error_kind":"string","string":"Value does not fit in field"},"4440399188109668273":{"error_kind":"string","string":"Input length must be a multiple of 32"},"8494938221169433674":{"error_kind":"fmtstring","length":132,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"9791669845391776238":{"error_kind":"string","string":"0 has a square root; you cannot claim it is not square"},"9885968605480832328":{"error_kind":"string","string":"Attempted to read past the length of a CapsuleArray"},"10135509984888824963":{"error_kind":"fmtstring","length":58,"item_types":[{"kind":"field"}]},"10791800398362570014":{"error_kind":"string","string":"extend_from_bounded_vec out of bounds"},"11021520179822076911":{"error_kind":"string","string":"Attempted to delete past the length of a CapsuleArray"},"11220776034976816114":{"error_kind":"fmtstring","length":128,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"11692359521570349358":{"error_kind":"fmtstring","length":40,"item_types":[]},"12327971061804302172":{"error_kind":"fmtstring","length":98,"item_types":[]},"12469291177396340830":{"error_kind":"string","string":"call to assert_max_bit_size"},"12913276134398371456":{"error_kind":"string","string":"push out of bounds"},"13782432182790537927":{"error_kind":"fmtstring","length":144,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"14990209321349310352":{"error_kind":"string","string":"attempt to add with overflow"},"15764276373176857197":{"error_kind":"string","string":"Stack too deep"},"16431471497789672479":{"error_kind":"string","string":"Index out of bounds"}}},"bytecode":"H4sIAAAAAAAA/+19eXwdR52n39N7umVJPvQkS5Zky7LlU4dt2YosO7JsHT5i+YjtJJCg2IpjkI/YUmRJJLovO058wQ7D7nDknIWQIQQGmJtjmBncAwM7MByzXDvLFSAsgeXDwmSfEqlfdVf9flXVXW2pos4f+Tyru79V9bvrV7+qirt29b+8eL7r9LH7zp47+XBLe+t959uj/59ztf9D28+dbGs7eaKupa3txpwrV65fufK5wjn4f4Er0f+uXmMAfnvZS/1P1505fb79ev8zO06eaz3WHux/tul0e+uJ1nNP3rm+go9t/z4g9X3fUfv3c+TaP9r/1AQprqaYOM8daG1raT/5cKtcT+bMoRGCsggfnujL8Zb2lrozZ7vMIR0l+0SAv9HzJa57flRBz5862H7m7NVrQE9tPKp7uv5ka9vxKOyr57/+zBcvf+xzz7U/+/S7M7+Z9p6UNcm9w8O/yP153h+/Mvyk/cMdZrc+eOdmbq/i7Z/vNNvd+udxdz/40d+dSWkYfKHzm9+4oyMtr+UzBWNP3/35qwU/vm/E/mG9+eGPHntvb/oL195fuNr4dXzDEy/f96um8OZvGu/M+ezA73/8ynX7hw3mh1+5+/f//lL69e4Llz/Vs7lkfsuHr3/9lz/5whc/kv6r7z3/0Nc32j9sdKlGTXLfZ9i/30V8X7lBQvgnv98t9z3V/z1y31MittckfP9Tz/177WWj7Ae/T764t2XowvpLXz3ys+7sZ4v/4+3P53040/7hHeaH32+vu9oeOVX5s8QvXS7/QO7i77z67Es//E1X6+aXf/ijTyz5lf3DfVMfZlesqDr7R19e8O2Spd+6/W8/vO5GzqvLtnz7k40feOV3//hbBqma5VhFDXW/3Pch+/cH5L6Ps39/0KQY+7/A1A/7h4ecGtjJ7+/kNDz1X9j+4eGpD1dtSXrl6YuPDs/57rM/ffw3q/7y9rWZ+bWZ6/7He7+We/rcPTmv2D88ItfjvGcOtLZ3nDs9aamNZQ/2f6j+zLnWkydOT/zhXZ/saD/ZdrK9q6G1/c43fkWba2+90P6u/uf3tp46c66r9vjxc63nz5NmFXoSBJ/EgU9C4JPwu/qfOXjy1Nm2VsuQGX+s3DD1xzeoiv3ryhXa1cRL2fRmGiBBCqCVBkiUAjhHAyRJATxAAyRLAZyhAVKkAE7RAKlSACdpgDQpgNM0wFwpgBM0QLoUQCENkCEFcJ4GyJQCaKEB5kkBHKcB5ksBHKMBFkgBPEwDLJQC6Op/cu+Zh4mwMSs2D6CgI3LWd3F0snPydMu5ruhH+86+ywR+Mmrs3rBlUy0RLTzfdPr4GzGqrfEs2YDM2nisCbN5esxBOzWyya49HQ2xz7Wyn8ZDzWXTzWXHmsMgE9RDJqqHTFIPmazFwFPUQ6aqh0xTDzlXPWS6FuzxQCEztIDM1EKIErSQy3lamA0PhGi+Fo5iwWz14wvtoU8kFp6JhnFmQ2AQF1EUxDHGGYk1L/5RFvejHLwlMpvwwmQ2YUfr/R0n9pw5ceXKDfv03kyj/mlja8vZ2nPnWrpIduQB7x9iv58z5waVD4gG/f1Pv/HiVdbDPHZawf7JG+mCOdYBfmJygPWt7ccePNRy4kTr8egwz0fXJoB+19nw6PAanmzkyGblpCcbObCcZiuS0xxUHy3EfXGSuHvOtByvazl7vqMtqqlQdigLEIjANQbPywHuBq6LZ6ymGAr8vfG6SA7KKnIAyRYhJGvsf2qCPOSIiQ8nsnw2LsYINtmT599o9PV/7Dt7g3jhyb0dbcxPcyjcHJIRljEhPciZ7IH9lSxI6hBlkTbImOXPonUvSzCxO8fexxxEoRfJ6dQCeYVeBCt0jiKFZkhnDkFme7O5cs2CMVIu3WwuOW4bG/LIZwDk4o/siSrwoQdbTu98qKOl7TyIHvUYuzpOnW16gGhg8c130zKVR8oU0GoePZC8GP2emmjo6s2r9vEsQsTKJYkFxCoXFqtFisSKwd9FiFjlyTU7T4obxLhtbFhMPgMg81GxyiPBaLHKv/kkLVaLBcRqMT2QxZRY/Yl9PLmIWEmSuFZerPJgscpVJFZ5LLMBi9ViuWZvl+IGMW4bG/LJZwBkASpWi0kwWqwKbv4ZLVb5AmKVTw8knxKrD2HCI5KDb8M4IQLQSQPkSwG00wAFUgAP0gCFUgA9NMASKYAyGmCpFMAjdrEsQqzDMsl1aHnrsAy2DkWKrMMyWrqLwJWQYrJrlDIRT8GVkGK6uWIkQi0WSHc4h0xWDzlfPWSCesgMLSBT1UOmqYecqx4yXT1knhbaowctF2sh6vnqIQu0YI8HA8+craJeqB5yiXrIpfY4ZRkStRW7mzYLRG3FcNS2TFHUxqDVMmROt1yuWVDcl9PNLifHbWPDCvIZAFmCzumWk2D0nK7k5mu0YBCtgnO6FfRAVlBzut9RiWZC5hYpEuNFCP2KETF2yVIBMV4Oi3GxIjFejtPK3uwK2XJ6Ge4T47axoYR8BkCuRMV4BQlGi/FKI5BOS0aJgByX0CMpscuxEUi2j2g5IliSRN4pL1grYMFarkiwVrAMFSxYJXLN7pBiBzFuGxtWks8AyFWoYJWQYLRgrTICebRgrRQQrJX0SFbSghXBxEck3zKH1jVYMldKcSnwS3nJXAlLZokiyVyJaiw15lVyY34FFCO62VXkuG1sWE0+AyDXoJK5igSjJXONEVhFS+ZqAYVYTY9kNS2ZxbSuwYIlR+Q52+UFaxUsWCsVCdYqVGOpMa92t7SBs4MYt40Na8hnAORaVLBWk2C0YK01AptowVojYPLW0CNZQwtWBSY+H7yzXGKTHYMXIgBzaJrCor1Wjs2vyYv2Wli01ygS7bUoZ2zUWEd2jRKEdSTVgebW0c2tQyJ4H9KH9CF9SB/Sh/QhfchbBrnKh5xlkLNWLn2F9Dnumw1fLn1IX4h8Ufchfd/jc9wfuC9EvtP17aUvRL4Q+QP3aelz3JdLf+C+EPns8U2w7yh8IfItkW8vfbn02eMbN1/UfYX05dLvpQ/p67jPHh/SN8H+wP2B+wP3jZtPSx/S13Efcrb4Ht+P+3Lp99KH9CF97fEV0mePT0vfXvpRsC/qvhD57PHZ47PHd2c+LX2F9CFnlRDZT3lfG/sJ3nDHOJJyLdJeLvma7cBK8zvG8Z3rPD++cx18fOdaRcd3rkNpZaNGKdk1io6lAqJQSjdXirDGh/QEcrUWkP7AZxstZ20vfcjZpuO+JfIhfbn0fY8vRD4t/YH7kL4780XdFyKflr5c+pC+h/QdhT9wH9L3kD6kL+o+LX1I31767PEtkU9L3176cun30hd1H9LXcR/Sl0tfe/yB+wP3rbpPSx/S57gvl74Q+e7MH7hv3HxL5EP6cunbS1+IfPb4A/fZM5u1x9dxX4h89vjs8Qfu09LXcV8ufSHyhciH9CF9SB/Sh/QhfUgf0jNI+/GdxNmea6H2JI8LXUu+hhzS+cE7N3OPyTxEA5RKAdxHA5RJATxEA5RLAVywH9pJHCxKQa+XO0W03MayKWCTYWZLRAvgEaYVio4wXU/LS0VMXmzU2EB2jZKlDaTgAM1toJvbgIgnAVmgHjJBPWS6esj56iHz1ENmqodMVQ+ZooUQzVMPWaoeMkM9ZJl6yET1kPlamI1CLUywBzqepgXHl2ohRKlamI10LYQoebZaonwtLJEewaDvdGc0ezzQ8SQtBl4+W2Oici9CAyTVIJLF6KDn7XAWY6NcImGrfBZjI5zF2KAoi7ERJbaNGpVk1yhGEE/BLEYl3VwlwttKAcflHDJBPWS6FgNPVQ+Zph4yXwv2FPocn8kcX6qFEM1TD5mshb3M0II9aVqwRw97OU8LuUzRguNpWiikB3KZqB4yU4uB6xGy5msRE+nBcT1C1vLZGrml+jGRHxPNQEuUroVclqmHXK8FexK9CA1s2boydbnLJUpzl2Xe5S7LCFrZm62Ua1bOSxLjtrFhE/kMgNz8kT2t588ferDl9M6HOlrazoPom/qf2dVx6mzTA0QDm434TbRkEM2ugJrdRI9kU4yAT020dNWIr6DKKTcKaDCDORsRQS5DKLgREWRJpsbJC3IlLMgbFQlyJUorWJ4qUbaXOWM7DkmtCMCs2SRHnZA8azbBrKlUxJpNqD22UWMz2TWKjsTTLNAQ0M1tRljjNSTN06frT7a2HQfpGTf1gyYNLChVcrwKywtKFSwomxUJShVKZhs1biO7RrHgNgGu3kY3dxvCVe0gN1FOx2L31Fi2SsH2Nitqb7Nge6osdxn5GuVGlClkulKF3OSdQm5CosPb5JqdKyXyxLhtbKgmnwGQW9Do8DYSjI4Otxjx52jJqBZQ3mp6JNV0dHjKPqIqRLAkiZwpL1i3wYJVpUiwGByuQgSrWq7ZDCl2EOO2sWEL+QyArEEFq5oEowWrxojvpQVri8C0Yws9ki20YHVTFvI2AV2R9DhV5Gtv9vaoIARW1GrPQ7JqWFFvU6So1SitYH2pRsW6yplYvxkg7QIr4rxwL4IJbPUtbw9RA5HqwSYaYIsUwG00QI0UwF4aYKsUwE4aYJsUwEEa4HYpgFoaoFYKoIEG2C4FcJQGqJMCuIMG2CEFsIMG2CkFsMdu3eoRW98gZ27vkLf1DbCtr1dk6xtota8HbX0j2TXKJDSS+g8010g314hYGQIyTT3kAvWQmeoh89RDpqqHnKceMl09ZIp6yAT1kBlaQHog6nO1YM8WLUTdAx3Pn606vl4LhdSDPQVaWKIFWliidC1oqYdc5mnB8UzfEimDLFQPWaMecqt6yG1aQN6uHrJWC/aUatHL7eoh47UQojr1kDu04PgOLURdDxO8TgtR36FFL/WgpQeivlMLUffAXi7VIr5M0iKp48EkxYOplAfp5Qz76kYDstbT6K7KSWCtpxFe62lQtNbDoFUDUoDTJNcsuEDTRDfbRI7bxoZd5DMAcjdagNNEgtEFOLuNhAO0ZBDNgpVdu+iR7KIKcBL2YuIjsgpZj/FCBGANTVNYtHfLsXmNvGjvhkV7lyLR3o1yxkaNPWTXKEHYIyB/e+jm9iBWh4BMVg+5Xj1kmnrIeeoh09VDpmpBywXqITPVQ+ZpwR495DJFPWSCesgMLSA9EPW5WrDHA7lMUg+ZqIXTTdGCPfnqIcu1GHihesgl6iGXqodsmq1h1lwtIrdkLeylHlHwXKrOvTz2E6xzL6fbK0faqyJfc3nXz1n7RLRJ3bQ8T+m0vMm7aXmT+2l5/GwNOub7s4BZZ+N0cOfls9Wr6ZGIydfCbKTP1gBu1rInRQtHQYeZu2M/IxKRz26kvYgl9oFjQZEw8wANsEcK4DANsFcKYB8NcIcUQJ09NtyHRMrNcsFqv3yk3AxHyvsURcrNtLzsAyPl/WTXKFkinoL78PbTze1HxHO/gE11DrlAPWSmesg89ZCp6iHnqYdMVw9Zrh4yUQv26CHq+eohE7SQSw+MW7LPHmWQKVoMPEMLSA/Mxlwt2LNFC1HXI4DJ86MNP9rw3ZkfbfjRhh9t+NHGraGlHqK+Xgta5mvBngItFHLBbHUUesREHgw8TwuOZ/qWSBlkoXrIePWQu9VDerCSskc95O3qIdeph9yqHrJUPWSdesi9PnuUQdaoh9ymHrJWC1reoYWo181W7dFj4LPWBNf5tPTdmVvIRi1CVg9ouVM95A4tQoNSLWiphztbqsXkOUmLRUMPMjAe5Ik8qHOjDgRq7jdLQami0/1ydZ8p8kWn++Gi02ZFRacMWjXHaGWjxgGyaxQdiafg8TkH6OYOIKzxIX3IGQ9p3xtA2JMqRSaqinyNqgSHTdQBOSuxTN5EHYBN1H5FJuoASisbNQ6SXaPoSDwFc84H6eYOIqwhIBPVQyarh5yvHjJBPWSGFpCp6iHT1EPOVQ+Zrh6yXD1kphY6nq+FXHpAyzwt5DJNC6uer4VV18NsJGqhkAu00PFZK5cpWgQw9M7mA7GfEUWzpQj5GpVSgGcvB+UmEFflZy8H4dnLAUWzl4MorWzUOER2jaIj8RRM7B+imzuEsOaQgJ9zDrlAPWSmesg89ZCp6iHnqYdMVw9Zrh4yUQv26CHq+eohE7SQSw+MW7LPHmWQKVoMPEMLSA/Mxlwt2LNFC1HXI4DJm63RRqYWAUy+FjGRHqLuRxuzLdrwJyn+JGUmyqUfBftR8EykpR6ivl4LWuZrwZ4CLRRywWx1FHo4XQ8GnqcFxzN9S6QMslA9ZLx6yNvVQ+5WD7lOPWS1FrTcqR6yVD1knXrIvVoI0VYt2BOvhY57oJB7tNDxWSuXNeoht6mHrNWClndoYYLrZqv26DHwWRsa1Pm09N2ZW8hGLWIiD2jpwSRlhxahQakWtNTDnS3VIqmTpMVqqQeZQQ/ylx7UBWfQm2onv2MU6R+Sq5O31zFMAZudNVsiWgCL9A8qKtJn0IrYQGGjxp1k1yg6Ek/B3eZ30s3dibDGh/Qh1UJS205g/b5TTsX+Tl6/74T1+5Ai/b4Tt4X2Zg/LNfu3ULOH6WYPk+OmGj4i13CcnZF3kehAp+7+yJ7W8+cPPdhyeudDHS1t58H+3dX/zK6OU2ebHiAauNtI/pi90aPkJ5TcHRUQ5aM0nY4iojxNkHfRkHeRrHtqglpXjeQ/xZRI5OrLckwiRQAq7Cw6gij4UTmZOyKv4EdhBT+iSMEZ7D4COvC7yK5RokA8vV1KFGDpIiDztYBMUA+Zoh6yXAtapqqHTFMPOVc9ZLoWA0/WopfztdBxDzg+TwuFzNCC4x6I+gIt5DJRPeRCLbRHD+PmwcAL1UMuUQ+5VAtalmshl3pEwWlaDNwDD5mpHjLPD1lnmfZk+E53Jg9cj5BVDxOcqIUJnq8FLfWIL++crfFlkhZmI1ELWmZooZB6sMcDezlXizBLD7nM00IuZ607O+yFO7Mt5B1Wt6y5WOmy5mHvljUPu1/WjNfC/CZrEa7qMcv1ANJf1pzRGdZELTi+QIuoTY/kWLoWvdRjwVCPHJEHHE/RwvfQp9YT9XsRRSWBEfI1quQRDjzvkov9huUDz7vgwPOoosDzLpRWNmrcTXaNoiPxFNyIdTfd3N0Ia+4W0FTnkAvUQ2aqh8xTD5mqHnKeesh09ZDl6iETtWCPHqKerx4yQQu5TNCC4wlaWPV8LTieogV7MrSA9MASzdWCPVu0EHU9YqI8P4DxAxg/gPEDGD+A8QMYP4DRlj16iPp6LWiphyUq0EIh9XBneoT/eshlnhYcz/QtkTLIQvWQ8eohd6uH9GC9Z496yNvVQ65TD7lVPWSpFr3co0Uv67QQIg84XqMecpt6yFotaHmHesi9s1XUfR2f0QPXQy59D+lrj2vIRi0Caw84vlM95A4too1SLWiph44v1WKKn6TFaqkHeSIPslke1Axm0GW6pU/Xn2xtO84tka22V7tWTzXJqP3dIld+G7KNdArYHKfZEtECWPtbraj2dwtN5uoYmW3UqCG7RrGgRsAm1tDN1SBcJSCzvICkBUXq6NU7MaEQAXgHTWFY3rbJsTxbXt62wfJWo0jetqHcslGjluwaxclaAXmrpZurRYSDgExTD7lFi14mq4dcrMXA09VDpqiHzFAPOVcLWuarh1yoHrJcPWSCFuxJVQ85T4uBF6qHXKIekjpOoVRZZBv4rtLIttS7yLaUoJW76CrwHYkAZxs5bjjEAcODneglDtssskBd4rDTSAugkrHCmbBNXoCQ+ntqe+aW2M9KCeZsQQS5knwNaW+zovY2Ixzboi5EX6M0RN/iXYi+xX2I3qhFpLpei0hVD8e4QD1kpnrIPD8UmmWzUQ96OV+LqD9DCyFK0kKIErWgZaYWvczXguP5s9WdpWvBniQtBq5LssCPNmaw2fAkNLDN67Yhs9xaz2e5tfAsd5uiWW4tK08DzXJ3kl2j6Eg8BUtWdtLN7URYQ0CmqofMUA85Xz1ksnrIBeohE9RDJmrRy3nqIdPVQxaqh1yiHnKpFrRM00LH87XQngwtOJ6khXHzQIhStGBPpha9LNdCiFK1iDYyZ6u9TNdCx/VwFBlayOVcL9hjXzsmpsCbFM2qN5GvIXNnkfrQ79EAO6UA3k8D7JYCWEkD7JEC+CQNsFcK4BPYqcsiAP00wN1SAG+lAe6RAiihAd4iBbCeBnirFMCPaIB7pQAaaYD7pAA+RQO8TQrgKg3QIgXwaxrgfimA6zTAMSmAV2iA41IAjGTcA3L5sEIa4UE5hDjITp6g7eQDZCu2nFprLO8nnR88AecHWxXlBxmjaUWs/gly0OKQJ0QhKa6dUMS1B1jjJFqxcc3aKaTLS9RTYZ56yDr1kInqIWvVQ96pHnKnesjd6iH3qIeMVw+5VT3kXvWQd2kBuV095N3qIe9RD/kW9ZBvVQ95r3rIheoh71MPWa4e8m3qIe/Qwp21qIe8Xz3kMfWQK7SAPE4lXuJjP5uh9uLp9uKR9prJ12xha3w/XM6wVS6STpOfrmyFpyvxiqYrW3FauSzhkKtoJsZtY8N28hkAWYfudqklwejdLnXG3LW0ZBDNgtvIt9Mj2R4j4ORul7kl9hFtVVcns1JpncxW7+pktoJ1MtvJrmFsWOeMDRhkgXrIVPWQGeoh09VDzlcPmaweMk09ZL56yET1kJlacDxfC1Gfp4WoJ8xWS5SmBXv0EPX1WghRgha0LNfCUXgQwCzQwp3lz1a5nLX20hMPac9arIv9BI82WEe3tw5pr5J8DWlvs6L2NpOv2aZv69RNZlOVTmbXeTeZXYdkSbbLNZsiJYLEuG1sqCOfQUVQaJZkOwnGOhNk7rtoySCaBbMkdfRI6ugsyRWszqpBKpcEC3ID+RrSXqWi9ioF29usqL3N5Gu0OponWr56/uvPfPHyxz73XPuzT78785tp70lZk9w7PPyL3J/n/fErw0+5luojNEKdHMJ8rIpNCGEeVsYmhJCJ1bEJIezACtmEEGqxSjYRhMAcRimb4NGmDALcI/hpACtfExr57Vj9mhBCAVbAJoTwn1gFmxD1X8FK2IT68AdGDZvJhK1/Hnf3gx/93ZmUhsEXOr/5jTs60vJaPlMw9vTdn79a8OP7RrHqNaHGw1j5mhBCMla/JoSQ5LqALZdRCiUox0G89q28kouQSCOclEOopBHeLoewiUZ4xxQBln3t0wn/978/EXrx31450/nrVdf/qeHyX39oyzVj7da+gz9498/30p+2yS5+UQin5BDm0ginXZcwnpFDYLDxrOzxbxTCQ7IBMoVwzpTjHz323t70F669v3C18ev4hidevu9XTeHN3zTemfPZgd//+JUb9KfnxVSA5UDazU+/cvfv//2l9OvdFy5/qmdzyfyWD1//+i9/8oUvfiT9V997/qGvMyS3QzY+phAelkNYYIaYn6VCMGImkQ2FYMHnpqJmcg5yiASxxeIhZEoUlut8UH5KFIanRCFFU6IwHZWGwPW9TrJrVMTaSU4g6FlH0Ii0mvz7Zzt0ACF0UG6sOfKEDsKEDigidJAmdAAkdJjsGkVo4mmhBF/DyGyDgFyqHjJdPWS5esgE9ZBp6iHnqYdM1WLgc2erXGaqh0xUD5mvhVx6QMs8LeTSA4VM1kKIPLDqGbS7hoOXeM+jxHg4eAkrCl7iUVp9qD5KqpMnTte1tLW968WO9pNtJ9u7JsLzupaz5zvaolR8fm/rqTPnuqIg56IBOBnc/Glja8vZ2nPnWroIesYHrvU/c/DkqbNtrcT+uPL+p9948erUwzemLoHrIH6c/clkn3cCf2+8boVm/8tCVIhkEYRkjVg9bKT/qboWGxdjBJvsyfNvNPr6P/advUGGmXs72pifxlO48VCIjfUgfrIHNhUIzlQVCHqnAkEwfo+QXaNMSYQkrLh1IqYLjvpoUdMXJtV0R+v9HSf2nDlx5coNQCd2sHU0nA3pEKTTNxg6vZnSafJhNlvjADOATClFBQo2/4FYtsA3/r7xn+XG3/5KEJI6aqwEWLOiyKyZfA1p76Ci9g6Sr9FZQTOf2v/Uc/9ee9ko+8Hvky/ubRm6sP7SV4/8rDv72eL/ePvzeR+eN5ULSy/HBALUyog1l8nmK52FixhZL5otb7Rq759Pau/2jrZ3HGhtP3eyNbpKeubE+StX5JVsL/D3O4SUTD7GmNZkbNC7ZGxQhaUNAC7ca0t7h/eWFgt5GjFrEI8ZsQDP0gasltZi/xD7GcAtbZAyI36woSjYCPjBhlywIasCosFGQDrYgHvwzBvFb4Ae0s4vYKQfcK03Ub9+6FzL2avXmAriuyzfZc1yl2V/JQDONGBlcT9hJ0lD617AjNK/3153tT1yqvJniV+6XP6B3MXfefXZl374m67WzS//8EefWPKqa7U97Nrg3GnG6w9Q0hEhBwzIWzav6iHCMJXZRnqb2e7brYr8jeJJTT7c0nbyeEt7687TD3W0drQev+NMe+v52tPHdz7cerrd0bShHvh7g8S04Zno3KXj3GmIHGufPNhxv1X9IjH1Az4qZdVbmx+hlCw10s9O6ERb21Vj2WlUUNfK3NJZ5rn7KPP+ls4y2haWqnAfEbb7KHsTuI8KhGS0+ygjPqQscylBMJ77iFjdRynZhB23jGQE6j5IGMB9RCCpA3UVyIys5eppv6mnD2HdWMujVekEi5gOMGLX8ApEwzfIVupLa/gGWMMrFGn4BlpcK1RoeBlbwzccltHwwxIaTkgh9CTsQMtpQSwz0v/YdL2XMI1eJmFWy5BYaZlFmeH2chW1l0u+ZlOI7NjP1fZnOcizInI4tmfF4OLN8tjPLPuzFWSHbc9KQMQ1JOIkFzOqIMJtQ7SDNuY1xIew9dlGTYuJ7+5hCNw2I/15U+DeR7VaISBwFaiWYwJXgbWXq6i9XPI1G8PKEKHagAjVRlAENiFCVYUI1W0gYjVLqMo8vLTrsNL9m7fm0i63O93uvIX7N+vd7N+sN9I/7eH+zfSP07d8K5yYW64MtzVUE9OAqc78DWg6gTCPMHbxTGOX9T4T/DOYia1F9Ms9GbYRQ4V3ky5StJt0ETIsr7i7CIx1Y9z9Z1DnAO4SP3cyuLvdyBozwf+FoqxFbRGyL1NE9mXTQPZltD1S2FBdjIcAiRpQa7mTIns98Sk162oi30NnksR+8CZgJmlpCUtEMgT1++Bw+YJazxDUBiPrlAn+H44FtY56WEeaGMj7sNwAwSJoqKjTquMNOP1lc3rdDjoogJr1uFGvM9J/YYJ3SkhmDbemron+qIHsF0L/JomO1HNTkE0o9S2yTROoyUj/DUF9hjcilRDW0JUSIlWPmJGV5Gs27atXaa8sfeer+Wsu1HwvW80PmwF7kKIsKkn15FRBDdlzp4Hs1DSnSWVDTVx/tAdV4L0U2XcRn1IuZB/5HuqP9hAfAf7I0pKcP8oAD2zcwxfUXQxB3WNkVZvgWdicHBXUJkzEtzmzseDNBbtQi9hgERJqwLuMjMV8fwSpfRPujxqMjEK+P9rlxB8xxHmXIP3Buy9qaMwmrj/Cqd9kGROL+isE/VENkrBZhSRsttMJm+diERScsqlDUjYVdMoGNqjVFp8KJW2ykdHkkIOG850b6HwnMWg447kJyXhW0RlPYtBwzrOayHmyVpUztrheycQKcMpoYYFzYhWer6BWwDmxMkU5sQo09e58fSWbvb5S8SZYQd2AkKwRc30bsJXObN6qYLZ1BRVdma0gGYHGGSQMEGdkQ1IHLufwV1CzmQtXGXtMo94NrxVR9RfZXGdTIVZ/wepVhZHRTNRfQA08w/Jiay0SwoI+Ztq7gxIaupY74A2od11riQ2pfm0wMo4Q3tUuDxtokQGFtgJcyt4AqxeDwUTXgc82io6YxeSNRsZb+UzOpnu2gcuJjWKit4HdqxayVyxjXHfmbNekMWbswYPNJeljpBeqs29I7MJgmtYpqT9GSRcR9pTxpKsMlK5qK7VeMrcrtrW2t5r0uuaAXmXXZPacYPFDjefxQ4338UMNGj9QKyBE17CgvRpqrlo8XPnYJM9fb8ZkuZOIghnJVAfwiEJwl2n1TBWQau8EpNrDAp6aN8GOjG0IyThVHe6sqSXArCabsOPWgDEh0oMaIMAsg6QOtAL8AJMVb1UbGb1EiZ6oW2mJ/Yx4qL6Zs0p9gQrbmgwZ9c1wUn9XBihwk5Lqu4iRccOMbsawgvuDEhuyIkgK+yAinlg1HFE7m0VnjOFnG5BnG5Fnm8guUzkyqHTpNhJxiq7fAAs/HKwJiC/VI0aYiF1qJeqATMRmbJV2u0Q9jol4AFsUrpNYEDIR92OLlfW0YBI+4n4s6d+saHWqmXztFq1ONdNHt1BrLc/Krg4QRuIYe1FwmQn+3x0vCh5URPaD00D2gzN6UfCYDouCDEH9C9lFwQjZLnNRMMkE/2vMFzpfFKxxtih4zKtFwc+7WRScikTYS4L/4GhJsHpalgSrPV0SrGbT/kvYkmAN+bnEIlop6eThMKnW4VJiHRImRZClxHokUGogAiXmItq36clKRN0iWgTT9CJFUW+RYHsrFLW3AmFLBJkEZnuew8mGJ4ERRZPAbJRW8Lp1Nk3HalKzaOHMMTJbTOn9Ka2nMKFz5MZaKU/oHJjQ2YoInUMTOhskdBHZNUxBQINbRDdXJKZzyeoh16uHTFMPOU89ZLoWA0/WYuDztRh4inrIcvWQeeohE9RD5quHTNVCiNK0UMg8LWg5Vz1khhbsSdKCPYla0NIDE5ypBS31MMGZWhi3WRsM5msRbXjAnsVaaI8H7CnQgj35WliiuVrQslA95FIq+UfseohI5FlykPYi5GuOUjfi444A1RWub1zI2Sh340KRgxsXNsrduBA7mNC7spoKDctqnJZN3iFRUbYNkfdtAp7eOWSKeshy9ZB56iET1EPmq4dM1UKI0tRDpmshRB7Qcq4WtEzSgpbrtRD1eT7HlUEmakFLDzxkpha01MNDZmrhe9K1MG7JWghRghbsWayF9njAngIt2JOvhSXSI74sVA+5FNusFZHIDdSIJadqnKUbxMftWXKqplwuObXNQXKqXC45xSxO+5fpq5zcpKiScZNge55UakpUTkoW9KUoLeiLeFfQJ1Q5mYNWTmZJlF1XI6zxIX3IGQ9JHWplKrKowsMN5YjZJvcNkbttbCa3WsDES9JvE/kaBAnsQjkW+wleO1AzedrNxM5c1jhWM5xnjZH5B3N/xiNgZbe5GynzNdmeZ5M9Z+3+XvjTKfB5QYwNOaigVKMhWBUGXKSIv0Ui/KUhie0jxSBr0T04VZb+MXg8L5W//6mKL3nVUpJXxZO8eRkykjdvnmzPs0nC0h2oMhYaJvhCSkCKRSWvGJW86lu+DQZpr1hRe8WC7R1S1N4hwfaOKGrviGB73vAPvqOqhH2cUQ4Sr1fJhcwh+Xi9Co7XcxTF61VoYQh16gDRNYrUHkz1Ccg49ZAbJGTsCDd7gFNSbfYgchh4/wD7/ao4+ezBYZnsQdxMssWVitqrFGxvs6L2Ngu2t1VRe1t9er55xseP8sBjRyL8KK+EefLPgldN8IPYgLcoGvCWGRochRS1FxLwoAzILVzfxNjPHPLMN62Wy2xnO8hsr5Ysu5w5ouJJe7RurjIWLDB184SH28rXK81CT8u28hKyaxShiac7oOZK6OZKEN4RkKnqITPUQ85XD5msHnKBesgE9ZCJWvRynnrIdPWQheohl6iHXKoFLdO00PF8LbQnQwuOJ2nB8UQtaFmuHjJTC1rmaxETeUDLPN+qzzKr7gF7FmuhPR6wp0AL9uRrYYnmztZY/U4vYnVkd/UhiXRDjljuJkdmwbFELjsSJ5+aKfF+wbFEZsFxDdk1io7EU7AQaw3d3BqENQRkqcQI+Bvf19zC1cGSCuD9Zvb7a4LyGdgKmQwsXXyULaBV2SidMa3Kxtpbp6i9dZb24CvkqtmVBfRx1PN+xEjkrjbm55sv/MTDRK6Dg1inPZGr/DaOnDfBZTpFCMkaMfdWhElxhHeZTsR6mU422YQd11KFih4AT8IAB8BHIKkD9Zx/mU6EeYz0vN/xb2tkXJkXiVEfknKxK/MizC0a8/6Tf5FfzjMO7gjMMeZnTpme+TIayr+tsUj07sIcRr+KjPlh5LbGIlpkQKF9vfOxf7aQKKB6MRhMdB34rFh0xCwmFxvzU/hMjtA9K+JyolhM9IrYvUr3/LbGHPFrjWKEUHVb44T8I9aGf4FtLXitlle3NWZL3dY4y+MHp+eLyxRnQOGKqtsadwJVGA5va4ydUGWPFIhZ8iZFE+9N5GtIe8WK2isWbK9IUXtFgu2tUNTeCsH2Dilq7xD5GgTJv0rnLQznUmLML+Nf/1IyEXQC0dYB6KNSepCHnFT3lmLUJhIJVRIdKeE67GonvWduhyYGYu89scGkxknvm6e19yVk7/3rZ9XcX1k6TdfP1ut6/WwpLzwsdXb9bKnr62dLIamD+1pjDWXPkQiwhonqBxSQbVMHVYvo/XY51Vsor/fbYb2vVaT3jMs2a0Fq1JFdo9x6HamVQHN1dHN1SKRAQFaoh9ygHnKjesg16iGzfEgf0of0IWcAJHaoRS16atT92OypWNHKbjH5GtLeOkXtrSNfo5a1ncc12JL1OuxSbZCQtWjkgBGyFqxeMBc1518CmwUSA8Ti0DFGYqDWWBA2wR/HBjxF9skuxVnEcTIMm3wWkgvCYmc+9NkpsH0KMiyhY8RF5R2olmWj7N8uwI4/AsWbz44OBjvWGPN/boK/F1te3CZVGkE0CskPuqKSY9E2hhTNfz+5hgR3u1pWfgmGPMxu+SkisQWJaI5LEV0Ii2gtV0TxuYQjuV6DynWVRP5+DTdFVoVKxhqLfjDOLpn/Av9IFwFteZitLS8KML/WO+av4TK/CvVz4hJTZRFmO/MJ0SiRyEbnuGR+Dtksk/l/xWd+DsD8Epz50fX0vxVg/hrvmJ/jhPk5XObXosxnFO4RTnq5hFcoccn8EtwnRJn/RT7zS5yZ/eh6xj9Pr9kvccL8EpfMX4My/zZ00lAyo5zCNwnRwCYzMvcllXi1Nmw+qQHq3BY4WR1eIDG0Ui5DSlCGlOIMiarT95AaIHJLt/zBTms8Xwda432d9RqZOutSVGNLXfpqjyof6oHqZ4eVD+KyTRT0UUW9xOhjZb1IumGbhF21zGmgKFw0/KllaFWdMf9XfA/IDPR5bqKelVkiiQWTqJ56WEf6C6hBwE/X4n663pj/OwE/Xeedn67n+ukGmpb1XAY00R81WGYcdq1vQm1CNdm2AxPUSBtkojlutoIx3yh2OUPNwXJJddRDy9wWEpPt3iWa6rhiUo8mc2Vki6ARJQi4EK0h25axdAJiUkvkGCkfHiA3q3DpvIIGCEoB3E8DxEkBrLUPNIQEKGE5KTomH6CE4QAlpChACdNsD4EBSjzZNUrKiKe3Q83F083FI1luAjJdPWS5eshM9ZCJ6iHz1UOmakHLPC3kMk09ZLIWQpSgHjKgHjJDCyGar4UQpWhh1fO0EHU9rHqyFvYyXQsh8oCWc7Wg5TwtRH2eH23MZOPmAS0TtXAUHgQw67Wwl3oIUeps9ZCZWgx8oW/VZ9kcUo8JX1ALWuph3PSIgpO00PH1WnBcj1g9ToteemDVC7SwRHo4igwt2KOHJcqbrZYoTYtoY4EWvUzUguMe6LgHE75yLSATbqFCBlh3166O/VzFqL8KTFwqhhRjCNUcUNWeceqKKY47KaawdSdM9gwstCA7VrkB7tiHFv7tW3cUvfYWiUKLMLcOKB6tzqCImCBHxPvBiql465MQTUWz7IlofKpK6gbds3jZnslQkWiF0hDiaZYz1jx16FzL2asWMSY0wl6QFoz9BLd6Bun2goiSFwu2t0JReyvI1yBI/mWFrPOkgsaCPxB1nfaCcWIw2eyCccyESJZEObgJOASbiThF9VghmldxYD1WmOwaJvonnIk+BrlGPSQq3ZWKpLtSsL3NitrbTL5m418wJmOisgg3ZKEVXMbovqEQOThKIhU2ZIIdogsRFTYTT4ZFtoYCsS5MlrkuBG8LSQBsoolxgGERE4yFZ0zoQkogLT4ZapcV4MWRg2I2W0xb0EQ5IzbH9I20qUwUoCTosOKcUDLOWHjAhF5FUTKA6X0cKd32hwmkRNofJpIgwHASaYuRiMhjHELFRMT/JclxLyzv/5Jg/5eoyP8lof4P+CgZJfBz29tajr1j+5kL/S81nznfevL4mdMVza3nTnW0R988c/oaQd6kEPGP5BBqZAOoZUxEPV0CaoVQ4QWvHQ/QRMCs3lbyNaVTx6gaup06rvIw7lvlJO6j/CnRM6EafWzq+MG69ybV3NOyTiImDHF1ghGGbUWmjpITtBJw6hgGp44hcOoYj00dw7I9k6Ei0QqmzVnOWCM3dUQfJmAeKhHzUEkCIUQy6HBJg0rperKx8C7T5bZB4Ck0jRK44ptKf5RC9ss+ymTiUwlMvm9Joz9KxTpC9DINPsnz9a4we58CalaCy21sYXgbW3JMKcWZmOyEdimoA00jiYw53zhUXZNR55vIWVTnCnQc4mkb6biX6DQ38k10IqJJrPAHEdEEy2hhWxLEbEkIU8EwphagFUplhRspZORBm6BUY2E37TPS1E1kwLx6CvM2l2RsipJiLLxiysAjIDBgjHnQfQI7phNd2pAQbENSuDaEadPd2d9k1IaAyywJiDUDj8pIRDf1J1u8G8WfRGPhJezskiBJE8y2JbmYWKw2he95cGIZm55fA+0NIKCJmIAmGQv/zIR+lzdmJx4zO0kSri0FmTgl0b6a/o4xTUn1fHqeCk9FUhRNzxkqnOQsDHAyPU8lp+dpoemwcklOrFxSzLZQ4pSKKm8QVfwQajTCSKuWQpuYURA3l0IBTwKRNEV0OojpdAjTaTrOSBWIM9JA+0XKJ2XB0oyFf24O6J8g8LlOAuV0+qO5ZL/soyR8XLoEJl9VM+iP0rGOEL3MgGc76dbZThr5PaTDyd7NdtK4OsxgYpoT2lmYSClhBklk56qfhkYEKZwiSK5AJyHJ1UY6jCA6HQskkJttcrCrPcArvhiXhRCfZUOf4afVWu4UYZ0Zu/CryGm1xDk14M1Vkoc8F5GvQZD8lfjd7MF8g3+zE+OAnyKuHuAH/GTjB/xAHQFGSRz5xzqmerux8DsCs6Iql7YmRflJ1Dwa19Mf1ZFUoUSpnqQ39TSHbJt6GiFVBOgQ49TKbNBKZJOknzqgbR4lGNWaWolfilmJTYqsxCY1VuI4ezD/15GV2KSZlfiDgJWo9q2EWytR7dBKVE9ZiczXIOg9/BsOWbzfY2Sl8iV8H93vBi7199Mf7SP7ZZfwPcSn1MN9JJPsD/fHfjZBvTkA0Gc/bgEOGFkLTPq8D9SNfS51IxnWjQNc3ThME/oAlztH6Y8Ok1Sh5PsoySlICGnQ/dy84j7U3ewnm6X5s8/IKsDyivUkTainTc7GJHT06p4pnc34C0pgGwRsRROrXQIB+GwXSs0IOXaamruMrJX8o1cbAFVqmiILC7rByFrDNzS76EFXc0WZwaFdZK8Q6u+hHjaRsgOpe5N3rnAXV92Zw+XRiGHB95BiQanGPpJemFrtAsXEoeI0mIrzrKyzI37uZTu7rdPi7CpmnrN7C9vZ1d8CZ1frOzvHzm7/LXd2FaDOVrCc3XzM3G6TcHYVrp1dBdfZ3ePG2Zk/49nu7l5H7q7mTejuts8wd1dxi9ydkOqY7i79NVkZJH7uZMvgWb4MNjmZWTMEtwlzdw0kAREZrKUeEqJdJxsOEN/uZocDFwTcnVvpnwdL/x6u9DMF2V0wsouW7/0CtrYB0UPQ3TWhBnqXJcKi+NNkZA1i7q6WpAn1tM7ZmCR19vvYkfzbJLJZFvWD8lmi7q6OeadE1mW+u4NSiHW4u9tuZF3hm5p6J+4OvwsAvRKhAbuzo9azazXmz7BrNSrQWHA7qlj1EklvIdXZbqrOP/OXLUw8Ql6c577DbMF9ki+4dchgHWefEcGlZ33bRAR3m0vBPTzDLvqooUWzQVRw6/jSRRshSnAti11Tgvs39reKkLK3Ys+v8SqGy96KFJW9FePr4OS9Wi9O3qs1Ib+T12pdAy/VymFfnlUcuDZ1LxZxfUk5dGmW/KVdO4G/N+KXdtn79DpFAJItR0jWSKk3ccbBcupYAKIMYuoeObDUKOfJvR1tzE+LKdxikhGWMSE9KJ7sgf2VHEjqIAIVAQY7nsSkDXaRkfUZ00w9hHUjnkerImtZVguJYtPwYkTDl8spWaa8hi+HNbxYkYYzxLXYQw1fniGj4RlOLp0sAnS8yYGOs67RzfrSlEPIuolks1cjy7pZUwiROMSliIoLz9euQFhMW6TlxIdoZdb91KfEASrNEp1ZgdR4NJOv2Ui1wgWpsMNfmvkX2Wd9GxpfCf9q7mPMG0Ujd5jg38HcxAqM7AcVkf3gNJD9IHhlsIqGSmI8BEi0lqUmBNOQOyLXUu7IcqUp6mLXEh8BLtbSkgWML6ivgMPlCyrrmuq1RmS9Cf4riiiWaEA8qLRoByTConeLFjO6vcLI+q3zq9WLsQXuqEf4f/yZZA5qhB0NuRgPmKJDfg3LohUhYQ/hx1Yhfmw54cfoDkSMSDwdNeWo26KYI3OtcpHn87Ei769VLmKpjoJoLcKO1oq8no/t9X4+VoyQjI5+0HkTYWMivDlGxDofs9hFZJYVwZ0FCQM4iwgkdcLzobBDDZOcksQpzXjkeJfxgC8uX052jTKwy0n5F59+LUeimOWkGQYgs8VthOu70AkRZhqQ7KCT29CDEkOLcJ1ojmhhXDbTuUeKyKp2WNmAgxuzEYXJ8dwl5cAKk61IYXKQ0uYgPbsluoZFJODWhgjanFrpNp0UU7YjASeyHZAYWDxXtrNR2Y63qAkl29lGpBwLEAPk51M58HIX84lj7PlEJT96LsWzVOyPyuiPSsl+2X0/MRMrox4SX9Iz8LLYT/AYpgqAPsS3rDr0CiOyVaBWodS7OvQK7grQBierZBvpjzaQVKHEcSPJKfE5fBlXiUpRJSojm6X5U2pEmjAlWkHShJGVcDQmoQvq1xI5ALvAlpBGF2h3DTpNB+V8reg0HcguHORP06Ec2xpsmh7NsB3mG5q1TgwNwzqtJXuFUL8USyutANV9jXd16Gu56s4crltjTKmGxaZiagUqTolDxSnhZ3kfefJgx/1W6ADXzjzK0gy60iHAEN5HjchJk2WnaXIQOZlH7CN7FIlAez2PQHvhCPRRRRFoL83nR1UkRQLsuK/X66RInfdJkZt9CM3orEgv+SU1CXqUIBkvLRKwpkUeJduw4/aSrEDTIiQMkBYJQHIHaivgZB7hamo3skxNdOMRHq0etaZlakkUm473Ijoe5ZiUnh2VV/JoE6CW9yrScpbI9nqo5jf7jsjo+REnWZNHwSfblSxWB4zIdTNFP4SdrrwIIrvk6cqLyNeQ9nIVtZeLKAVxkMxq5AaJRfZnnbFVNNuTC7GfWfZnXWSnbM+6QcQeBPGd5LNJLmZn29+K6p7CZdIY2iGKfTf7yXAJUtN+moHRD+EWcyzv2QfXr3RwlgFwz+mP/Ak4yAH+ucGsUuybA8ay/Sb8B2gKD1g6izFgkTIGLJoeBlBqd3NQaVOD3AX/m8MMSg2QHKQYMER+TTn3myOWV9GQJfo58R0QtNjaw5b+GeL7IjxwvvhGm2bI77CxrNLE/7gb+Y3yh3o8aLFDUOeHGFwbJLkGjhrNTFhaBwYf+Uss1RPtM4mADW852MlB5uiEVoSi73mtUkSzfPn7PMxCvvyxtsHeHDKWFZjw/4BOU9TSQsKC9MLTKJs6IzaL8S1hL1ZKWbRhhKUrLe/ZKTasVHosA+BLz9fAQY7wpYd1CMDNEWNZogn/DZrCI1bjjjAgVxkDcqeHAVSEenNUaVOjfOc7zqDUCMlBigFj5Ne0r7xoeRV3vuPkd5DztbYn6Xx/Ag9cwPmOseR33Cj6mYn/M2x2xRHfKHtQ4R8E+z7KYxr04Rjue0esskOPfcyIvMpfGABNQxQU9ywjRkTgwLebY3gOQkLUx8TZMS7TnZjqNcL9wZkxyhfEyH8KMGMUYsYYhxmjRnZAgBnjjphxkUGzcUvnKGaMWqyMeBZ6gnoueTFmGRuLFdmJaEw6SALgeV2JkLSX5KAznbcGa0yVz54rHG4PIsmfVUjyJzpjobI/sYf9SAIoGszBGaAAnQFC/HyPRfHhLNCEoTDTQKxLZrNzXS/xYPW2vdi9oeA6suS9oUXka0h7YUXtWe5hhSCtlsx09oTQMNmxzJTfD0qYjTA8CwiSzPBwDcDBQt8MWAOgc1dk79BsVFBCmvgnQcusVbwwuVaxo/X+jhN7zpy4cuUGsP63g71QEcyF1guhhY3ADcbCxmZqYYN8mMtecoBq3G613s6g9pYpam8Z+Rrl3BRO1ix9505sssF7OHv58xrWYTy9RtG3THD6GCAh80xXY3RyI69esWqMTmaXs+uJagyggU6AHrsFRtTLuhGMiExWs3u1273lx/z/xNq/jT2dAorWSQt+p5iidQrSlnbIQQaBOo3s/aodcqdgeB2WaK5XjDhoe8WK2isWCzjcWyFL3/lW6F7Y9fLu0GYVB97sM4r+0QRvwaxQL0xZygoF+fO/PjEzFGR3OvsBvh1iB69NAiO62ccyQ0HcDE306h0MO9Sv0A71Yw64RJEDLpkGB1wyM1b3w8oWl8OW9/h63QW3zA8vmBmSfqPoqgn/Tjy+QKSK4fu8Nu9icZaY74sGB0OeTka5gcxm5ocr+p+844z1wvTYtxNmB6yO67VWEnaSP8GPohMzy1e9Ql+9btktomD+vttzhTV/34Oq7BplKrtGUmWvu1HZewGVfacJ/268yqAPZbaVbwMkMeHPBq0yIt7cpKyTULHfWciXA3apnCTynWz/mhMwqfPfbt2S/z3oevZaqXqNIaTNtZb3QPWKCeDT0nUGpFrdyy40yH7ZxH8OX8hXW2kAC8mwTSyHLL/h70Zs3w1bRPuWLTlHM9twH0eRsQ3gYhlNitvHMKR0DEOWMdjbGlHalol2WETwPy2/9EYI/gPA0tvfmfh/RQs+uuYSIGcGeDJ2somcYmRtc2o6NTnuIxYAeFGQmoWJLMNdFJuGsddDLxrZf0/Mw8DSikaTsv8AD1tgBTu6XsleL/vfZgNfxMsnGMV344Lm5CLt5cZJJ8Gmz1fNnn0Zb3qEQT7yzSmYf8Xeu4d4DR7JuM3oWJfkcaMzjq8SY7ZuzNbsKKfZEUsX0WaH7dG0tdBlIp6mqlwukW9ApTBkbc04b98KRVhrZQ5GGcuGF0vXxiXasxYw4F5pnGPxx6VqYfpiqk7bb7KDMROO6imqiIj4jnFGddFpSQmmnGOEeeNETE6jHDjGpKz+24TcxQheftFH4jHLhrL/Dz8DB5clDXHi0Cj+rwUqYUad7MgFWE12Di1LGsPL1Ue4ZmIEDfqwYNEyrbtHUF+GbNbFWnPmLH4e4riJEalZkaD1GCJmPrN+9peT5MXsr+iEiZ/6pp399c78yV+vP/cDxD7fi7lf0RYTf4nzud8q4bkfZqytMtFv+c3a6ZqzywQuQfafU7MXIgWcBZf1sxbCLNNd5n6hnNjNl09j9dobFO2G3UC+JkEDm+tlkreBsaY3LHv/H6JBNPqoLLp8zdooGtCOwBVtls5VboA7t7Ks+ub30t/zT1LTiFFHwdsGQjKo/o7LEbMGPHomGvdZHoUY5Jx8FLa0P6UJNxi9G5PtnRw1yYZYm1XM3yecsglFjVosL2B7naJOrayTkk4qNRJ8rmaEO4T9nLLAD2LWrkKRtatQYO162caulSGjA3IyugGLrmj0EVl0eWPHCmDI3sHGbkTQ2K3b9M3SL3w18e3wRJi5f4hr7EbRA+Zcm5My2NiNwsZuBDZ2Y6ixG5XtnRw1yYbQbOIJp2zCc5T9nsD2OkWljR2+ANaHBbKDlnHGrB17mfaM+cbbZZZKLBEpEkrTDwdI1Km2H8XCbHOuMEWwfdYg35ZOtuQ+JoJhcO7NCpjJz4PsiXdOp9nvdrjfQWsGKMvaZ5ihQRO8C82wDMLvYfMcSzUJPgcS5BzTOZnZ45w+zM1uUuRmN5GvSRyx00lC8Ge0i95m3Rfxicl9EQ2t7QcfbDnXevxg67Fzre3wMUsTaWXo0RD8aFjupKWoQN8Awd4JPumFO9APPxq4IdI3uKdYyVqZopK1MvK1GdTeRkXtbSRfu0UV0BvRUq9KZaVelVZ3hrS5WVmbm4XbnC3jLFPWZpnlPW7pXs7TDkr3JkGa2YV7S06Z4M+hg0Z1t0qR7lb57U1Le7cpau+2abC9t6H1piAlbw4wDxMTomX0velok28fPgu37Mg+DBhLCk3wv+fYB5lB98NV6r2WMUuccRADbcZLkPGTzHql2hwUE1Le6WkDyhqdASOVWVo2eXYAJxBcSjKMoe7nHgmIH3mnytHbExFYq0PqWh0Sb3VaxlqlrNEqLJLy7lDMKgGj/GNYdB1tfRw2lsw1wV/GD46abeT3aon/kACffyu9wo/zedQo/I0J/v94fEbpxDy8cCTWuowYDPPT/yN4DZHMKhjhdeysHsOWZySXTx3c9T1R4QouwIypOkDlInZKle1kkpcmM3C1refLKzbviKbfus62XwMOFbmYAaexxq+hZ4tkMM8WuQE01J8B3e8NfDCSATwYzbjhoF+cT/CnqMscU+cyxywvCk7yTQtEyiRzlr8ojb+XlBn0jcFxuv1wYHttqTUKELrkov/Jgw+2UQbA/H0G7jqTMI08wgwaixYIEGYII0wzL25Fi24HxQgz+MF95yhxsjSCMKdUmZiWTo+XL+U730WF0lWlhCk/y17bKvyBCV+E7UO/lbQAN66HgWGeFYrxmct/xBBXsym0aI37IrM52MERw8hyXmzVb9E6WapwmB82Cv/VBC/n8F5Cu8L8IGgITxFJzIKRg9YUlvEFvuuojE+sdsVV6DTGqV1xHDqNGYHvwMHTKB48TXwrFT6hjQ0CXw1BMdQwJ4aCuqc0igpbOAKpLqo+aO1J2PWpmoWIVu84+TBcsIilQfd2tMFOvBemA71BdtRiHDhHeQA0PMQ8dWTRTjMgeg7j2yZFbNtEvkYd+6rQiVr67u3SRCw4QaKyVmVRWavlPTRMH1E3YxGrIONoy2mByO6IgzUNyxhYyxqFwyb+3VhNThg/WUziDONOEh+pZQoT9TVIxzoVFQtZusU6E3fRebNDrViHdinq0C6ETgEkbAl6fmBuEA5aAopiliBKKxs1QmTXKDoSTy9INLeLG2qG0D4qPip3tdxRuSEHJ+Wuljwp9w1lyH+ArS0P05IZVjcfCmNnenVKsDkoZhLgE1yfAbZfg76PsJv1imKHevI1CNLBiYhhY9F11xFkM5YTcL1ZodnBpGsAK2KdqGoEp2QDgtsJKn5+4ertW1b+3mn9g0Rmsp6QC6q/Q3LE3AtvJxiEtxMMwNsJhtDtBIOyvZOjJtkQWh1wj7IyldjDRqeYdNU/Wns2XWaPm4DvY7uF9/DTzGHk1OVG/MB0e4qZPCNzstiYNmdvPKDF7zXbf8huhH7bYRxAlMxekni/SZIPYTdJBy22BxtqL+8AC9uxkBYSIlsXoAMo30Gn9vuF+01WzPQDp/gE2c5nAg2Z5HUqm+NZb1bB2mxQ1maD5b1bllZvEJiIvuhmItoGzENjs6uPoxeEgVPsTkZ6qI9vjvsFz0/rA7T30wKn6EAne7cJCStzQ1IfHrlN9Oxv3EdX6JIEXKrXZwbFlRsYPmeX5LruAREyDfBvupFYaQggy71i1XhDvJXYTpmqkQCyymo9rQQEZfanWaQ/Y0h/DuDnuo2xNxgu/hdT22+C02tciFg3coSMvM+bwF9yCLyHCbzouybwVzD7VKMo+1NDvuZnf1Rkf3olmquZWdmfiPfZn4jT7I9dGQiKH5YgXghRhsPka0h7EUXtRcjXxCEPc4Wmi/4o4pXQhPKA9w+x3++aIy80eTJCM4eK67vIiQd67y3B5K6pSQKcVwsoyquJrn8cVdTeUctrrDqT3HjXadVR+vZH2J10y2JLu5Nu5MLJLtjVdAtm4jr+18K9//rRt4AhZzfNoW6uGvfQHx1F0nCSCdMhMAvXAybhusEcXC+WguuR7ZkMFYlWKEknnt7jjDUMSN5cDwekEm9dgtp/q62NJ+05ysVBXg49mrYTN3JdRm4GcXku5jJ4aa6wNWNl2rmDHlrAsBMLCFq5LkUBNUPyu8CAuofsGiU1xNMsCfvYgwiidpBKC3Qo96cMqkcdlJvCIOw4zmo4h8TIl/Yh7Km2vIdVPVWj7qiLxXnT4mEbPldTI+0SMNpdqGpiRrsLvNvNTNXmrgebBVKSlvUklnXOu88Er8QGLHk3XxdJR2bOKLfa87v5+PSskaenmShjUnO7CX07Rs0wqkXd6JpED+8eKmWrn32WF+lFdmTZf9BzNztxypLQwr6rWutB3Gw5LHZ/bntby7F3bD9zof+l5jPnW08eP3O6orn13KmO9uirZ05fs6SnQ5YpYwi1hV2oLWTdYNRjETLMHq6SMHnkwjkS+nbdchOLtBevqL14xKR3qVzns/Sdb+vAm2q7+b7jIYa16zbyykzwFmwhvwumrIP7srud35fdbeQ+4Py+7IcERtTt4L7saK/e4Xouj7nCHiQodduugxWHHrE0kBu73YOngcjE7IuTidkJ8a1rOXu+oy2qY9C+lE52rrUncI156h2QbYePDowDcrwN0IKB3JmBr1ME2lWBkIw24j2ki7BP6gmX08mb1HdaJ/WWNJMdt4dkBJpfJmGAIpROSOrgvr4uVbF/tpMI3k37etVBkXfCug6+5zuI2bBizD5VMVs/HrPhxaJoZWGcyspC83fIE9QsH9VH9VF9VB8VnxT3IVsdm7HyBJlaEqw8IUi+hrTXoKi9BvI1qvpG4QTV0ncs4RVUljYOWt7j1r7mfkK6yJMIZx5iZzbzlpjwn8Jqn6HKhy6aP/TacZcZwJmrx1Lh01xzHtwHR4lhyRjL/N2GVyXjsiLEuM8JbmVg8a2NuZchL9kE/wJWEihTd2ZpFNJedHnVUqnHqmTMvUkur8Ld7gbb56d/drJb/jJxIygkpwGXcjofltMQV0y7UMMoYXO6UNm1bnMWLxgNcnNdYVQ2ghYNYWz3y/0WIRvO9WUnU19y/6cA+0PesT/IZX8Y3SglLjOWYg0sDXvBSXWpQ+YHLDLNYv6P+cwPAMwP4cwPGLkvCzA/6B3zA06YH+Ay/wLKfMbay4XYz3eiYaZMcXTIpWiEcJ8RFY3fEqKBrfkEpXwdO8H6sckE6+vNTGZYr1yRyIGaT3qAcup5eBaUnYWdJ2Go+YsSQdEaKfZhFLmvITVSpJmfHJLEDoKQ5/n8kPc7CEIyOwhwjQ3PMOk2M/xs2Q44kW2snj8oEMmG0Eg26KxQkOOwuoy8dL7D6nK2Ht+PhnQBjEiMHaJdAlE1eHEJx7Xe7DfysgR8a5d3vjW2GzUslY/p5/NhEN/ZH8IPXQ/iiZx+J+rciBzEGOTPNlmSxY8xAfIhAmmrxcHqg+CcwcTyhmdJgwG+0Aw6OyWDVUwziIbklqNo+/Bkw4DMPFBIbGI3i8PppW4ns8EewKQQSsBKbfQYeRsIiyK+/suPl1k06iU7hqwbT5AJviKlC5TiXpdCnOZF5sutxnNS2D3otPNmH3JgWzdRADQtFYnIbSz8zBP7nLtBI69palh5b5EyHAKsYl28MmTxCtgW8mEZ3C5+b1h3DgyjvSGN3whyysmwtZzBthEedCJ9LvUvjOjfIF//2N7AERmHcP2zXkrtouxy0E3Z5YS350l6F+pNYNvQRRRCY+ofULY+Y3WTzFnAcf6RQgLV7m1s8BN8R4j6/aCkX0D0tMsiAhj5w6j17Uatb4/Dm7LY9yYTnwInp+ed8/zkdNCdsM/uG8BK9idcyZipYB3SroqPfkFgMufapoamxaZyHCWr3Jx0XV0OC8pBvUXTD6RSdAELt4NYWjSMW/Ru3KL3oN7Cuu1oUhqfFrisOu+idAIihnIAyD88Z6Jf9swu9eJRVL/UJBK9N9B6nQuoHQH35y062cUyhFREDqqqiBxylq0Zxkkts4tlyLKLZTg0Paaw35kpJC71RFMNXbjR6HcQJcINs0PEp70LEdej2h5Gtb0b1fYedA4DxyjDsIWzCCzrqsG8F0yafUZq0iCQsGLd9zZi6R566NeoFLCAHrMuDBnF+0N2dwyZQ47a5pDWw8tAJR/wcA45zFdy9pzaER2tfMUvQBt1ZR+G8VnkIG4ihgTEHU1tNWKH+09MYMyABClh3K+ohHE/+drMPUFqv5OCA+9OkCqSO0HqgoMTpIokT5CCWRdQxLqACOsAR2Ku+9PXLROFHwckmHsB6ekB8jUIkjUtD5GzB9rbXTDyfkoHt5JnkVz3cA/hdSd7CLFTTsCQukfwmKm/2ZmUumXZ9i9I7C/s4eo6Y4XlACEObjdEXUFWTKBzpnrgs977sIOmemW7JkNHohXM493jjDlwkL3fGSB10JTl9JFbbeGYpzHnvULkVGdAj6Jpwl/PrB6NGHm/m1k9iuZhXuNnwi8guer92DAuYB4toMijBQTbO6iovYPkazYHcSHmRdzvbLH0nXv0wuJUFwsZx5kLGYv/2gRPx6qX4EACOXphv1SBl/kRCcTq8gLnRy8cFxhRl4OjF6K9ynF9Rhy2XNHt4dl0Dko1p/1sOuVHL3R7ffTCTu+PXuhBSEYfvYAekUAsKsoevWCpasSOdMCPXiBh+EcvdAkevdBtzTO1kAgKz9i5JSfuuY70Mx2sM/TBmt+rapmBWQwGEcSyLtOHr9uEpFJW/eKrQZ7ADnsDO+oJbNgT1Cwf1Uf1UT1CxWpB8ZzJ/TPpPINmRe01k6/dovMMmrFjDYMSexLDYoQM87fEL34b2Cx/i+9x5j7BxeYi6eJj2La0C/w7HOAV/7DLtcAUeC3wAncpsJeVYDB/HuNsjsQk5IIAx0672JR9jLmRcPEfmeAPYacB9EjtlSEahVTW3SEGix8WO8SgS3YFx0zGNLHb7b4FRxhkujnCIIzaQkfbmIOy25gtB5KI75r1/HiDxSNYvV4P+bl4r0NAskLdNuZudiYjkOFkq2fGTNrGvPiyv415zqzexrxzGrYx90iRWyBKc3fuxuL/xt/GHEbXNcRjFcvJJOhOb/QUbqhBcAsz4lR7jcVPCTjVsHdOtZdfAIZnqhxu8QhJH3olcr+C683LcJTZi/hsp1s+A5ik4Vs+Q55t+UyZiVs+A/iWzzDvjDRx0yIkL2H+PBKrIQbXDKHT5QnZb2Meir74M/y9Wj1Otmr1okUnXdiCSy+2i+uCZ4c1JMPy2+NkitvjVss5h6B1ozOMHs9q1KML7Yj1aVKUlmmyKA3cXkRRexHyNXHIJieK4FnxaThXrvi010Hxaa674lORkEiSdTP1zsF9itrbZ3mNVcS0+Leubzgd9HItddDRWipSCt8reMQ9Vn763k9uuHs4eM//kbHOIhEJYwPDPqwCdVyOln3who8xsAT1Zh9cgzqO1aBGMSV7J0dNsiHU293jlE0s1MmHB5xiUtWovdNpgpjVqIv/gFRaTkOPhoz84Mzq0YiRnzCNPULaa1bUXjP5GpX4UrhmZ+k7t1Izf55sLoQIQ48xsyGFbzPBF2IpGiS0gys1QTPRi1RqHrAAMbqcv8h5peYxgRH1OqjUjPaqwL23x0o1GcmJTpJTECGQPDu+ptuJtXdIUXuHBNs7oqi9I4LtdSlqr8vSHnLHE3vJQWUoGZptZXmdntS3xN3iqjyGwB1xmB/xaO7ceRh4/wD7/Zt9cfKT58Myk+e4W67a3GKK/G2yrspSF097nE6jYNQE344NeIuiAW+Zob4hpKi9kIDpYEBu4Wpjl/gyvntlXA1tCGC/3xWQ18XVMroYmEmisk1Re9t8VWBBbvNVQU4VQgKiIllueoh8zR5xEu2FOUUuMc/FmjiuNvL/2HyhlSiEgOawM61mJuhdzUwQEGip/WQB4JAMr/eT1Xm/nyyMrqMhKhIWKdoC92gFrPvJgoJ6EsD3k5EwwH6yACR1suW1j1jUlFHglh+rU+2GCzaofA3/rp+Q2KXmAWYVa343P18TYh6O+YhFQljQl03T84iEhj7isvTzEYspZhRZ5fcjlYZhWmRAoQ1ZNxbWkijiCbkA2XXInYuOOMCcjOSP8pkcoHsW5nKiU0z0wuxeXSJ7xTLGdWfOdpkFhTcclMuGwCePwsb9hogxxUzrlNRfRq0NT7qCoHQFrNR6yYzF2lrbYwWY1xzQK3gNHa0fP5Dxg9OaW5mK8qDHNbd1QD25u5rbuZ9906fDneeL3sI2hk/yK9Ze33QPRAcHJM5UOMSdCTJq47oxahPpth6JjvA3FfQ66b3Lm0Uc9L95evvfaem/h8sUDsz0DFimcD7R64aS5F7P9Oq9n+mxlkR64ame/chOW2RDyicvsum2TvZ6LY3Yga21oeh0zwIEzPe6IelDDqrts0Zi50gIWNmk6w/AE6cVYA1gRkDyqPKFDowAdlT5gJdHlQ/ANBmx9A+9wwVeV2QdBzyCrSuSrQ56AzvsDeyoJ7BdnqBm+ag+qo/qo2qFyrmoAS1SuR+blMks+XWJTbm7sPbWKWpvHfmawrPasHqRdehtFHJb9gbEaBl9D6pjja30/SfcMpB0IHJOx9jl1AUXpuALAuiwu7y7jyEV2WA51G9W9stoHHEDSAeucyFUFMyrDBG+FKSAss5nSwfzXNGCFhN8Lroltl9CzSytgpKErjNYNjmx5Wk+chZLmLRrsrJMcOVhoO3ILdg6vtDdLcacGYpDGe/CZbxHYq23i5uR60FFxLJpjXWdcMFSgYva+YrzMFtxikUuzBvwTga6uCLQgzpACbnpsQg1drWUTJFQ2CX/w2SzTP6XCZxwAV6pgfI/bBSsvwW33yPsDzthf5jP/gGU/Z34YQAXJJxEp0v2d+IeIsr+rXz2dzpzAZ1GQe30eoBOJ+zvdMv+Lpz970RnFZ0zyjfsxc7kEjp5NowT2JtDuaIpava+9QVOVlEXSIyt21mFBvE9ypKoSh1CamUIbQcKFsNI2rnL86WnLjjpHFaUc+5C7Tl17RGmtN0uPbZHFQL1QP2uwwoBcdmWO3km/xjnkmwJ4ypymMPNEdE4aCLAZ23TLXiA7wqByJ/rMTi3DYZRWo2hVzrCU7cx+J5r1HHfHDMKTokE7iMeTt7G+JO3cQZRx/i8uMj4bNw6HaFc3UXUUvRaOuDAMjUitUtd/MQGazoSdD2LxW+BjTIfu+gVyU8NeZifGuFLzRieEZYTNoJYtNBwhKrL0gEpcyggNrF7hKOJyuk+KDwoYMCDqAxj1AvKloZzir+CRsEVwvxN69mnDvYha3v26QmJYAQ7j4KA7FEPGcSku1KRdFcKtrdZUXubydfgqmL36zoWWt2i8/03e3woibkCYWsmXmUz8bGfq+0NxdGLIH8GCUYCYBPjYoWrtEVMMArNI0gLPkYJZBzZTahd1jkhceSgWM0WfJK2oInqjglJ5G/oK/g0NKI40LsglIwzCv7DhP4r7Hj8IEZm2sUmYIFbIgkCDCeRthiJiDzGIVRMRPxfkuzl8NL+Lwn2f4mK/F8STas4bgiZjBL4ue1tLcfesf3Mhf6Xms+cbz15/MzpiubWc6c62qNvnjl9jSBvUoj4R3IINbIB1DImop4uAbVCqzDh3SqxpQKzelvJ1yBIlmVZTXaUVsPAhBo+7XKbyirQDruP+1Y5ifsof0r0DNSJkOA5hh+se29SzT0t65zNF8TDsK2EONj7Gi9HxBJk0QE6wjAEnmAYjx1gGJbtmQwViVYwbc5yxhrqlME4QScUxJxQCHNCtIdKEgghkvnTuUSGricbBS+bLvc1CDyFplECV3xT6Y9SyH7ZR5lMfCqByfctafRHqVhHiF6mwYX2qdY6+2Tye0izElxmd8JwdieZm9xhMDHZCe1SUAeaRhIZc75xqLomo843EXW+SXyBjnOYwY/jR76JqBMXj5ksYSliS5IwWxLEbEkIU8EwphagFUplhRspZORBm6BUozCN9hlp6iYyaaBGMI8KSMamKClGYdGUDBSCVxKlAMaYBz1fYGEh0aUNCcE2JIVrQ5g23Z39TUZtSAI4ZUasGbi+nIgugyVbvBvFn0SjMB9b8g+SNMFsW5KLicVqU/huByeW5vS8sBi0N4CAJmICmmQU1pnQJd6YnXjM7CRJuLYUZOKURPtq+jvGNCXV8+l5KjwVSVE0PWeocJKzMMDJ9DyVnJ6nhabDyiU5sXJJMdtCiVMqqrxBVPFDqNEII63Gk/oTMwri5jIODHgsEWssaYrodBDT6RCm03SckSoQZ6SB9ouUT8qCpRmFu0xavRUCn+skUE6nP5pL9ss+SsLHpUtg8lU1g/4oHesI0csMeLaTbp3tpJHfQzqc7N1sJ42rwwwmpjmhnYWJlBJmkER2rvppaESQgip/Kl+gk5DkaiMdRhCd5gYS2M1qyNUOgPoStSKsq7Ju9hmFx/knj7DOCuBPwXi3mPXihwwMYBe+haflwrd+fr0He8xOKvyt287QEn/WadtCG4UwYcOuzerl33rAogT/MLubgwJVZKdYkjxoFHYKSPKQoxLsYbx2iSGrNwfJz9HipSh7PKtemotI8zBfmlk1W8N8co3i9Yes6wtHLaTjnccO55NihUiLXqRGPKhyiZzkcBa8dVFJU4S0rIY3nsWmqZdhSRbQr9Ms/Ro2Cv/UxL+CF+sNsbfoFV43pfEjOMAgqk9hVJ165cc+xLEt0bG/x+z6+2BtHXSprenutHXMmbZyag2Zh6NYiw1lnOGQgA9Ak0o2w8t2BU9heaWwhT6cXffO3JuQgTpCy/GwxWLKuKNhzH6IHQ8zzDpgjrAKsADtOPkw1R2BD8eY6WJSuALsgvHCj5r8/aikOojwdhwXwGGLojA6OG4Uflyguh+0R2MWx8g2SJ8kbvly08BZAP8vBIKpcWfFzbyS+DFcLy7Sj8csRhg+ymvcevQY+d15+ugxEnWYd6rZG6MCR4SGD7whDQFa8BXTIf8941yvi3LOJ06Gza2WdpzvfUCHDQOPm6timyX1MkYyA0Y31UYe/8tEiIPGcavMjnxFys4PgE7GEkENE7EgZ/LB2kpd+G8iO3Jczk4C33Wzl5pFHYHN1CO4Vwjg3nOFuo2pchvcFq2TmdISCLtdhcP3Ad7hhwLeYcQRfzhzx2jnUOcwOl1TbUyYRTYKjTrzpawgZxQX5zE8/LVMtUfkpE4k/h0yRbqQ5tWopR+odxhxOqGBT5C8iMd9YxY3xlCMi0bh7wXivkvO5mmPMT67RA6LItdF8mu4O5AdGJ/qUxNrsJeMJUERJzHqclKciejVJb5esanGJfZlxmePWWhDK85lC+lxxbrEmaWNyRgKMcUzr6TL+a2MTxVI2o5AEjTM8SQjxpJ5Ap5k1JEn4ZhGVlbWygGOdZoWiZ+2jcoBfJ/yxO5sVODHMNE0o9WcH0stkQisrHBS9wFXmftBqd4OCWaTWTEO0WqVskarLO/dshR2FRrCVSlLe1VZ3gMTqkqGZxkAP0O/ZIO8MR1A3XHUlN5hom/i5eddCH2vXP5wss/N3q1xhWdi4M2MrMcs/JDJmg/bPTyDjiMe0lHgJM7hJx2dVTLKzdJKLxb2WnrgXQI/57NSoxp0L1QDrkKWoVkWsvDOVmHGLENCQfgIlplrgsUCsu0EF5mrr6PGknsFAuUxZ2LHWwEcweVqHJfKYe9Mlp5iN4rHD07FDk8IjxChB7XSYUmAxjhQXkm/ak0yoxey2Oy4BRe2ygcfbHv9DSbMgzz3Y/mQ6OtJmKZU0gfCmPDCzMCrQ/woLwj77bDNEO/fCGA6upBT/KwDZJ8wQ8bK9DrTqOdnzESbgO+PGVZ1f8woPr2g7Quu0WLB3hhugnDYQW9gh9DZQ6VU4IodgV+JRzZEm5uVtbnZ8h5yT5KCOaGFaPamRpU2NUqOEPSESpoai01m7Q2NK22IcKmr4VLc2JT6PbDDhsKu/lhlNTOdv/R/muj/FV93GocbZ+3gJL9dzW57yQcYtvaSuk2cUSwBoj4pv3yIE3XYWPp3JvozOFEH8CUNxlrfJYugUo8fsyDJLBk8hkmqdZ3FTtXHMOd52fMdcNEmYOf5mCrnyVovucgPpR/HSS2xD+7m5RD5r8dDuEFm5mdGLb3AneQl3GKtksqTPBaL4dHE3TAeY48A4dvIDA7fRrwM30bUhG/DuodvwyLhm2x63TpFw9rcrKxNaznWLUvp++Gb9+HbNzwI346Z6N/Gc1Sy4dsIP3z73kwI334gv8yEE3XEWFpvov9vXuLPD9+s//nhm5vwzbo5YprCtxHJ8M3WaST8iloYAYsgFduNycnHEgfiOXYrYjvOKer0wMflWi4kRPXZQ2cOtBw/eeFd7Bj8LkCgxq3xpHI+D8xgPg94yeeBW8jnYVk+Y+pepizqLZueqLdMIMJYmim/2NmPFrKMGkuXmOgLaAr34xEGoaq93l0CGKfjvup+vFQCnuX2Oy2V6DdLJZ5GBnWw434r+GkLBGwsqA9j07JGuc195lcWKNYOn6XLTdaflhf9MXKQbOFfOaM23o1aAkLq8TjDMjHUbdylui1B1O0iX90uOYtuOQX3LH2yTFFGBRTZtIQiEn8Jd49OxzGG8xXeOQBe+TTKEfMxY2m1yN6Bix7KzZgzuRlzT+9RjtyMO64PGcVqpBsZ7twSy5geffpm9XAe5jIcTZAtMYTtsrF0rzm4t0nNZQWMxBOMzx63ukD7gMl9Ik9IAQvY+CuMz57A+0N29wqyw/kJ2w7nyxYMz5QYq0u9zFdiFl8vO6Pj4xzjf8VCc3cJjMvuEhhRreKL/IhzczEikGK85EyC+W6Xs9ENNUDDuAEaxdV1DNce2Hw9wUwjE98y08hPGEtPM2a9VxSmka/AisM+neMymh9+3FhqbvBc+hCMDVlzLnq7SNxwybvDTqM845octk9wbbovc0yO3EEMl/lTpUv4fljrfkfmFtGlveidzsMWArnL6F7krUFNSeUH4G2ksbQGvLv4MUh0L6Gi+5ix9CkTfdxLGzWO26jHpDzl41iu6DFGAMD4lJWxfML7hZMnkIzl46oylk/gKyBy0YWjhZMnLAsnV0LTYxUfc2YViZUTWrye4Gj3MMc6jHKsyxjW+LhFu2K2Q8bECsZSF4k1cFTxh3HFH8UVnxG7PCEUu1yBLZ5Femmjd8VY+iGTdn8NNnDVWYh+jfHZVUv3qAGT7vKaFLCAUl9nfHYN7w/Z3evI1Ouabep1xYIBavxlD6deV/gaz+LrFWd0tPKVVtfrFpq7sxVXOJHG4xxz8YSAyKPHUjQyIhSy+7EgZfrKZz3K1PyDObhvaZ2pGXYf7vuZmoenLVMjUymsLlPzLakVY8HoYliglt+bE4lcZmoGNMvU/Fi7TM1rpuS97EGm5hd+pkanTM3v0EzNACf+8SJTU5QnkKkpCqjP1BQVmOghL22Un6mZasLP1LypMzUDHOugPlMTtR2eZmregyv+gH6ZmqLlJu2q/EyNn6mZrkyNjK1QlqlBRF5FpqYoIFDFOAl5hHjYh1QA0sWPY/w48aJg8eMYe1NTUS1R/AhuiWs0h13nqnSMfcjumFHUYjZQz7sLAK1sG8KO85+cU7E/vQegj3kEX9FuvOkRBvnIN6dgmrH37iFec3TpAbMUbRCPUEcto4CbHbM1O8ppVuIgs+H+J+84Y9sHQLBhYuZO7ZMm9fLi5D5p6iUyOzHOvfHBTtiLlhFglLG6iEuWgYi3N2ppD895j3OOOhuXqinsg+1fnzXMmSz/zuddcIHdqwGL7xhnVBcRs8s6aQ8clZXUMfPGOR0WHtWwbVRDlt9Qr4doq/82IXcxgucH+kg85q7PolMCZe8jAjcK3Avgn3V2DvRafpDCO1RxiHuoot1MkMwa4ZqJEZjVvchnr++LIG29mLoM2YzLiGXU4r0ctrSHewmpWwJEjYdZRpaThG8C6kNGNWAbVb/lN7zfBVMzOJbDLy4LcJRs0CgaEFCyQYHltXsB/GFnN2Su4SsZ74bMfu6Rw3YlI1k1yFWyQZjRvai2gErWj3zWb1OyQUHltPdywNIerWR9ljZgcXW7PSv7OufCRVAY8QNH0av3BllC2m8UvVvgZrN+QAkC6NbCKPh7BDSAMSiB6waGmKQgeoYasSFaAUih6p9UADo9O/TGk2iC4DX8PywYsdktULKZ53kVfcCk6YdYHXS58XkQS04Py+7/lU9ODyPJ6UFVyelhjh653VpfwNn4TIjiXUAQYL2EiX/EfdGHpLWXtIdvBRT4oyb+R7w0iF2Seu7aQQ5I73Qmvg7ihUB98hE7/+aWok+JXInr9latX2p5uH+/jGiSh/uDQid+IynrQr+bQ0bR57D13aCFPnggIjc4weOp+wXMRh+q1tLGhhjTbsDYGALRwoCjaGGQSSqyc6g5GJyugw+wE9cH+frojfEMcJJfnIMPBjGX0Ge6hHuh7vU6kss+QC6Jnu1kiWWfUfQdAbHsdySWA8y1UaJvlNj1CfuwICyV/S6lch4ilQN8qRx0tq+eG/Hjyck+3AwPIFLZawrlVniFCJwimT/3so+4KHpFQL4uOvOs7KMYiM6hqyaX8ILCYbxYZ9RJpZD5+y1ArdBvRcIgt5W1te4KOi47WyZnF+SS1KElXKzIchxfVJVavmQzG7igc1mc8IZE3uKz1OjE5h/mul/kJ3hSelAm4g1YQMCYVzR5yT4ZZ8xYliZyDYbAuu8e9oRjWYazG3B6+YLOuwBnlHd6KG+50qt7l7a/Wa6KdHz/jZhimccVRL6Gr9n1ycSg1muNna29WVNNbMFfJqBYQwIz+e3sqeGyFc5u8xZQLN5t3pz7NfED9szAnaFYwy4Va6eOt3krXaeTvM078nlYc/iRaB07tbysyplkikTv3MP0npK8Z56U637cIwy6qovaCfjfWpFI1O2Va/Nn5JVroxyXMyyVWhA4RZBTUDEqYNX3oJGo9e5kXK+H5ZyWiF6bu8YiL6KpJsRhDuIOc8BhsjNgIQLboR0WcJgDkKYNchzmgLHsLmfr6AIOk7dMMMi9IARbZkcuLR90aRcWTMvtseyDVFGHOWIhHa54Xt4eG/kTdxS/cJS9mBlnlevJv86JNWKK9NQHxrJT1BqnuRAa61LlBrhL3/z8r7/20q6KU/T+xSkWPnOgtb3j3Gm3DeX+ZeuXt337J9/2vKHxilDm43ftbfS8oS8n/PTVL/79iSueN/S/Ept3Bj/+WIHnDf3Rq3dsHMwu+oXnDb3rc2sbf7H/Z/n8hiat4uSf42MGkKlCCc/Q1fHxMWNkV6AEY5kZBi8bsZrYcKypqTeuA29IH98NXMWUZP8gLvaBpeXk2AuWv6dA5nryz6kM8phYSRR5Uo1l12wMSIx9NmWA7W0nsttOtg8uGXISU4D2D1JiH0xx5BIkiGHJ+o4pcWNLFciXsJX+iQBfkjiMT2bwxcRKoPiSbCz7E0gxEu18SYq9wmw70T64RA5fKClNovnyXxTZiY9tXHNb2tHlfZ4bpLTPf3Lf9357drnnDY1+/7V/e6wn5+eeN1Tzvs7x1I0vfNTzhp5P+cr2v3pf4r2eN1Rd/Hh27j8+lOp5Q+FQ7nsKX3jbHm5D/x+s2wwSfOYFAA==","debug_symbols":"tb3dji27caX7Lrr2xYwg44d+lUbDULvVDQGC3FDbBzgw/O5nMpgRg6vWKVZWzblvVN9eqoqRSXJEMpmRzP/80//8y//4j//9L3/9+//6t//7p3/+b//5p//xj7/+7W9//d//8rd/+9c///tf/+3vz3/9zz895v+0/qd/bv/0pyZ/+md5/tD1w9YPXz9G/OiP9YPWD14/2vrR148Vpa8ofUXpK0pfUWRFkRVFVhRZUWRFkRVFVhRZUWRFkRVFVxRdUXRF0RVFVxRdUXRF0RVFVxRdUWxFsRXFVhRbUWxFsRXFVhRbUWxFsRXFVxRfUXxF8RXFVxRfUXxF8RXFVxRfUcaKMlaUsaKMFWWsKGNFGSvKWFHGijJWFHo8rp90/eTrZ7t+9uunXD/1+mnXT79+XvHoikdXPHrGs/mzXT/79VOun8949JhgCZ7wDEnPoUb8jEnzl5kSOKEl9ARJeEZmmmAJnjAuaM/IzBMogRNm5HkGc8AvkIQZ2SdYgieMC+bgX0AJnNASeoIkZOSekXtG7hl5GqLN9pmWWMAJLaEnSIImWIInjAs0I2tG1oysGVkzsmZkzciakTUja0a2jGwZ2TKyZWTLyJaRp4na7ItpowWeMC6YZlpACZzQEnqCJGRkz8iekT0jj4w8MvLIyCMjj4w8MvLIyCMjj4w8rsj8eCRQAie0hJ4gCZpgCZ6QkSkjU0amjEwZmTIyZWTKyJSRKSNTRuaMzBmZMzJnZM7InJE5I3NG5ozMGbll5JaRW0ZuGbll5JaRW0ZuGbll5JaRe0buGXl6sMmEltATJEETLMETxgXhwQBKyMiSkSUjhwd9giZYwjNybxPGBdODCyiBE1pCT5AETbCEjKwZ2TKyXRmJjRNaQk+QBE2wBE+4MhL7IyEje0b2jDw92HWCJGiCJXjCuGB6cAElcEJLyMgjI4+MPDLy9GC3CWNBmx5cQAmc0BJ6giRogiV4QkamjByXwD6BE1pCT5AETbAETxgXTA8uyMickTkjc0bmjMwZmTMyZ2TOyC0jt4zcMnLLyC0jt4zcMnLLyC0jt4zcM3LPyD0j94zcM3LPyD0j94zcM3LPyJKRJSNLRpaMLBlZMrJkZMnIkpElI2tG1oysGVkzsmZkzciakTUja0bWjGwZ2TKyZWTLyJaRLSNbRraMbBnZMrJnZM/InpE9I3tG9ozsGdkzsmdkz8gjI4+MPDLyyMgjI4+MPDLyyMgjI48rcn88EiiBE1pCT5AETbAET8jIlJHTgz092NODPT3Y04M9PdjTgz092NODPT3Y04M9PdjTgz092NODPT3Y04M9PdjTgz092NODPT3Y04M9PdjTgz092NODPT3Y04M9PdjTgz092NODPT3Y04M9PdjTgz092NODPT3Y04M9PdjTgz092NODPT3Y04M9PdjTgz092NODPT3Y04M9PdjTgz092NODPT3Y04M9PdjTgz092NODPT3Y04M9PdjTgz092NODPT3Y04M9PdjTgz092NODPT3Y04M9PdjTgz092NODPT3Y04M9PdjTgz092NODPT3Y04OSHpT0oKQHJT0o6UFJD0p6UNKDkh6U9KCkByU9KOlBSQ9KelDSg5IelPSgpAclPSjpQUkPSnpQ0oOSHpT0oKQHJT0o6UFJD0p6UNKDkh6U9KCkByU9KOlBSQ9KelDSg5IelPSgpAclPSjpQUkPSnpQ0oOSHpT0oKQHJT0o6UFJD0p6UNKDkh6U9KCkByU9KOlBSQ9KelDSg5IelPSgpAclPSjpQUkPSnpQ0oOSHpT0oKQHJT0o6UFJD0p6UNKDkh6U9KCkByU9KOlBSQ9KelDSg5IelPSgpAclPSjpQUkPSnpQ0oOSHpT0oKQHJT2o6UFND2p6UNODmh7U9KCmBzU9qOlBTQ9qelDTg5oe1PSgpgc1PajpQU0PanpQ04OaHtT0oKYHNT2o6UFND2p6UNODmh7U9KCmBzU9qOlBTQ9qelDTg5oe1PSgpgc1PajpQU0PanpQ04OaHtT0oKYHNT2o6UFND2p6UNODmh7U9KCmBzU9qOlBTQ9qelDTg5oe1PSgpgc1PajpQU0PanpQ04OaHtT0oKYHNT2o6UFND2p6UNODmh7U9KCmBzU9qOlBTQ9qelDTg5oe1PSgpgc1PajpQU0PanpQ04OaHtT0oKYHNT2o6UFND2p6UNODlh609KClBy09aOlBSw9aetDSg5YetPSgpQctPWjpQUsPWnrQ0oOWHrT0oKUHLT1o6UFLD1p60NKDlh609KClBy09aOlBSw9aetDSg5YetPSgpQctPWjpQUsPWnrQ0oOWHrT0oKUHLT1o6UFLD1p60NKDlh609KClBy09aOlBSw9aetDSg5YetPSgpQctPWjpQUsPWnrQ0oOWHrT0oKUHLT1o6UFLD1p60NKDlh609KClBy09aOlBSw9aetDSg5YetPSgpQctPWjpQUsPWnrQ0oOWHrT0oKUHLT1o6UFLD1p60NKDlh609KClBy096OlBTw96etDTg54e9PSgpwc9PejpQU8PenrQ04OeHvT0oKcHPT3o6UFPD3p60NODnh709KCnBz096OlBTw96eNAmWIInPCMrzQdCjwRK4ISW0BMkQRMswRMycs/IPSP3jNwzcs/IPSP3jNwzcs/IPSNLRpaMLBlZMrJkZMnIkpElI0tGloysGVkzsmZkzciakTUja0bWjKwZWTOyZWTLyJaRLSNbRraMbBnZMrJlZMvInpE9I3tG9ozsGdkzsmdkz8iekT0jj4w8MvLIyCMjj4w8MvLIyCMjj4w8rsjj8UigBE5oCT1BEjTBEjwhI1NGpoxMGZkyMmVkysiUkSkjU0amjMwZmTMyZ2TOyJyROSNzRuaMzBk5PTjSgyM9ONKDIz040oMjPTjSgyM9ONKDIz040oMjPTjSgyM9ONKDIz040oMjPTjSgyM9ONKDIz040oMjPTjSgyM9ONKDIz040oMjPTjSgyM9ONKDIz040oMjPTjSgyM9ONKDIz040oMjPTjSgyM9ONKDIz040oMjPTjSgyM9ONKDIz040oMjPTjSgyM9ONKDIz040oMjPTjSgyM9ONKDIz040oMjPTjSgyM9ONKDIz34fCb/KKIiLmpFvUiKtMiKvKg0qDSoNKg0qDSoNKg0qDSoNKg0qDS4NLg0uDS4NLg0uDS4NLg0uDS4NFpptNJopdFKo5VGK41WGq00Wmm00uil0Uujl0YvjV4avTR6afTS6KXRS0NKQ0pDSkNKQ0pDSkNKQ0pDSkNKQ0tDS0NLQ0tDS0NLQ0tDS0NLQ0vDSsNKw0rDSsNKw0rDSsNKw0rDSsNLw0vDS8NLw0vDS8NLw0vDS8NLY5TGKI1RGqM0RmmM0hilMUpjlEb5nMrnVD6n8jmVz6l8TuVzKp9T+ZzK51Q+p/I5lc+pfE7lcyqfU/mcyudUPqfyOZXPqXxO5XMqn1P5nMrnVD6n8jmVz6l8TuVzKp9T+ZzK51Q+p/I5lc+pfE7lcyqfU/mcyudUPqfyOZXPqXxO5XMqn1P5nMrnVD6n8jmVz6l8TuVzKp9T+ZzK51Q+p/I5lc+pfE7lcyqfU/mcyudUPqfyOZXPqXxO5XMqn1P5nMrnVD6n8jmVz6l8TuVzKp9T+ZzK51Q+p/I5lc+pfE7lcyqfU/mcyudUPqfyOZXPqXxO5XMqn1P5nMrnVD6n8jmVz7l8zuVzLp9z+ZzL51w+5/I5l8+5fM7lcy6fc/mcy+dcPufyOZfPuXzO5XMun3P5nMvnXD7n8jmXz7l8zuVzLp9z+ZzL51w+5/I5l8+5fM7lcy6fc/mcy+dcPufyOZfPuXzO5XMun3P5nMvnXD7n8jmXz7l8zuVzLp9z+ZzL51w+5/I5l8+5fM7lcy6fc/mcy+dcPufyOZfPuXzO5XMun3P5nMvnXD7n8jmXz7l8zuVzLp9z+ZzL51w+5/I5l8+5fM7lcy6fc/mcy+dcPufyOZfPuXzO5XMun3P5nMvnXD7n8jmXz7l8zuVzLp9z+byVz1v5vJXPW/m8lc9b+byVz1v5vJXPW/m8lc9b+byVz1v5vJXPW/m8lc9b+byVz1v5vJXPW/m8lc9b+byVz1v5vJXPW/m8lc9b+byVz1v5vJXPW/m8lc9b+byVz1v5vJXPW/m8lc9b+TzKj3TV9baiXjQ1LEiLrMiLRlL4fBEVcVEr6kWlIaUhpSGlIaWhpaGloaWhpaGloaWhpaGloaWhpWGlYaVhpWGlYaVhpWGlYaVhpWGl4aXhpeGl4aXhpeGl4aXhpeGl4aUxSmOUxiiNURqjNEZpjNIYpTFKY6RGFC5dREVc1Ip6kRRpkRV5UWlQaVBpUGlQaVBpUGlQaVBpUGlQaXBpcGlwaXBpcGlwaXBpcGlwaXBptNJopdFKo5VGK41WGq00Wmm00mil0Uujl0YvjV4avTTK57183svnvXzey+dR6qQjiIq4qBX1IinSIivyopGkpaGloaWhpaGloaWhpaGloaWhpWGlYaVhpWGlYaVhpWGlYaVhpWGl4aXhpeGl4aXhpeGl4aXhpeGl4aUxSmOUxiiNURqjNEZpjNIYpTFKY6RGFEddREVc1Ip6kRRpkRV5UWlQaVBpUGlQaVBpUGlQaVBpUGlQaXBpcGlwaXBpcGlwaXBpcGlwaXBptNJopdFKo5VGK41WGq00Wmm00mil0Uujl0YvjV4avTR6afTS6KXRS6OXRvlcyudSPpfyuZTPpXwu5XMpn0v5XMrnUj6X8rmUz6V8LuVzKZ9L+VzK51I+l/K5lM+lfC7lcymfS/lcyudSPpfyeZRaWQ8aSdPnF1ERF7WiXiRFWmRFpeGlMUpjlMYojVEaozRGaYzSGKUxSmOkRhRgXURFXPTU8PV+VC+SIi2yIi8aSdPnF1ERF5XG9LlTkBRpkRV50UiaPr+IirioFZUGlwaXBpfG9Llb0EiaPr9oangQF7WiqTGCpEiLnhojNKbPLxpJ0+cXUREXtaJeJEVaVBq9NHppTJ+PFkRFXNSKepEUaZEVedFI0tLQ0tDS0NLQ0tDS0NLQ0tDS0NKw0rDSsNKw0rDSsNKw0rDSsNKw0vDS8NLw0vDS8NKYPh/hnunzi6xoakjQSJo+v2hqxBiaPr+oFfUiKdIiK/KicVEUeV1ERVzUinqRFGmRFXlRaVBpUGlQaVBpUGlQaVBpUGlQaVBpcGlwaXBpcGlwaXBpcGlwaXBpcGm00mil0UqjlUYrjVYarTRaabTSaKXRS6OXRi+NXhq9NHpp9NLopdFLo5eGlIaUhpSGlIaUhpSGlIaUhpSGlIaWhpaGloaWhpaGloaWhpaGloaWhpWGlYaVhpWGlYaVhpWGlYaVhpWGl4aXhpeGl4aXhpeGl4aXhpeGl8YojfK5lc+tfG7lcyufW/ncyudWPrfyuZfPvXzu5XMvn3v53MvnXj738rmXz7187uVzL597+dzL514+9/K5l8+9fO7lcy+fe/ncy+dePvfyuZfPvXzu5XMvn3v53MvnXj738rmXz7187uVzL597+dzL514+9/K5l8+9fO7lcy+fe/ncy+dePvfyuZfPvXzu5XMvn3v53MvnXj738rmXz7187uVzL597+Tyq0J4PbQMZ2IAdKEAFGtCBo3AaPhFqBjWDWpheg6RIi6zIi0ZSmH4RFXFRKyoNLw0vDS8NLw0vjVEaozRGaYzSGKUxSmOUxiiNURojNaJy7SIq4qJW1IukSIusyItKg0qDSoNKg0qDSoNKg0qDSoNKg0qDS4NLg0uDS4NLg0uDS4NLg0uDS6OVRiuNVhqtNFpptNJopdFKo5VGK41eGr00emn00uil0Uujl0YvjV4avTSkNKQ0pDSkNKQ0pDSkNKQ0pDSkNLQ0tDS0NLQ0tDS0NLQ0lt1boANH4bJ7DyQgAxuwAwWoQAM6cBQ61BxqDjWHmkPNoeZQc6g51BxqA2oDagNqA2oDagNqA2oDagNqI9U4qucSCcjABuxAASrQgA6EGkGNoEZQI6gR1AhqBDWCGkGNoMZQY6gx1BhqDDWGGkONocZQY6i1UNNAAjIw1EZgBwpQgQZ04CjsDyABGQi1DrUOtQ61DrUOtQ41gZpATaAmUBOoCdQEagI1gZpATaGmUFOoKdQUago1hZpCTaGmUDOoGdQMagY1g5pBzaBmUDOoGdQcag41h5pDzaHmUHOoOdQcag61AbUBtQG1AbUBtQG1AbUBtQG1UWr0eAAJyMAG7EABKtCADoQaQY2gRlAjqBHUCGoENYIaQY2gxlBjqDHUGGoMNYYaQ42hxlBjqDWoNag1qCGXEHIJIZcQcgkhlxByCSGXEHIJIZcQcgkhlxByCSGXEHIJIZcQcgkhlxByCSGXEHIJIZcQcgkhlxByCSGXEHIJIZcQcgkhlxByCSGXEHIJIZcQcgkhlxByCSGXEHIJIZcQcgkhlxByCSGXEHIJIZcQcgkhlxByCSGXEHIJIZcQcgkhlxByCSGXEHIJIZcQcgkhlxByCSGXEHIJIZcQcgkhlxByCSGXMHIJI5cwcgkjlzByCSOXMHIJI5cwcgkjlzByCSOXMHIJI5cwcgkjlzByCSOXMHIJI5cwcgkjlzByCSOXMHIJI5cwcgkjlzByCSOXMHIJI5cwcgkjlzByCSOXMHIJI5cwcgkjlzByCSOXMHIJI5cwcgkjlzByCSOXMHIJI5cwcgkjlzByCSOXMHIJI5cwcgkjlzByCSOXMHIJI5cwcgkjlzByCSOXMHIJI5cwcgkjlzByCSOXMHIJI5cwcgkjlzByCSOXMHIJI5cwcgkjlzByCSOXMHIJI5cwcgkjlzByCSOXMHIJI5cwcgkjlzByCSOXMHIJI5dEneFzChA4EqPSMJGADGzADhSgAg3oQKgR1AhqBDWCGkGNoEZQI6gR1AhqDDWGGkMtcsnciZOjAjFRgKGmgQZ04CiMXHIhARnYgB0oQKg1qDWoNah1qHWodah1qHWodah1qHWodah1qAnUBGoCNYGaQE2gJlATqAnUBGoKNYWaQk2hplBTqCnUFGoKNYWaQc2gZlAzqBnUDGoGNYOaQc2g5lBzqDnUHGoONYeaQ82h5lBzqA2oDagNqA2oDagNqA2oDagNqI1S648HMNQ8kIENONXm1rkcJY2JCjSgA0dh5JILCcjABoQaQY2gRlAjqBHUGGoMNYYaQ42hxlBjqDHUGGoMtQa1BrUGtQa1BrUGtQa1BrUGtQa1DrUOtQ61DrUOtQ61DrUOtQ61DjWBmkBNoCZQE6gJ1ARqAjWBmkBNoaZQU6gp1BRqCjWFmkJNoaZQM6gZ1AxqBjWDmkHNoGZQM6gZ1BxqDjWHmkPNoeZQc6g51BxqDrUBtQG1AbUBtQG1AbUBtQG1AbVRalExmUhABjZgBwpQgQZ0INSQSwS5RJBLBLlEkEsEuUSQSwS5RJBLBLlEkEsEuUSQSwS5RJBLBLlEkEsEuUSQSwS5RJBLBLlEkEsEuUSQSwS5RJBLBLlEkEsEuUSQSwS5RJBLBLlEkEsEuUSQSwS5RJBLBLlEkEsEuUSQSwS5RJBLBLlEkEsEuUSQSwS5RJBLBLlEkEsEuUSQSwS5RJBLBLlEkEsEuUSQSwS5RJBLBLlEkEsEuUSQSwS5RJBLBLlEkEsEuUSQSwS5RJBLBLlEkEsEuUSQSwS5RJBLBLlEkEsEuUSQSwS5RJBLBLlEkEsEuUSRSxS5RJFLFLlEkUsUuUSRSxS5RJFLFLlEkUsUuUSRSxS5RJFLFLlEkUsUuUSRSxS5RJFLFLlEkUsUuUSRSxS5RJFLFLlEkUsUuUSRSxS5RJFLFLlEkUsUuUSRSxS5RJFLFLlEkUsUuUSRSxS5RJFLFLlEkUsUuUSRSxS5RJFLFLlEkUsUuUSRSxS5RJFLFLlEkUsUuUSRSxS5RJFLFLlEkUsUuUSRSxS5RJFLFLlEkUsUuUSRSxS5RJFLFLlEkUsUuUSRSxS5RJFLFLlEkUsUuUSRSxS5RJFLFLlEkUsUuUSRSxS5RJFLFLlEkUsUuUSRS3Tlkh7owJFoK5csJCADG7ADBahAAzoQagQ1ghpBjaBGUCOoEdQIagQ1gtrKJR5IQAY2YAcKUIEGdOAobFBrUGtQa1BrUGtQa1BrUGtQW7lkbtdvK5csJCADG7ADBahAAzoQagI1gZpATaAmUBOoCdQEagI1gZpCTaGmUFOoKdQUago1hZpCTaFmUDOoGdQMagY1g5pBzaBmUDOoOdQcag41h5pDzaHmUHOoOdQcagNqA2oDagNqA2oDagNqA2oDaqPU/PEAEpCBDdiBAlSgAR0INYIaQY2gRlAjqBHUCGoENYIaQY2hxlBjqDHUGGoMNYYaQ42hxlBrUGtQa1BrUGtQa1BrUGtQa1BDLnHkEkcuceQSRy5x5BJHLnHkEkcuceQSRy5x5BJHLnHkEkcuceQSRy5x5BJHLnHkEkcuceQSRy5x5BJHLnHkEkcuceQSRy5x5BJHLnHkEkcuceQSRy5x5BJHLnHkEkcuceQSRy5x5BJHLnHkEkcuceQSRy5x5BJHLnHkEkcuceQSRy5x5BJHLnHkEkcuceQSRy5x5BJHLhnIJQO5ZCCXDOSSgVwykEsGcslALhnIJQO5ZCCXDOSSgVwykEsGcslALhnIJQO5ZKxcMgJH4colCwnIwAbsQAEq0IBQY6g1qDWoNag1qDWoNag1qDWoNag1qHWodah1qHWodah1qHWodah1qHWoCdQEagI1gZpATaAmUBOoCdQEago1hZpCTaGmUFOoKdQUago1hZpBzaBmUDOoGdQMagY1g5pBLXJJmzcKq+71QgJOtdYCG7ADBahAAzpwFEYuuZCAUBtQG1AbUBtQG1AbUBup1lbd64UEZGADdqAAFWhAB0KNoEZQI6gR1AhqBDWCGkGNoEZQY6gx1BhqDDWGGkONocZQY6gx1BrUGtQa1BrUGtQa1BrUGtQa1BrUOtQ61DrUOtQ61DrUOtQ61DrUOtQEagI1gZpATaAmUBOoCdQEagI1hZpCTaGmUFOoKdQUago1hZpCzaBmUDOoGdQMagY1g5pBzaBmUHOoOdQcag41h5pDzaHmUHOoOdQG1AbUBtQG1AbUBtQG1AbUBtSQSwi5hJBLCLmEkEsIuYSQSwi5hJBLCLmEkEsIuYSQSwi5hJBLCLmEkEsIuYSQSwi5hJBLCLmEkEsIuYSQSwi5hJBLCLmEkEsIuYSQSwi5hJBLCLmEkEsIuYSQSwi5hJBLCLmEkEsIuYSQSwi5hJBLCLmEkEsIuYSQSwi5hJBLCLmEkEsIuYSQSwi5hJBLCLmEkEsIuYSQSwi5hJBLCLmEkEsIuYSQSwi5hJBLCLmEkEsIuYSQSwi5hJBLCLmEkEsIuYSQSwi5hJBLCLmEkEsIuYSQSwi5hJBLCLmEkEsIuYSQSwi5hJBLCLmEkEsIuYSQSwi5hJBLCLmEkEsYuYSRSxi5hJFLGLmEkUsYuYSRSxi5hJFLGLmEkUsYuYSRSxi5hJFLGLmEkUsYuYSRSxi5hJFLGLmEkUsYuYSRSxi5hJFLGLmEkUsYuYSRSxi5hJFLGLmEkUsYuYSRSxi5hJFLGLmEkUsYuYSRSxi5hJFLGLmEkUsYuYSRSxi5ZNW9Ng1kYAN2oAAVaEAHjsKVSxZCTaG2cgkHdqAAFWhAB47ClUsWEpCBUDOoGdQMagY1g5pBzaHmUHOoOdQcag41h5pDzaHmUBtQG1AbUBtQG1AbUBtQG1AbUBultupeLyQgAxuwAwWoQAM6EGoENYIaQY2gRlAjqK1c4oEGdOAoXLlkIQEZ2IAdKECoMdQYapFL4uPEq+71QgJOtR6/G7nkwg4MtRGoQAM6cBSuXLKQgAxswA6EWodah1qHWoeaQE2gJlATqAnUBGoCNYGaQE2gplBTqCnUFGoKNYWaQk2hplBTqBnUDGoGNYOaQc2gZlAzqBnUDGoONYeaQ82h5lBzqDnUHGoONYfagNqA2oDagNqA2oDagNqA2oDaKLVV93ohARnYgB0oQAUa0IFQI6gR1AhqBDWCGkGNoEZQI6gR1BhqDDWGGkONocZQW2uvGmhAB47Ctfa6kIAMbMAOFCDUGtQa1BrUOtQ61DrUOtQ61DrUOtQ61DrUOtQEagI1gZpATaAmUBOoCdQEagI1hZpCTaGmUFOoKdQUago1hZpCzaBmUDOoGdQMagY1g5pBzaBmUHOoOdQcag41h5pDzaHmUHOoOdQG1AbUBtQG1AbUBtQG1AbUBtRGqV11rwsJyMAG7EABKtCADoQaQY2gRlAjqBHUCGoEtcglQoEOHIWRS4QDCcjABuxAASrQgA4chQ1qDWoNag1qDWoNag1qDWoNag1qHWodah1qHWodah1qHWodah1qHWoCNYGaQE2gJlATqAnUBGoCNYGaQk2hplBTqCnUFGoKNYWaQk2hZlAzqBnUDGoGNYOaQc2gZlAzqDnUHGoONYeaQ82h5lBzqDnUHGoDagNqA2oDagNqA2oDagNqA2qj1Fbd64UEZGADdqAAFWhAB0KNoEZQI6hFLpmfpmyr7vVCAU41fQQa0IGjMHLJhQRkYAN2oAChxlBjqEUu0Tj0yCUXEpCBDdiBAlSgAR0ItQ61DrUOtQ61DrUOtQ61DrUOtQ41gZpATaAmUBOoCdQEagI1gZpATaGmUFOoKdQUago1hZpCTaGmUDOoGdQMagY1g5pBzaBmUDOoGdQcag41h5pDzaHmUHOoOdQcag61AbUBtQG1AbUBtQG1AbUBtQG1UWqr7vVCAjKwATtQgAo0oAOhRlAjqBHUCGqRS+bW0m3VvV6owKlmj0AHjsLIJeaBBGRgA3agABVoQAeOwga1BrUGtcgl3gM7UIBTbW4+3Fbd64UOnGojWidyyYVUuC6Ak2LMzq1226qvHKEQY/bCBuxAASrQCmN0zh3L2qqkvJCBDdiBAlSgAR04Elcl5YUEZGADdqAAFWhAB0KNoEZQI6gR1AhqBDWCGkGNoEZQY6gx1BhqDDWGGkONocZQY6gx1BrUGtQa1BrUGtQa1BrUGtQa1BrUOtQ61DrU4ko3RmAHClCBBnTgU43nzngtKikTCcjANrEHdqBMlEAFGtCBo1AfQAKGmgc2YAdONXoEKtCAU43ieOeV7sJ5pUskIAMbcKqRBQpQgQYMtTgyG4X+AE41joaaWSOxAacaR7CZNRIVGHFn4oqaSeaIO/PD8zlV4IwQT3SiOjJRgQZ04EiM6sjnc6pAAjKwAUPNAwU41ToFGtCBo3Dmh0QCTrUugQ3YgQIMNQ00YKjFQdIo5AeQgFMtbrujOjKxAwWoQANONYnDmfnhwpkfEgkYanGQrQE7MM5tBCrQCjsDI0KcxXQ3x2w8ChpZ48jC0gvD0hcSkIEzmMZBhqUvFKACDejAUIsjC0tfSEAGTrWYVERBY6IAp5rFkYWlL3TgVLMYtGHp+eWIFgWNz0d3gQxswA4UoAIjbhxkmPdCAjKwAXthuNA5UIBTwuN4w2/+bLMeFYSJBGRgA/bC8IVrYAcKUIEGdOAoDF9cSEAGQo2hxlBjqDHUGGrhgPkNix7Vezw/WNGjeu/5NDNQgQacEeZMrUf13oXzWphIQAY2YMTlwIjQJoYZRhxZmOFCBkaEaOoww4UCVKABHRhqccZhhgtDLU4+zHBhA0bcEfiM8Hz6OnEO8MSI0AN5/muc5hzgiR0oQJ0Y7TCvWYkODLVoHX8ACQg1h5pDzaHmCrTqC0dvOnpzoDcHenOgN8NDqwvjmrW6MDwUnRWVc4kE5OyLqJxL7EABKtCAnv0WlXMXxjUrOisq5xIZKNmFUQ23+i2q4S4Mv0UXRjXcaqiohktswA6U7Kyohks0oGdnRTXche0BhFqDWoNag1qr3oySsvaIJpEOFOA8HIpzm2ZIdOAonGZIJOA8HIommWZI7EABhloIqwEdGGoxCMI4FxIw1KI3wzgXdqAAQy06NixC0bFhkQsJyMAZl6P5wiIcPRQW4eiLsMiFBnTgVOM442mRRAIyMNTi3EZIxPGOkIjDmfO+1uJwpoeej+4DR2JUjCUSkIEN2IFTrUmgAkNtBDpwFNIDSEAGTrXeAjtQgAqcaj0OJ/x24Sicfms9jiz8diEDQ80CQy2OIfx2oQIN6MBRGM6a67g9asMSe2EPDOF5e5Y4JeYUsEfhVqIDR+G8fCUSkIENGGpxbuFY8UAFGtCBozAce2HEjdMMF84JZ49irOeybKADR2G4UOPkw4UXMrABO1CAoRa9GZevC0Mtmi+8uTC8eWHEjXYIv2m0Q/jtwohAgaMaKvx2IQEZGHGjSUYHChC9OdCbA705Si0KrBIJyMBWGL6YE+Qe1U+JAgwXaqABHTgKwxcXEnAKzyl2j+qnxA4UoAIN6IVxxTEOZGADdqAAFWhAB47CORtMhFqHWodah1qHWodah1qHWoeaQE2gJlATqAnUBGoCNYGaQE2gplBTqCnUFGoKNYWaQk2hplBTqBnUDGoGNYOaQc2gZlAzqBnUDGoONYeaQ82h5lBzqDnUHGoONYfagNqA2oDagNqA2oDagNqA2oDaKLWoc0okIAMbsAMFqEADOhBqBDWCGkGNoEZQI6gR1AhqBDWCGkONocZQY6gx1BhqDDWGGkONodaghlzSkUs6cklHLunIJR25pCOXdOSSjlzSkUs6cklHLunIJR25pK9c0gMVaMCRGbGvBLKQgAxswA4UoAIN6ECoKdQUago1hZpCTaGmUFOoKdQUagY1g5pBzaBmUDOoGdQMagY1g5pDzaHmUHOoOdQcag41h5pDzaE2oDagNqA2oDagNqA2oDagNqA2Sk0eDyABGdiAHShABRrQgVAjqBHUCGoENYIaQY2gRlAjqBHUGGoMNUw7BNMOwbRDMO0QTDsE0w7BtEMYag1qDWoNag1qDWoNag1qDWoNag1qHWodah1qHWodah1qHWodah1qyCWCXCLIJYJcIsglglwiK5dYoAINGGojcBSuXLIw1DyQgQ3YgQJU4FSbC6M9ipsSR2HkkgsJyMAG7EABKhBqBjWDmkPNoeZQc6g51BxqDjWHmkPNoTagNqAWucSjhyKXXNiBAlSgAUOtB47EKG5KDDUJZGADdmDEnbcEUbDUYvU2CpYSGRgRRmAHCnAeb6zpRsFSogNHYeSHWPqLgqVEBjZgxOXAiDDvN6MIKZGAcbwhEZ6/sAMFqEADxvFGk4TnF4bnLwy1aL7w/IUN2IECVGC0TjRqeD6WFKMI6cLw/IUEZGADdqAAFWhAqE3P91j6iyKkRALyxGjU6fnEDnyqdVq/q0AD+sTot+n5C6fnE6darPdFEVJiA061WGCLIqREBU41XsEcOAqn53ssj0URUiIDp1qLnp+eTxSg1xmPaJ2IOxjYgB0oQAXO440luigsShyJUVjUY9ktCosSGRjHy4EdKMDo+fW7BvRCirgSyMAG7EABKtCADhyF/ABCjaHGUGOoMdQYagw1hhpDrUGtQa1BrUGtQa1BrUGtQa1BrUGtQ61DrUOtQ61DrUOtQ61DrUOtQ02gJlATqAnUBGoCNYGaQE2gJlBTqCnUFGoKNYWaQk2hplBTqCnUDGoGNYOaQc2gZlAzqBnUDGoGNYeaQ82h5lBzqDnUHGoONYeaQ21AbUBtQG1AbUBtQG1AbUBtQG2Umj8eQAIysAE7UIAKNKADoUZQQy5x5BJHLnHkEkcuceQSRy5x5BJfuWRebn3lkoUEZGADdqAAFWjAUBuBo3DlkoVTbRar9Cj4SmzAqTZf3+xR8JWowKkWDwyiiOt5ExHYgB0oQAUacB5vLBBHEdeFkR8uJGCoxTFEfriwA0Mtjizyw4UGnGqx8h9FXBdGfriQgFMt1tejXKvHan6UayUa0IERd16Solyrx2p+lGv1WM2Pcq3EBuzAUIszjkxwoQEdGGpxbmH/uEuKGq0e6ztRo9VjJSdqtHrcJUWNVqICDejAURj2vzDUotXD/hf2Gkbh+QsVaEAHjsQo4kokIAMbsAMFqEADOnCqxaw4irgSCTjV4rYkirgSO1CACjSgA0dheP5CAkKNoRaejzufKOJKVKABHTgKw/NRrBJFXIkMbMBQG4ECVOBUi/uW2OKux31LbHF3Ycwf4mYltrhLnGoxP4uCr8QOFKACDejAURj54UICQk2gJlATqAnUBGoCNYGaQk2hplBTqCnUFGoKNYWaQk2hZlAzqBnUDGoGNYOaQc2gZlAzqDnUHGoONYeaQ82h5lBzqEUCifvC2OLuwkggFxIw3B0DMeYPF3agABVoQAeOC+WxcsnCOAsNjAgjMI7XAh04CiM/XEhABjZgtEOoUbavRIFanKZEgVoiAxsw2jeOLDx/oQIN6JCAWnsACcjABuxAqWMIz19oQAeOOobl+YUEhFqHWodaeV4e5Xl5lOfl0XFufZSwoCUFLSloyeX5OAZBSwpaUqAmUBOoCVpS0ZKKllScm6LflucXoiUVLanot+X5hWhJg5pBzaBmaElDSxpa0nBuhnMz9JuhJR0t6WhJR0tOz8ss+JIokkuUiRSoQAM6cEyMY5ieTyQgAxuwAwWowFCLgxwODM8/r0MSpXPLhVE6J/PL4xKlc4kCVGD1ED0cWD1E9AASkIENWD0UBXWJCjSgA2v0ET+ABGRgnIUFKtCA0TrRDhx9EUfWHkACMrABO1CACrTCmQlklsNJbCSXyMAG7EABKtCADhyFAjWBmkBNoCZQE6gJ1ARqAjWBmkJNoaZQU6gp1BRqCjWFmkJNoWZQM6gZ1AxqBjWDmkHNoGZQM6g51BxqDjWHmkPNoeZQc6g51BxqA2oDagNqA2oDagNqA2oDagNqo9SiLDCRgAxswA4UoAIN6ECoEdQIagQ1ghpBjaBGUCOoEdQIagw1hhpDjaHGUGOoMdQYagw1hlqDWoNag1qDWoNag1qDWoNag1qDGnIJI5cwcgkjlzByCSOXMHIJI5cwcgkjlzByCSOXMHIJI5cwcgkjlzByCSOXMHIJI5cwcgkjlzByCSOXMHIJI5cwcgkjlzByCSOXMHIJI5cwcgkjlzByCSOXMHIJI5cwcgkjlzByCSOXMHIJI5cwcgkjlzByCSOXMHIJI5cwcgkjlzByCSOXMHIJI5cwcgkjlzByCSOXNOSShlzSkEsacklDLmnIJQ25pCGXNOSShlzSkEsacklDLmnIJQ25pCGXNOSShlzSkEsacklDLmnIJQ25pCGXNOSShlzSkEsacklDLmnIJQ25pCGXNOSShlzSkEsacklDLmnIJQ25pCGXNOSShlzSkEsacklbuYQCBahAAzpwFK5cspCADGxAqAnUBGoCNYGaQE2hplBTqCnU6vmmRIFlogIN6MBRuHLJQgIyMNR6YJybBgpQgQZ04ChcuWQhARnYgFDzfHYrUWCZaMB8ditRYHnheADj2W2Mh1iVuLABO1CACjSgA0diFFgmEpCB0WYWGK0zAmfrcPxC5IcLCcjAGWE+KZYohJT5VoZEIeSF4fkLCcjABpztyxIoQAUa0IGjMDx/YahRIAMbsAOjfXugAg0YatFQ4fmF4fkLCcjABuxAASrQgFDrUBOoCdQEagI1gZpATaAmUAvPry4Mzy8Mz19IwFDzQKl+i5nChQaMuDGiYqawMNx94YzbYhgZxoNhPIS7L4SaQc2gZhh9htHnGH2O0edQc0jERKDFeIiJwIWjMCYCLX43JgIXMrABZ9wWYycmAhcq0IChNgdtlDHKfLwmUcaY2IAR1wIFqEADOnAUhqUvDDUPZGADdqAAFWhALwx390fg/LP5MESiHjHRgA4cheHjC+dBzneYJOoRExuwAwWoQAOGWg8cheHjCwnIwAbs1Rfh4wsVaMBo9WmcKDe8miRsemEHCjAOPcaDoEkUTRKGvDDihlpchC/swIgb3a3oAEUHKDpAoWZQM6iFTS9swA5EdxvUDBJRNziiSaJu8MIIFmMnDHmhABVoQAeOwrCpREuGTS9k4FSTOJyw6YUCDLURaEAHZhWdrLrBCwnIwAbsQAEq0IBeuKoJNZCBcRYc2IECVKABHTgK4yotPZCADAw1CexAAYZaHG+4+0IHjqsQUlbl4YUEZGADdqAAFWhALwwfSzRU+PjCBoyzWL8rQAXGWXigA6PN5iCIGsNEAk61+VhfosYwsQMFqEADOnCqzcIAiRrDRAIysAE7cLaZxglFBfE6yPXWYZzQeutwIQEZ2IAdKMDZF6tRzYAOHIXrrcM4t8gEFzKwATtQgAo0oBeG5zVGdXj+wgaM1okxGZ6/UIHRFzHsw/MXRl/MsR41hokEDDUNbMAOFKACDejAUJv9FpuXJRKQgQ3YgbPN4nFK1BjG3gBi6wX7wKggvpCADGzADhTg7Iu4abP1gv1CB47C2OhlLCQgAxuwAwWoQAN6Ya+ej2rCxAasno9qwkQFVs9HNWEiel7Q84KeF/S8oOcFPS/oeUHPC3pe0POCnlf0vKLnFT2v6HlFzyt6XtHzip439Lyh5w09b+h5Q88bet7Q84aeN/S8oecdPe/oeUfPO3re0fOOnnf0vKPnHT2/PO+BDGzADoy+GIEKNKADx7ULi/jagmYhARnYgB0oQAVaYbh7FlBJ1AImMrABO1CA8yzmrjwStYCJDhyFcZ2fZVUStYCJDAy1OLK4zl8owKk2i5ckagFl1hBJ1AKKx+HELH5hzOIvJCADGzD+bPZm7OKWGH/WAxkYfyaBs6l5/asAFWhAB47CMG9MqaKoT2L+sHZm44UGdGBEiD+LnWsuJCADG7ADQy0aNWbmF0ajjkAHjsKYg4/ogNiaKVY7onzvapK4Kb7QgaMwbopH9FvcFF/IQLRvTMcvFCDUHGrhwjBkFOolNuAMFiUsUbOXqEADOnAkRs2exnP/qNlLZGAD9okcKEAF2sQe6BOXxCikB5CADGzADhSgAkPNAx0YarNjo2YvkYAMnGqxeBg1e4kCVKABHTgKpzcTp1osrUbNXmKoReu0DhSgAg0YEnM8RKFeIgFDQgMbsANDIlqnKzAkoh26A0fhvDRrLEpGoV4iAxuwAwWowKkWa4NRqJc4CvUBJCAD49yi55e749zC3WP9ggNHoT2ABGRgA/bMiFGSl6hAA3qmtrEyQWBkggsJyMAG7EABKjBaJ0bUeAAJyMAGjL6IoTEEqEADOnBcqFF8p3NJUWN3uEQGNuBUm2uOGt+XTVTgVJvrfRqFeomjMJLCXOTTKNTTuYanUainLQ4nksKFHShABVrhmo4HUREXtaJeJEnhyrnmpFFVl2jAeeHyoJEUG8QtoiIuakUR0QKjGeJf4w27RVTERfNw40/WG7VBUqRFVuRFIRK9FS67cLZ1j7MNl13YgPMwe3TR9JPOIi2NcrfEuOEMigDRhdaAHShABVo2iVVzWjWnV3N6NadXc7pUI7pXI4ZlegygsMyFcaoxKMIyF8aRxvHHk6GIFQ+GFmmRFXnRuCiq1vTCOEsPjDlkkBV5UdySTFr3okFUxEWtqBeFyAhU4ByaczVOoywtcRTGZW+uxmkUoOlcptIoQEuM5Zkgz4aJ+rML4/p2IQEjbAtswA6UbPCoP0s0INQa1DrUOtQ61DrUOtQ61DrUOtQ61DrUBGoCtbjUXdiuoR5FaWv4RlFaogIN6IUanRKHEGZaGGa6cJopOiJuGxe1ol4kRVoUnR8jyxw4Cj10YqBMLyVGa8ZZeQN2oAAVaEAHTjWNwwnnXUjAqaYxFsN5F3bgVNNorbhYXWjAWAELGhetDeQWUREXtaKI2APjSONf49IzVwk0Kr8SGdiAcaQeKEAFGtCBoTbbOyq/Egk41ea7PxqVX4kdONXmjrMalV+JU83ihMKvF47C9d5YEBVxUSvqRVIUEaOJwn0WLRDum3e1GnVciR0owDjSOMFw34UOHIXhvgvnoYZYFIcvakXxuliQFGmRFXnRSIor37zN1ijfSmSgAOdhejR+mHVhFHpH00ad9yIumi3i0Xpx3btQgLNFPI4l/HphSMXZhV8Xhl89GjL86jGUwq8e7RR+HXGw4dcLBRhPXIKsyJPCliPOKgw4F7Q0Cqx0xMGGAcf63XmwIw42ZovzTQyNUiqdt5AapVSJDRhpJEiKtGie6yz11qiN0ll8rW1N9IJ60fOvba69aVRG2bwV1aiMSnTgKJxes3lXqlEZlcjABuxAASrQClvEjSNrEaEHxi/EmbU4nGijNgr7A0jADowI0XLdgREhmkni0KOZ5kA3iiaZIz1xFM6xbhTtMMd6IgNbxZ3rJ/mvAlSgAb3OWEehPYAExLmZ1AmZAnHGMdzXaPA43mhqj+ONpp7DPbEDBahAAzowWieObDyABAy16MIRanHoI9TiIEeoxUEud0RfLHcs9MQoDjJayMAGjLvzICnSonmw875ZozLIOP41JoPx1zEZXDQPat72aWymZrPwQmMztUQHjsJwx1yt06ghSmRgA3agABVoheGOuIeMuiCb63IaZT82F/k0CnwsJvBR4JPIwAaMzBQkRVpkRV40kuKSsoiKuKgVlYaUhpSGlIaUhpSGloaWhpaGloaWhpaGloaWhpaGloaVRlxUog3jmrJIi6zIi0ZS+GsRFXFRKyoNLw0vDS8NLw0vjVEaozRGaYzSGKUxSmOUxiiNURojNWJ7skVztmYxs4tCG4uVhCi0sZimR0mNxe1hFMTEtS7qYRbNgXrRHNNxRxwVLjF3igKXi7xoJMUgXkRFXNSKepEUlUYvjTmAY+IR9S2L5gC+6KkRE5AoebmoFT01YqIQ9S4XadFTI+YOsbfWRSNpDuCYTkT9y0VcFMcchxB5P1YCoqIlpghR0HIRFXFRK+pFUqRFVuRFpeGl4aXhpeGl4aXhpeGlMQduzGWivuWikTQHbkxvorjlIi6KVuDAaIWIOGIszD+PcpVEAjKwATtQgAo0oAOhRlAjqIUFYpobRSyJHShABRrQgaMwLhMXEhBqDDWGWnzZKOZI6xt+FxrQgaMwvmx0YcTVwDheC5wR4hK9vst34SiMrxXF5Xx9l+9CBjZgBwow2mGO/yhBsVg7iRKUxAacZxwrKlGCkqhAAzpwFMY87UICMrABoaZQi3laLH3ENleJDgy1aJ2Yp10YatG+FmrRvhZqcfIxe7tQgFMtpihRmJI41eIePwpTLObt61t7sSi3vrV3IQMbsAMFGHGjW2KeFncOUYJicRGIEpTEDpzHG/feUYKSaEAHjsQoNrG41EZZic19rTXKSixuw6OsJNGBozC8eSEBGdiAHRhqHKhAA4ZaCxyF4c0LCRhqPbABO3C2b4yd9U28Cw04nRUDfH0Tb+H6Vu9CAjKwAWdvxpqi1bd61epbvRrFJharC1FskjgK4wJ7YQNG62igFcY6QejGOsGiXjRT//o9LxpJ038XUREXtaJeJEVaFAcTIyeMd+EoDLfF5TpKQhIbcPaPR9uE2y5U4DyNGKZxlVw0kuIquYiKuKgV9SIp0qLS8NLw0hilMUpjlMYojVEaozRGaYzSGKUxUiMqQi6iIi6K9mqBHSjAaC8JNKADZ5fExCiKRBJn78SiSRSJJDZgBwpwqsUUMopEEqdarKZEkYjFBCSKRCxmG1EkksjAUIuDDK9eKMC4jobEuo4udOAoXNfRhQSMuBoYxxsnH/5b7Rv+Wxj+u5CAc2oYKzFRL5LYgQJUYBxvnGZ89S/WMHzNdKOh1lQ3fiHmuheGWhxvzHZjtSI2jEqcarHeEbUlTiuYFcaXbOM2PupFKJ5XRmUItfULBnTgPLJYNIhNoBIJyMAG7EABxpHFMZgBvTAuk+vI4jJ5IQPjMhlduC6TCwUYEut3DejAeUKxhBCbQCXOE4o1hqgtSWzAUIuziI9+XqhAAzpwJEZtSSIBGdiAHShABRrQgVAjqBHUCGoENYIaQY2gRlCblvZYYonakgv5AYyWjN9lBjbgHBqxQBK1JYkKNGCoSWCozVEStSUeqyJRW5LIwAbsQAEq0IAOHIUdah1qHWph/1jQiTKTRAEq0IAOHIVh/wuj3+KM4/PWFzZgqI1AASrQgFMtnuZHmcmFcc97YQPOCGH/KCjx1fPqwFEYSeHCiBCdFUZfBxlGv9CBo9AfQALO9o2ZbxSJJHagABVoQAeGWoyo8PyFBGRgqEWbjQ6cajGJitKRRANOF+rCcaE91meoFxKQgQ0YcSlwHu+8zbYoB/F5m21RDpLIwAacxztvOi3KQRIVaEAHhppPDB9fSEAGNmAHTjWJ4w0fX2hAB041ieMNH19IwKkmcWTh43ljZrHHU2KoWaACQy0OJ3x84SgMH19IQAY2YAcKUIFQ61DrUBOoCdQEagI1gZpATaAmUBOoCdQUago1hZpCTaGmUFOoKdQUago1g5pBzaBmUDOoGdQMagY1g1rkh3mbbVH4kkhABk4PzTI0iz2eEgWoQAM6cBTGh8AvJOA8i2XT8LyGTafnE+fxzrt+iw8hJhKQgQ3YgQKMuNMMUQazmiTqYNYZRyFMYgcKcLbvXCywKIVJdOAo5OrN2KEpkYEN2IECVKDVMSzPL6zepPYAUh1DeP7CBoRag1qDGjxP8DzB8wTPU6+xQx0t2dGSHS0Znl/H0NGSHS0JzxM8T/A8wfMEzxM8T/A8wfO0PB/HIGhJQUsKWlLRkuH5uSBksZtTYrSkBnagABUY57aCOXAUhucvJCADG7ADYxn+EahADPAw+lz6sSjLSSQgAzE0YiJwITrL0VmOznIMe8ewH+isgc4a6KyBzhrorIHOGhiIAwNx1NCIGhyfq1YWRTiJDRiPK1pgNFQPVKABHTgKY3pwIQEZ2IARVwIN6MBRGElhLilZFOckMrABYyIQJxRJ4UIFGtCBNcmJ4pxEAsb0Kw4n7H+hAg0YZzEnAlGiE5NIixKdxAaMVo8eCqNfqMBonRHo+LNRKA8g1ARqArUw+oUCVKABoaaQqJm5xU5KiQKcwebamcVOSonxjCsGV/h4Yfj4wnnocX2Lwp3EBpxqHscQPr5QgQYMteiAsPTCsPSFBAy1aOowr0dTh3kvNOCMO+I0w7wLw7wXEpCBDdiBU21E64R5LzSgA0di7JmUSEAGRrAWGH82my82P0okIAMbsAPjIDVQgQZ04CgMx15IwFCzwAbsQAEq0ICefRGbH10Yjr2QgDF2JBBNEja90IGjMK7Sc1XNYhejqx06miRsemHEDbWw6YUOnAuoc63NYhej688EHSDoAIGaQE2gFja90IAORHcr1BQSKteym0UVUaIB49ldnLyOQnsA5+rvIxoqHihf2IBzkfkRavFM+UIFTjWOkTptmjgK17LbQgIysAE7UIAKhJpDzaE2oDagNqA2oDagNqA2oDagNqA2Si02KUokIAOjJSWwAwUYLWmBBpxL9nPt1aJA6cLp+cTZb3NF1qJsKTHURmAHCnCqzSVbi8KlxKjaiOOlUcgPYKj1QAZOtRhnUbiUONUozoIVaMBoyRVhFMZK+oUEZGADRtxohxbHG+c2jT442mFepRMZ2IDzeDlOfto/UYEGdOBU4+g3eQAJyMAG7MBQi+MVBRrQgVGbEccbT88uJGCUZ8SRxQO0uVJmUQOVGBUa0WbxDO3CqAOJw1EHjsJVbrKQgAxswA4UoAKhZlAzqDnUHGoONYeaQ82h5lBzqDnUHGoDagNqA2oDagNqA2oDagNqA2qj1KKKKpGADGzADgw1DVSgAR0YT46ns2J3pEQCMrABO1CACrTCyARtYRyvB3ZgHO8IVKABHTgKozLsQgLOuHPd06I27GqShjMOzy8Mz19IwNm+sdgZFWKJHSjA6s2oEkt0IHpT0JuC3hT0pqA3w/PrcAS9KehNQW8Kzi08H3coUTKWONViGTaKxhIbsAPj3CJYeP5CAzpwFIbnLyQgA0MtBkF4/kKtzgqjx5Ltqi+7cBSG0S+k6gBHZzk6y9FZjs4Ko19oQHQWjC4wusDoAqMLjC4wusDoAqNHEdqYtUoWRWiJBIwqtkfgjDsLPCyK0BIFqEADOnAUxiX/QgJGXA4UoAINGHFb4CgMS19IwLi4xwmti/vCDhSgAg3owLo06yoBXdiuR9QWuyMlCjAev2ugAR0YZxEY9r+QgDPhxexqFaFd2IHRZhaoQAPmw3OLPZMulAeQgAxswA4UoAINCDWBmkJNoaZQU6gp1BRqCjWFmkJNoWZQM6iF/WO5KQrWEjswyhBinMWd+4XRkiuCA0dh3Lmv3ow79wujDCF6KBbjLuzALEMwXU/iF0bd0UIHjsK4JYiZbhS3JTKwATtQgBF3Wi/2TBqxkh5lbCMWGmPPpMQOFGCUMEmgAR04CsPzF4aaBjKwAeMWxgMFqMC4hbFAB45CfgAJyMBQWxjnFnEjE1yoQAM6cBRGJriQgAxsQKjN/DBinTaK2xINONVi3TOK2y6M/HBhA0btwQg0oANHYXj+QgLO1olb8KiES+zAON7owrjkX2jAON4YGnHJXxiX/AujL6KPw/MXNmAHClCBobbQgaMwLvmxEhllc4kMjFKzR2AHCjCqzaIDVhFcnNuqglvYgQJUoAGjTC2EVy1c4CqGW0jAqRbLbqse7sIOnGqxfrZK4i404FQbMR7i4h64yuIuJGCotcCI2wMVaEAHRtzZ1FEDN2LJK2rgRqxHRQ1cYgN2YKiNQAUa0IGRzGcBmkXl25PjiMPJj7i2Ru3bk+OQOK4Zked9VZFfrBvbxr7xAK8SuItXDdwjmDeu0RPfSkxUoAEdOAr7KrSL7ui0MW8cZ0dx1utqf7FsrBvbxr7xAK9r/sW0MW+86cqmuy78sSri68p/sW3sGw/wuvpfHLqxcOHr+n9x27hvHLqx/rRK8JJt49DlOM41DYilFV/zgIuXrgTzxks3js36xrKxbmwb+8YD7I+NaWPeeNP1Tdc3Xd90fdP1Tdc33bHpjk13bLpj0x2b7th0x6Y7Nt2x6Q7ornq9ZNqYN24b941lY93YNvaNN13adGnTpU2XNl3adGnTpU2XNl3adFdGiklE1PAV08a88dSNh2RRxpcoQAUa0IGjMNLShQRcp7PY8uI11t1FrLpFcV7yyjoX08a8cdu4b7zewZmOHLK1umxnL9vZryxycd94veETx7myyMW2sW+89bZuurr1tm69rVtv69bbuvX2lUXieK4sstg33np7ZZF1PCuLXMwbb7pbFhlbFhlbFhlbFhlbFhlbFhm+jTLf2tm3dvatnVcWWcfjWzv71s5bFhlbFhlbFhlbFhlbFhlbFhlbFhlj698riyze2nls7Ty2/l1ZZLKvCsDk0vUHsog/kEX8gSziD2QRfyCL+ANZxB/IIv54VP/6gx4b08a8cdt4tTMHy8arnVuwbewbD/DKIi2OZ2WRi3njtnHfWDbWjW3jpRvHfL0tF7ySSRzyWr+YtvbHyiZzCdQfawXjYt3YNnZ0V9u6sW/d2Glj3rht3DfeurFv3di3buxbN/YBRlryh2zDR7bhI9vwudLPCLaNfeOI36N9VvrpcZwr/VzMG7eN+8aysW5sGzt43cFEF607mIUN2IECVOCKHANtJZiLB3glmPkmqD9WgunRMivBXNw27hvLxrqxbewbD/BKMBdvupFgeozRyC8XduAU7TH6IrlcaMCpeAUbiVFmmEhABjZgBwpQgQZ0INRW2ogDppUe5qKq00oPc1XVaaWHi33jAV5pYC57Oi27z2VNp2X3i21j33iA1y3NxdHas2LYad3SXNw27hvLxrqxbbx0KXiAVx64mDaOku44rUgDF3bgEo0GXEngYtvYNx7glQQupo1547Zx33jTlU1XNl3ZdGXT1U1XN13ddHXT1U13JYfV0Ss5XGwb+8ZLdw54WnOQ1blrDnJx33jFj0G45iAX28ZrRToGnm2Dx7fBs1LExZuub7q+6fo2aH0btL4NWt8GrW+6Y9Na8wuNwbPmFxfrxmtxff2+bzyKec0vLo74s7zRec0vLm4b942XrgSv+Bo8wGsecfGKb8G8cdu4bywb68a28dL14AFe84iLaWPeuG3cN5aNI+YsO3VeyWGuRjqv5HBx31g21o1t4zhmizZfyWHxSg4X08a8cdu4b7x0o19WfrjYNvaNB3jlh4sJ/bXyw8Vt477x6hcO3tpqef9i2pg3XucS40e3ttKtrZbHL17xQ3fdf1xMG6/4MTZs6yPb+si2PrJN1zZd23SX9xcv719MG29jwzdd37SWry3G1fL14nXpv5g2XjFHcNu4bywb6/XgwqMmMdGBIzFqEhMJyMAG7MBoorlg521Z/uIBXpa/OE5n3oJ7W5a/uG3cN5brZVpf+5NdaEAHjsL1SvBCAjIwmsnjHNZc4WLb2Dce4DVXuHgddwtecXrwiiPBvvEAL3vPcldvy94Xr3aJ41z2vrhvvI7fg3Vj29g3HuBl74tp46U7gtvGfWPZWDe2jf3aPsDbcvpqnuX0i7dmu55kxvC4HmUu1o1tY994Pc6MoXI9z1xMG/PG6wFq6K4McLFsvHSji1YGuNg3XrpxjisDXEwbL90YJisDrKG3rv4jmnxlgxHNtq7+Fxt4Pct8xPmuh5kX88Zt43ie+YjzXVf8NSTXFf/iUbwKGpN5Y7m27PCoWEw0oF8befjaUm3h2qdjIQEZ2IAdKEAFRgXrfMTsUZxYTBvzxqsdWnDfWDbWje3a+cSjRjFxFMaWaxcSkIEN2IECnHHj5qavPa4C1146j2jotZnOxbxx23idTERcG+pcrBvbxr7xAE/vxwY73msHHu+1A4/32oHH+9qBZ6EAFWhAB45CXWejwW3jvrFsvM7Ggm1j33iAY8+dvpCADGzADhSgAq3QV+94MG3MG7eN+8aycRQvBVmRF42keOK5iIqiECOoFfUiKdIiuyhqECkKOjzKDYnmQzmPesNi2ThaoQUa0IGjcO2RtZCADGzADhQg1AhqBDWCGkONocZQY6gtY8/yZY9CxGLfeIDjOh7lHh7FiMW8cdu4bywb68a28dKNY1vbaC1e3r+YNl66Pbht3DeWjRU9uLx/sW88wPLYmDbmjbfRIttokRU/Rpf4xgO8dgSZDzA9yhefbMG8cdu4b7zOy4N1Y9vYNw5djmNb7zZwtLnRxrxx27hvLBvrxraxbzzAvumumqYgLmpFs6ApxtyqZwrSopjNBnnRSIr9VBdRERe1ol4kRVpUGiM1opbxefwteLWJBK820WDd2DZ2MK04HrziRHySjXVj29g3HuB1sY/1bl0X+4t547Zx31g21o2XrgX7xgO8csLFS5eDeeOl24OXbrTDygkX68a2sW88wCsnXEwb88Zt4013vXQYpEVWFO9bBY2keJFp0Ry3ESVeY1rUinqRFGmRFXnRSIrXlxaVhpbG8ns8alnliVFm5as+keJZwipQTKaNeeOI06Nflk/jWqDLp4uXTy+mjXnjtnG0bQ8vrKv5xbqxbewbD/CauF+8dGMcron7xW3jvvHSjbYauvHSjbYavvEotnX1v5g25o3bxn3j0I0lVFvev9g29o0HOO7zk2lj3jjekAvqRVKkRVbkSSsPxHKnLb/P7dZ9bbqXHHMLCjSgA0dhzO0vJCADG7ADV1NI8GoKDR7gZeeLaWPeuG3cN16nY8G6sW3sGy/daedVu5hMG/PGbeO+sWy8dKPZ16U/Vr1tXfovHuBrM7DFtDFv3NBNunWfbt23Lv0X28a+8QCvFHExbdwrLdiWImxd4i+2jdd5Rf9uKcK2FGFbirCVImIJzFaKuFg3Xu22ft+3v0VqsvHYeNMdm+7YdK8UsVg21o1tY+j647FxxIxVe1/2v1g2XueiwbaxbzzAy/6xCu/L/hfzxm3jpevBK/4I9o0HeE0JYl1gVTsm88Zt476xbKwbh26sxq5qx+QBXlOCi2lj3rht3DdeMaPNVx6IVfVVw5jcNu4by8a68TrmaPOVBy4e4JUHLqaNeeO28dKNfll54GLd2Db2jQf4ygPRX1ceWMwbt43XeJPgra2Wxxcvj19MG69zifFjW1vZ1lbL4xev+KG7pgeL1/Tg4ogfk/ZVh3j9rW995Fsf+abrm65vusv7Fw/w8v7F29gYm+7YtJavY5q9agyTR/GqMUxe50LBmJaPh2ysG0f8WNZetYTJA7w8Huu245r2x98uj1/cNt50t9uBsd0OjO12YGy3A2O7HVi1hMmbLm9ay9exdrlqBZN943Uuc8yvcsFk2pg3jvgxkV6FhMmysW68dKP91xwgpi6rkjCZN474sZa9KgmTZWPd2Db2jQd4eT/Wu1flYTJv3DbuG8vGurGBl69jrXxVD8YLEL6qB5N1Y9vYNx7g5fFYN1/Vg8m8cdu4bywb68ZLN/plef/iAV7ev5g25o0b+mt5/2LZWDde423mtFUZeLXV8vXFbeO+8TqXGD9ja6tRbTVWBWDyij+CeeO2cbw1Mp8NjFUBmH+rG9vGvvGmS5vu8v7FvHHbuG+86dKmtd5Ems8qxqru47mOP1Z1X3LbuG9s4LWVwFzTH4+1l8DFK05ohWd5LoOPVX7Hc9F5rPK7ZN546Vpw31g2VsTvtv27bzzA8th43nNwSMX6+4UN2IHbuYrj/GSAdWuD2Nmeo8vXS0NzPXqsCjt+xLBYrw1dbBv7xgNsj41p42gyCq2waHLfOHQpujksyhSncm0kEod87SQSTRkb3XP8+nRoIgH79YWt8bg2DYluvXYNiSa7tg1Z7BsP8LVzyGLamDde5xRddu0eslg2XrrRxtcGItE2aweR1Q9rC5E4/Ki1i6+CDVpf+lrIQLm+ljaiqi7RgCtyCx7gMGl8Y3vEXn/FvHGcUQwsWi8TXiwbxxnNicRYdXjJvvEALyNfHLotznQZ+eK2cd9YNtaNbWMHL4O3aKj4FKavf16/Hs3QfOMBXr6fS3djldslr8OM5lm+v7hvvA4zmmf5/mLb2Dce4OX7i2njpWvBbeO+sWysG9vGXs2w3iJs0RPrNcKL28Z94xV+BOvGtrFvPK4vFo71fc0LCcjABuxAASowmqvH6F77B11MG/PGcT49znntIXSxbKwbT/No9GR8YOnCUbi+q7mQgAxswA6MduoxGpffLx7Fq6iO5633WEV1ybzxOp8e3Dde5yPBurFtvHQ1eIBXNriYNuaN28Z946VrwbqxbewbD/DKBhfPtpRohvjq5vWvcwxInPj6SO5CAzpwFMZXci8k4Oyj1RLxldwLO1CAU23WQQ9eX8ld6MBRuL6Su5CADGzADpxxw5erwo6vfx7glQ8upo1547Zx33h1zAjWjW1j33ieUHh9faXzQgIysAE7UIAKtMI1N5jP/McqvkvmjeN0ZnXzWMV3ybJxnM4aLGtucHGczurslScWrzxx8dINz6w8cXHbuG8sG+vGtvHSjYGz5g2L17zhYtqYN24bx+CIUxkYHGMbHAODoz0eG9PGvHHbuG+MwdEeurFt7BvX4Gj0ABKQgQ3YgQJU4Boc//Vf//Snv/3bv/753//6b3//l3//x1/+8qd//s/6h//7p3/+b//5p//z53/85e///qd//vt//O1v//Sn/+fPf/uP+KX/+3/+/Pf4+e9//sfz/30Oob/8/X8+fz4D/q+//u0vk/7rn/DXj8//dE6N5PrzOUUZFeI5+folCH0epPcM0VUrgLVf/p4///s211Tj79tgHIDx/bNoc/ZznUXn9ulZ9M+DjGoHkvr73u7+eYuv/62zeC6f4whYfwmhhxDVFW3gEJ4X9rsBlHIoPJ+3VoDWfh0OfmjIrhnhORXzT0OMU2dytYNa+zTEqSlj56CrIbx/2pR0GJMc2TFiPAfHNiDk18MgfrU/jicy8kT6c9nh8xM5xBBtGUNm0sgY+sGecurVudhx9arwpyEOIytKViPCcwl/s+jjdoT4dMOK8NT9NMJhcHLUi64ufd75waO/9gcdBqfPJyrrIIZ9ehB8SDUtnjWvQfFsTAxvt5/1h33eH6dREd+aXqPi+Zz5sxDzvvfT5uxzqXo1p3T6NER/tU9ZXu5T1pf71A6ZP9YHIsSch6NPpd0/kajXuE5E6NMTOQxO9uzS58zm09F9TBVDa1BQ+6xHG72evU8xeqOM0Zt8fiVs7Xgh4rLI1hrPG5dfY5yaw7NH9CFbhHZ/YHSpgSGbyz4OjKanaYWNijF0SxgfzuRwHM+7kHLJc6qMjv1Gn5RL+n4J+K1PDuOTrBLGc1FhuyC2D3Os00xNZVSQ+cXDLcqHqRa9Pjo6vzo6zucyar5F85tOn59LPyUOQwbc5t/Pm/FfY8jL40NfT4HH9pj7dmd7zH2YP28PP11grSZ/z3UvtEf/MH88ZdKmWpM/2y7S49dkKqcLfXyiah2Hd/08xmkSGt9YXMfhD/88xmGcUnxK73Jdo89jnLJpLJddt0e75/z+ALmZCkVeT4Wirw71c8c617T+0T9v0NMgZVwmp1E/jTFe71h9vNyxp+boUpO4Lvb5GFV+vTm0vaE5+svNcUwdvWz/XOs9HMZhjHa1VgsiW0r/GON4HCJUs/NxOI7DKFWu43jeRH6eBr+T1PXTpG6Pl6f5drrmzy2B60Cs++cHwqcmYaom+WUO8yHGYaR2qmtlp+3G6VsxrBqkuz0+j3FIp/6olYG5Dwy698OV0s739dmoc3vFz2McZqetVlr24fFctf41wunOPqpn1vDg7eLyW4yDYYQzfUh7/CzCqBnh1hK/RTj1anwfYjXF2NdSP/Sq8+u96u31XvX+aq+6vN6rrq/26jHCy70qUQe9DuL5APxnCfDe8sB4vLg8cMx96FLt7fNEPk53TVojS9R/GMNqVfSJ9LMY8aXoFcP58xjH+9n4ctHqk4fbp/ez4zQdjU/3XjN8/fyeeNhpjNdy93O4723K92PEF/5WjEH2eYzx+l11vEr/2m318ULvj22dYTfLx86N99pfO5Bz31qu/z8fZPafjY/4zs0V4zA+4g30zwdqVIGvFnn2rn9y13M+kFrBfz4r88OB2GnFo+b5c/FmC/JhFf/hxwdlrR6U7Su23wnSjWs9yx/0eRB6vGHAnx40vWPASyUAmm9Zfj7g6XQD9Vw4qdMho/HJKKHTEvK92+txfIiJdZPm9CPXtFaz49b74/PBSvbHuuZ5i1AXXT2kAKLjrZx7tekv6+H+4VHkYazOHYHqCZzLz4IM1TydZzo4BeE3uOb08Omea75IRrhMDH98ngL4vHJa+dn34oPfgujxilVp0ffiA/7wTJDtD3UenhQ/n908fuY8xSzTmD8f8O3x6nPz42Fs14jBejiM00Bl+L9tK0rE4xtB4sNOOUl8HIKcSkvUMycOHZ/f01E7zgKsVqYem++a6P1LzSxJKtO0Xya9H6zX7GX3njzDjHU2Vv/cM8cZvOJISPcE/bG+4nFcaavn4Prgz4/k9ESKY2fn6/5OP7/jpv6GW/94T/XVe3/qL9/8U3/D3X/UU7x2+38Oce/+/2iawbjSDDmY5vxQymoasOfF57//GuS0Wn/vKnE+jl5PLXmfXP12HMc5jVbN3nzI9flM4vhYatTCCj+2m9bfSpuOJVY1Uh+fV3/Q6bEUx0s210i1/dnnhwnN6bkUra+cXLPvx5aKPj7dOl5umLFQ3ulwzRJ/wwzt9HjqZo4/ZlavZ/2N9tnzx8yqJ/fdru08HkvjitJ4X3T67VhOJVMm22qPf55bTw+pbmd5lTdk+dNzqptZXu0NWf70nOpmlj+GuJXlj7cCDZfw58Oyw63A8VohW5GM+JaSPmTo00Jte2AS/ksS+O1ITs8i9DHqIeTYJq4fC2Ctv56hT4+pbmZo0zdk6NNjqndl6E6OB7OHG4LjoyYULcqQQ+f44/XOcXq5c5zf0Dne3tI5xyzfeFt8OtyJH59btXIO7ytYv+XW02On21ne7Q1Z3v3lLO/jDVn+9PzqZpY/hriX5Y8lslIlsqqfFj0fb12fz+4rs/q+WvthkPXj8nW9MuO6h/hwmRinxEqOwf54fD4HPwZpKLf7ZbXmtyCn1HrzBYPhx7Fe65uHNwxOIW6Woz9eL1SJXRk+PYybLxmcZgB33zK43SuH1wzuDo++tcc3x9jDMJ/5/GYx9pY43NTcejWJT2vGd8vbz6dj9cz3eXk4nc7pTRSuK9X8hsanM4AvgtQK5/wwwudBiF42L5/elLpn3mOIm+Y9Pry6ad7Tuzk3zXt60+muee/3yufmPQ+PVvV/c4f7w/A4Lhfde03o+PDqXt8yvd63pydXN/v29Nzq9qtCxyA3a6mZ31BMzfxyNfUXg+xRiay1nyYyrfKouQ/i50FO70891wlRILq/bel8P7l3qgckz0vV55Mqbm9Iqe31lNpeT6ntDSm1vZ5S2ztSans9pX4xPKrC/Hk3NQ7DY7w+PE53ujeHR389K5+eWN0dHqcHVjeHx/Fx1e3hMf7o4bFlD6OfTZc7VWbv+932b2Ps9BrVzdfGub9hnMrr41ReH6fyhnEqr49Tecc47a+P0y9Gx61lkNNCCuEF9OdDvk9XMPj0oErVakHH7XDZPz2oGqhoeOz3QM7faQ9De/gP2/TmK/l6XFyuSiLe75R/i9Fed+3pGdVN1+rrewOcnk/d3hzAXnat+htce7tXDq49jo42HKNDfxZDGO+VtU/3CODT86nnIwuppxc6fhij6n+OMc5uuXdravLySD++h3VvpNvxMeq93SOOL1HdeT/kfBQ3/XZ6KHXTb6dnUkr1qF73W7Df/HY/iPwwSK+Fy+fdMR2C9Ff75XwutdD/xJ+eC9f+VMrbZeGbQeqVCN0XHL8XpNV9+vO2Xw9BTrOgBx6wTabPV1FOYW6v55yD1Gv+o9H4YZBWLwGMtm2j9r0gd1eWRn/DytJ4eUuK83HgHa/h2xTz9+O4G0QfPw1SF5on6s+CPCfMNel+sh3CHLtYKrGNfSLxzcHmGGy7j78XRAeCHAx4/xr+6X1qLDJ+eg2vd9/MDmsQx/n/vZ2TTg+oeq/D6H18fu/fTg+o2Kp2nq0fDsRfvgFopwXZe9OiY4h706JGry/6N3p50b+d3qy6ewNwv1fs0CvH0VGFnc+pYP9RjIbVpee1yn4a4/FyjIZ50Z6CvhejOvcZ7vMY/Hj5ZuaLGLduZs7n0jHIuvrrMX44xhoPPKz3z/v29GyKFG/eGB9cdzwQw7t3pp+nwtNLVbc71/7gzjXCuRyMe3qrih71/gDtW9R+s1EHdrU6jLLTY6V7NYPtuL3fkDqXYZ/fWB2Po2Otfd977bfmOF2zpUo5uhxezWynh1M3F+1ae72CqrWXK6iOIW5es/vrFVStv1xB1fobKqju98ohnx5Hx71Fu3OMe4t27fwe1L00dh7ptxbcWn99lPbXR6m8vh9LO+7ud2dh53wUN73y+mOpJv0daynHMHfvB89Bbt7enoPcXNX5Isi9VZ0v2uTeqs45yO1taOn1VZ12vFu/udEovb6qcz/IYVXniyD3VnWOQe6v6nwxTu4tyHwjPX8+udPx4lrKeU6Fffr6HuP3dZDjxKxedu9yWkyx8zbBt0qG2+k9qts7Yp9OZ39azoeNN5rJO05H/+jTiXXBdTr7xpK/n47/kSNNtGbvYvJ5oUw7PbDqta9K53335Q/NcXqgcTMrHo+iHs7s9zK/H8VxW8p6Ma0/ZzefHkU73mLWZtTzdnP8LIgPzCbG9mLKt4IMbAf7GNsDvO80ap3Mcx5/aFT/Q0M8G7Jm3k+Wz0/F39Ez/o6e8Tf0zNG5hje5uB8SyPGBys1td9rrz6nOx4FFJhqjH47jGKSeQPCD6YdBvGFHw1+a9WOQ8fplpp/eo7p9mTmdzt09YvrpVSpSwVqTin62DdhXQW5tNNNPj6nubjTTH8cPptzbaKY/3vByan+84eXU/nj55dT+eMPLqZ1efjn1HOLWy6nnEXJzw4x+3Afw/sfQTsdyd8OMfnqb6u6GGZ3eMVrpHaOVXh+t9I7Ryq+PVv5jR+vdl+378StUN1+27/yGLVU6v2FLlc4vb6nS2d4xQvz1EfLylirHC/jdN+W/CEKGIIdZQOM3TGraH70UoFjMUz28tX8OglsKPW3keQ6iNUjU+fOHX/38iORuw/of3bBe26Go6+F0jp+7eC4kdDzy0U8nel8EubUJUD89wNJR71Vap3E4nTdsAtT765sA9f7yJkC9v2EToN7fsgnQF2Gk1U3w8/Gif77qexqyplVHY7q/oP2xj48Pke6VjHV5/YXVLi+/sHoMce/BXpfXX1jt8vILq13e8MLq/V6xQ68cR8etkrFjjJslY1/FeLwc417J2BcxbpWM9dO7PDerir6Icetx/Plc7pWM3Y/xwzF2s2Ssn16yulsydj6QeyVj3V6vB/wixhs6917JWLfzev6tkrEvDuRWyVh/fQ/Afnpwdbdk7Hgc90rGvpzcyTa5a59N7my8YYZ4CnLvgc95ame9loqsfz5QnV+fO3zxwao7c4dTiJtzB3/9Y9TdX/4adXd7w9zhdq8c8vp54l/X2+fjic/T6XhDKjzO/HX7gMb+PcXfZv6nIFYD5In0syD0eNRcux/vQY7VfA1lGvrzGxlX3MhsV93v3sjUGc2bGj2EORc5ol1If9guvXYD4L5/JeG3IG/I8OdbiAfSgP/IOozczPT51VseL9dZy+MNddbH47jbpMeurWKPZy+3nw55qgXnJ7cf37vH9hpXGNYfO4drgjZD6s+WAH55xbj1wyLcaem6VoqQHHv71uPNGmvz8eZnhQFCb3lGKje9Rz98vGmjDsQfezb6EEROj670UVlaH3vvfuPJJB6hMW+1Bd97vGlUhQF2WMuX04OrtwR5dio+d799Tut7Qaz2JHyuKnzeJnLaDNBqQdK6/izE6JnUhvjPQtCDUZKjcghyerrhyK6+7zo/vvHEl6xhLmD7ZzkfHw9FX8oi5yatTLZ/sul7vVKLVcPk5Y41+aHl2qOuVm3bf/97QVAj+Yx3GOjHV5zujY5jDCIU91P3nx0IET4psm9B8b0grdaJaN+P9HtBhPHAqdtPgyjujnz89HTq4Qo1Pp3OeDmVtfFyKjvufXc3lfU/erC22l+RmtgPG+ReIjqGuJeIbnbLIcRXtZYN/TL6Z1Oqr4JgX9TH/hHaD5O746ZzN6s+j0HeUqF8t0XaG1pE3lChfAxys0XOL6A8es2oHo/9lanvvcfywBziGeb0Ys7pruj+6zCnMGqG+oat+Ey/EcLrEwvq3X4Woj5ypm6fhfhi05e7vfNVmLu983i8pXdOYW72zjHEvd45h7jVO+edqOoL8Lq/x/LNPbGqaPMZ5LCd1XmX9VvvkIs9Xl6Il9MrU/cW4o8h7i3Ey+m51c2FeDl9uureQrwcn1rdXIi/3yuHjR+Po+Pmxo/nr1Dfeodcjp+tuvds9IsY9zZ+5Nc3FeZ2zqg39487buV/dw+sY5C7W3qdv0xwcxO68+nc3ITu+GWCu/u23Q5y2rftHOTmvm3nNrm5V9r9r2h8+kwhlmE/HfW3tjk7b8lVS9be2+cfBJHx+jNjGfL6per0jfCbl6pTiJuXqtM3p+5eqsZ49VKlx/et7l6qbveKHXrl9WfG+ni9NuqL47hVtKqPl6tW9PGGB8bH47j3AO7YHDefaZ5j3HumqaeXpG426fHLSDefaR6P416TfvHNmmoO122Tkd+/WSNvuT/8IszN+8Mvwty9P1SyPzzMvdvMc4hbt5lfhLhzm3n+5uS9jwu0l28PlV//LoDyy98FOIa4d81Vfv27AMovfxdA+Q3fBbjfK/azwXHz7rC9fHOo7fWvAnwR497N4eufrrC33BraG+7H7PXbsdOmQPf3W3r9Zuwc4+5uS++4sBxb9e4WY/qOMXJsk7s7pukfeza3tzrT18eqvGHlQN6wcCBvWDeQt8ylzq16c/Ghvbz2oPLqFuunj+91VCE85977rmAf5mLHt6q4ptyN22fP/r4IUWUZ87PEn4bwlx/anRrjUUPjw2fiPhyGHheW7715q6fHfrffvG2vNunpK5Na2zXqL3twtfsRalapexnFxwiniZg88EYGb/U6rd+P0RmTOW6fxtDjI9RBeBVqkH2+Yc2rQ/T4mosKim1V9sXCD42q9njZsecQtxxr/HJzHLd4q9Il3t/U/RCBXx3jxwi3xvjpLO6O8WOMu2P8tPff7TF+3B2q9pnkJ28H8o0YgpdCRA4xTk6x7S07o/2DnR+dcnph56ZTziFuOeX0sao3JI5fm2Nbev3YHP18b41XjgWtwR/rwG/H8Ndj7DszfiwlP9W0WX2+i2zbH+65Fno/htfGMk+UH8bwijG2eeBvMc57XldVq3P/aYyOGPJ6jK2g/WMMPX8E1Wtdbqt5/i1Ge71vjzFu9u05xr2+1WP6qK1Pnjhej7H55Xsx6q64scnPYrSGvan642cxeiWy9su22986Dq35ddvvzn8cQ38Yo5ZM2156/b32YLzm337Yt9jo9on2wxiVg1qXn/at1tv1Xe2HnlPsP3rq22MM7Mg6tq8IfNP7eCD24Ndj0I+PwxBDfxZjoLp/dHv9OE7XufGGa/Z4wzV7vOGa7a/n9dsxDnn9HONeXj/GuJnXjzHu5vXjJvf1GltX7z+af/RR2+r04Z+3x3l+um2r45/PT43Hy8/TrB331Xlgb579rYuPB3JaF7MoLF3LjLLvpOwfYpyvDsjs+75p9iHGaUXrUffJ7bE/2v8Y41SAQo+OV6b2l2p+O5tjs8p27bdDsx6DjG3fpMMgOd32m9RbNU/e9hn7eFtnp53+MOSfa+Jb5/jHlj3YZtsrf59C/H4ch6l/q/QubfsYyscYp3I8sdqg74nysxijpiEytvKg387l2DOGl7fN9y0lvxXF8U6MuXzeJvR4eZXrHOLWMhd98UIsFqnmyP1kHcNOqXU8akf2QZ+uppxDUL1WN/ZXL/V+t7jVje6TXX/WuT5qWefJh8Vck5eXqL4IcWeJyuTlJapvNEf3HzeqIYr0n0aRgSg2Dl3jr3eNv9w1+viDu2ZvDh8/7hrcmo3xeUqk0962N5PZMcStZGbncscqg6Oh/ZDeVV99gHEM8UykaNWny8fPgii+hmL76XwvCEbJ8zd/NNKGoYJjnDIrHV+MHaNGyZPFfhaGGZt+7+bjZj8MQvzDIFLvLbNsFXrfCvI8hVpueuy3Je3jxt+HAyGqZzPc9vnVr3ULZm/YntrsHdtTH++xsGD9y6dZPp7N6YNGt6owhr1+JqcYgnz0Yd57/zgEm7GJbZ/f/BjDvL98zTuHuHXNO234d++ad26Mqr4Sb+PQGH660NTDDO37xxh+C3J6N68WNfY9oD7erx4PQ6o1dP/ywPfORWqx6fmIRn4cZNtnf/w4SO0pr788yvww1k+N6uVaGYcYdHzZ+eZ91ePVqcjxy1A3ywfOX5e6Vz5gxyA3ywfo9Omh3msNoO8fd6MPudAf9GoO+iLEnRzkj5e3kTi3htQo7WJ+aA15vTXk9dawP7Y1tON7jPtrCr+1xni9NcbLrUH08vXpVDI56vrU9y8mfJy6nGNUHUXft+T7GMNPL9Lcncz5aV+/u1MgOq2oKmHfCDkch73jZPwdJ3Pc26v6l/ZtCol/3bjJT6/kb1vzbyvM5t84DK09ZGkv3P54GHRcdb97ZWjHb5Arvre9F4b0xzeC6KPW/vapw3eDVHG/NvppkJpOjX3fxo9B/PxSzPaeou6vKnxs2PPHCxtugtohyOl04gHDOp19afd7beLoHT9sEeqN/uAgv7xVu++//KFNzkH2nUb3NvktyPGJFWoAaPAPg+BZE/VH/2GQXm/nPXOjHIKcpgH3tqM7t2vsD3WtqPjn7UqnhdWbr/jRqQ7g5vz/GOLec5Xjmdy8AfiiOe7dAXh/R573Y6nqrZ0s/Lgj/L23ar2fv015hTi9sngMce+tWu+vVwH46Vsh996q9VNl5923au/3ysFyx9FxbycLPz2ruvk+K52quu9+/eAc5ObXD45B7m5mcT6Sm18/oOMOjre/fvBFmLufcfsqzM2PKJxb5uZHFM5Bbn5Egfx4z3hnd4yje25uOHKOcW/DET+9TXVvwxE/fprq5oYjx+O426THrr33EYUvxurdjyh8EebuRxS+CnPzIwrnqc221Nt+Ojuqb6FuSeljiC+mvnUY9Eut9/emvvVW03OiRG+YhDP99D7LsIGxf/4pBveX3//7IsStNbDXX4w6hri5qHhu0Cr2erZtPzSovHocxxDP2Tne7HwcxukxiKIWQNv4YRCv7/XRfov2vSDD8GT1QT8Lcndl4nwkeD77vCM5nM7gN9yFD37DXfjgN9yFn/aUu3sXfm7XgXItop82yc3sfG6Sm9n5duecsvNxW6pbK9DjQa+vQI/jR6rurkAf93MdtXxlYx8kHz6CdAzi2C7sOSLpZ0EGOSo2x+cfER+Pl7ep+OI4BN8wkPHDk+FK9IPHOJzM+GNPpmEmsW9i8ttxEP2xx9EdX8p4nI6jvXocX4S4Mx0Z9PI0IMqPP38ssE1H9tcTfhti7eV1yWOIe+uSzG9YlzwGubkuOY7fhLq7Lnn8tMS9dcnxht3+xutbqY3Xd/sbb9jtb7y+2994x25/4w27/Z1Hx711yXF6rnF3XfK0wdXtdcljkLvrkuettm6uSx6P5O665Gl3qW+sS57D3F6X/CLM3XXJY8vcXZc8Brm7Lnl+9ePWIpq019cljzHurUuO0wOse+uSo8vr65LH47jbpPKGdcnzWL29LnkOc3td8oswd9clj1Obe+uS59nRnXVJOpXU3bxVlDdUXg15R+XV41jxVG/Vtr1R6TtBOlVFTG8kPwzS6x2U/uv+aB+CHPchN655vD/oEIRenoQfQ9x86fLxhkn4McjdSbi+ozjguBe6Ot7r8cfnPXOauxL2RH7O1favO9t3gtSLqM9lSvphEK+3nX59/+RDkKHjDWnguJ/f7ZrF05Go4OKnop938enVDasXOLvvDv7YJtbe0Sb9Hatop+swbgzaY3v9i74VxOsOpT3482E/3vHW1XjHW1d0fMtPrFL9k/XTdaPj6dyejh83fZX6pmiX7Xw+bvo6znUcTXC/9PnNn79hacBfXxrw15cG/A1LA/760oC/Y2nAX18a+GJ01BBjO9yYHJ+VkmHHw2E/jfF4OcZWUb4vGn8vRnVu28s3P8Y4PcC6+VmDL2LcWm45n0vHIOvqr8f44RhrPLALnH/at881mePuwpigGZ9sdzoSq6fHzbQdjuT1r1Z8FeQN/WvYt+jg3bXW9flKGPZepf3G5nvtWu+DNP98pM3vDL26vvGM8YbCq/OR3Fzh+GIWUU+OSPzRPptFPOiLKG2LYj+KcvPJj73+BT96nF/GujWLmJ9BeHUacY5xbx4xP8Hw8kTiGcRfnUnMfa9en0p8o28Ojxns9Q/50YNfT4xk+obnDMcgd58z2Bs+5nc+krvPGc53JLefM3xxY3P3AcHxlO4+IDgGufuAwOT1XP/6lxLPMe49IKBH669fQZu84wraXn9GcO7dm88IzsP19jOCc5jbzwi+CHP3GcEXK1nYvk/3fTc+zgr68eVZwaa3zyifrnMcP3KxD336vOKXTkdiow7EH4eXIp/nc3pm8agsqY+9aT8cyGkla38ncnutmYW+EcSqzPW59PL4PMjjtA/ge6KQYlVtf4/3m1HMUKQ6Ds3yOL2lZfUUxvbnBd+KMTqqsfyHMdb0Y53Nvsfq/0+UU4K7V6RKpy8pERk+wUq/7Cf2+O1YTp+1zgy3vXje23ea9YHKwR93Ta0jDZPXu/cU4+i+Vo+UnmamHwZBtd0z3mnAnzaMvztEjkEIH0GjfT/Q7x0KkWJjYZefRmm1jkP7FwG+GUWwX7ts+7V/N4rifmWb4n/3jB4VpfHxjMbrme0U425mOz5ru53Z7A8ftq3XtKuJ/bRRbualY4ybeelm55xiHJ+W36vrOD9wv1fX8Xj5KM57gt06ivN+kbg9/8W739p0UrFzpY72wyCORD+2jQm/uXMlPnLy4M9Px053O3e3vzwGuff583OIW58//yLEvc+fj+Mzy461l8cPO/eXIP2nQRhB2mGYPcbL22B/FePOKwDPGP2PjXFzNfncqNgjxfbbku/1TK02so2fZpH9SH4cxOuB0BN/HKRmEecgx72j7+X38/bTd/L7F3vYV8XBoP7DbfDrQd0Tx6cDlV+/1vGrbXH+4kPtPCX2y66A34iBzyyIy+NnMUZVdD7xh1+ecMNx/PQLGF5PcZ/hfvoFjO0JQf9xezhifN4vx6+K4KXoLoPfEONnXybpqHrqe9XTt2JY7RrX7TDGTivpNmpa54/HYRmPTo+zutbrlF2HfLpC+sWR3FtQpNOLWfcWFE/1aHfXE+0dC4F0eqnqPVFuLyeeo9xdTqTT+1k3b7qPMW7edNN5l8ObN93H3UHv3nSfG3ZgNWPw5w3r/A4Tt/a6if0dTwWO+0feM7G/4aGAv+OZADX/o6PcN3F7xzOB4+Ojuyburz8TOMa4b+L+hmcC54a9aeLjt8oe9YqI/PrliI/LTacNAoW95oy8z/f8Y5DTdvhWLau2fzbJv3E2VUkl9ODD2Zz2Gbx9NqcHFO84GxS6PvFns0ZpldSkdf1ZDMZxsL0hhj9+eC5VTyKNxg+PA5/DaI8ft+lAm8oPY3TE0Hby3etP484x7q16302shxj+hodx/o5ncfEC18up+RTk9rO4L6LcfBZ3jnL3Wdw5yt1ncV9Eufks7oszuvksjk5Pr+7OKE4x7s4ojN8xo7A/fNjefRZ3bpSbWekY42ZWutk5xxjH+76b53KMcfNcbt5/HmIcVwduZtjzKsXdDOvvGKr+lgzrb8mw/pYM62/JsP6WDOtvybDjDRl2vCHDjrdk2PGHD9vbGXa8IcOON2TY8XKGPX4Xtun2CfJt48QPn6m/H0N/GKPqZNtu4W/F6Hi637cHwN+L0fAS3fbI9HsxqB7d9v17Hd+KofjQvR6O41Rk5Irv5J769hhj4Duq+/6r34qBTU/Hg1+PQT8+DkMM/VmMgYvE6Pb6cfTDWOc39C2/oW/5DX3Lb+hbfkPf8hv6ll/v29Pi5HPtumaKLPsD8d82gHy9kOWLGLeKUJj7HxvjXiHLsU0bPnzc7HFq0+PHXG98QvV4GB2VMH2fqf5+GOP1BVI+fuXu3gLp8WwE+2oLy6dnc45R5SO87/TyMYaePmnBghcARR4/C3KvJO8c4lZJ3hch7pTk9ZerafrLxTSnl8ruHcMxwq1j+GLjyO2rdo/9Ivnh2eYXUfDmxzNK+zSKHq8Lj9iS7gpDpj8Lc3OMHkPcG6PnEHfG6HE5pVUG+2XT6CbtGzHqTvsZgz6N0fQdY+SLKHfHSH/PGOmvj5H++hjpPxsj//35H3/+17/+41/+9m//+ud//+u//f3/Pv/uv2aof/z1z//jb3+5/vN//cff/3X7f//9//0/+f/8j3/89W9/++v//pf/849/+9e//M//+MdfZqT5//3pcf3PfxvzPv85Qtp//6c/tfhvnf9t/fnftH7hOdl7/o/Mf6D4h+fy7vN/7L//1zzE/w8="}],"outputs":{"structs":{"events":[{"kind":"struct","path":"HatNFT::HatMinted","fields":[{"name":"token_id","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"owner","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"game_id","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"hat_type","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"hat_quality","type":{"kind":"integer","sign":"unsigned","width":8}}]},{"kind":"struct","path":"HatNFT::HatTransferred","fields":[{"name":"token_id","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"from","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"to","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}],"functions":[{"kind":"struct","path":"HatNFT::constructor_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"HatNFT::constructor_parameters","fields":[{"name":"_chess_contract","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]},{"kind":"struct","path":"HatNFT::exists_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"HatNFT::exists_parameters","fields":[{"name":"_token_id","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"return_type","type":{"kind":"boolean"}}]},{"kind":"struct","path":"HatNFT::get_hat_metadata_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"HatNFT::get_hat_metadata_parameters","fields":[{"name":"_token_id","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"return_type","type":{"kind":"tuple","fields":[{"kind":"integer","sign":"unsigned","width":32},{"kind":"integer","sign":"unsigned","width":8},{"kind":"integer","sign":"unsigned","width":8}]}}]},{"kind":"struct","path":"HatNFT::get_minter_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"HatNFT::get_minter_parameters","fields":[]}},{"name":"return_type","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]},{"kind":"struct","path":"HatNFT::mint_hat_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"HatNFT::mint_hat_parameters","fields":[{"name":"_to","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"_game_id","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"_winner_elo","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"_loser_elo","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]},{"kind":"struct","path":"HatNFT::owner_of_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"HatNFT::owner_of_parameters","fields":[{"name":"_token_id","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"return_type","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]},{"kind":"struct","path":"HatNFT::process_message_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"HatNFT::process_message_parameters","fields":[{"name":"message_ciphertext","type":{"kind":"struct","path":"std::collections::bounded_vec::BoundedVec","fields":[{"name":"storage","type":{"kind":"array","length":17,"type":{"kind":"field"}}},{"name":"len","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"message_context","type":{"kind":"struct","path":"aztec::messages::processing::message_context::MessageContext","fields":[{"name":"tx_hash","type":{"kind":"field"}},{"name":"unique_note_hashes_in_tx","type":{"kind":"struct","path":"std::collections::bounded_vec::BoundedVec","fields":[{"name":"storage","type":{"kind":"array","length":64,"type":{"kind":"field"}}},{"name":"len","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"first_nullifier_in_tx","type":{"kind":"field"}},{"name":"recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]}}]},{"kind":"struct","path":"HatNFT::sync_private_state_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"HatNFT::sync_private_state_parameters","fields":[]}}]},{"kind":"struct","path":"HatNFT::total_supply_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"HatNFT::total_supply_parameters","fields":[]}},{"name":"return_type","type":{"kind":"integer","sign":"unsigned","width":32}}]},{"kind":"struct","path":"HatNFT::transfer_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"HatNFT::transfer_parameters","fields":[{"name":"_from","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"_to","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"_token_id","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}]},"globals":{"storage":[{"kind":"struct","fields":[{"name":"contract_name","value":{"kind":"string","value":"HatNFT"}},{"name":"fields","value":{"kind":"struct","fields":[{"name":"token_counter","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}]}},{"name":"public_owners","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}}]}},{"name":"nft_exists","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000003"}}]}},{"name":"hat_game_ids","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000004"}}]}},{"name":"hat_types","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000005"}}]}},{"name":"hat_qualities","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000006"}}]}},{"name":"minter","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000007"}}]}}]}}]}]}},"file_map":{"3":{"source":"use crate::cmp::{Eq, Ord};\nuse crate::convert::From;\nuse crate::runtime::is_unconstrained;\n\nmod check_shuffle;\nmod quicksort;\n\nimpl<T, let N: u32> [T; N] {\n    /// Returns the length of this array.\n    ///\n    /// ```noir\n    /// fn len(self) -> Field\n    /// ```\n    ///\n    /// example\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let array = [42, 42];\n    ///     assert(array.len() == 2);\n    /// }\n    /// ```\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Returns this array as a vector.\n    ///\n    /// ```noir\n    /// let array = [1, 2];\n    /// let vector = array.as_vector();\n    /// assert_eq(vector, [1, 2].as_vector());\n    /// ```\n    #[builtin(as_vector)]\n    pub fn as_vector(self) -> [T] {}\n\n    /// Returns this array as a vector.\n    /// This method is deprecated in favor of `as_vector`.\n    ///\n    /// ```noir\n    /// let array = [1, 2];\n    /// let vector = array.as_slice();\n    /// assert_eq(vector, [1, 2].as_vector());\n    /// ```\n    #[builtin(as_vector)]\n    #[deprecated(\"This method has been renamed to `as_vector`\")]\n    pub fn as_slice(self) -> [T] {}\n\n    /// Applies a function to each element of this array, returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.map(|a| a * 2);\n    /// assert_eq(b, [2, 4, 6]);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array along with its index,\n    /// returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.mapi(|i, a| i + a * 2);\n    /// assert_eq(b, [2, 5, 8]);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(i, self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// let mut i = 0;\n    /// a.for_each(|x| {\n    ///     b[i] = x;\n    ///     i += 1;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for i in 0..self.len() {\n            f(self[i]);\n        }\n    }\n\n    /// Applies a function to each element of this array along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// a.for_eachi(|i, x| {\n    ///     b[i] = x;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        for i in 0..self.len() {\n            f(i, self[i]);\n        }\n    }\n\n    /// Applies a function to each element of the array, returning the final accumulated value. The first\n    /// parameter is the initial value.\n    ///\n    /// This is a left fold, so the given function will be applied to the accumulator and first element of\n    /// the array, then the second, and so on. For a given call the expected result would be equivalent to:\n    ///\n    /// ```rust\n    /// let a1 = [1];\n    /// let a2 = [1, 2];\n    /// let a3 = [1, 2, 3];\n    ///\n    /// let f = |a, b| a - b;\n    /// a1.fold(10, f); //=> f(10, 1)\n    /// a2.fold(10, f); //=> f(f(10, 1), 2)\n    /// a3.fold(10, f); //=> f(f(f(10, 1), 2), 3)\n    ///\n    /// assert_eq(a3.fold(10, f), 10 - 1 - 2 - 3);\n    /// ```\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    /// Same as fold, but uses the first element as the starting element.\n    ///\n    /// Requires the input array to be non-empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [1, 2, 3, 4];\n    ///     let reduced = arr.reduce(|a, b| a + b);\n    ///     assert(reduced == 10);\n    /// }\n    /// ```\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    /// Returns true if all the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 2];\n    ///     let all = arr.all(|a| a == 2);\n    ///     assert(all);\n    /// }\n    /// ```\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    /// Returns true if any of the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 5];\n    ///     let any = arr.any(|a| a == 5);\n    ///     assert(any);\n    /// }\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n\n    /// Concatenates this array with another array.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr1 = [1, 2, 3, 4];\n    ///     let arr2 = [6, 7, 8, 9, 10, 11];\n    ///     let concatenated_arr = arr1.concat(arr2);\n    ///     assert(concatenated_arr == [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    /// }\n    /// ```\n    pub fn concat<let M: u32>(self, array2: [T; M]) -> [T; N + M] {\n        let mut result = [crate::mem::zeroed(); N + M];\n        for i in 0..N {\n            result[i] = self[i];\n        }\n        for i in 0..M {\n            result[i + N] = array2[i];\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Ord + Eq,\n{\n    /// Returns a new sorted array. The original array remains untouched. Notice that this function will\n    /// only work for arrays of fields or integers, not for any arbitrary type. This is because the sorting\n    /// logic it uses internally is optimized specifically for these values. If you need a sort function to\n    /// sort any type, you should use the [`Self::sort_via`] function.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32];\n    ///     let sorted = arr.sort();\n    ///     assert(sorted == [32, 42]);\n    /// }\n    /// ```\n    pub fn sort(self) -> Self {\n        self.sort_via(|a, b| a <= b)\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Eq,\n{\n    /// Returns a new sorted array by sorting it with a custom comparison function.\n    /// The original array remains untouched.\n    /// The ordering function must return true if the first argument should be sorted to be before the second argument or is equal to the second argument.\n    ///\n    /// Using this method with an operator like `<` that does not return `true` for equal values will result in an assertion failure for arrays with equal elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32]\n    ///     let sorted_ascending = arr.sort_via(|a, b| a <= b);\n    ///     assert(sorted_ascending == [32, 42]); // verifies\n    ///\n    ///     let sorted_descending = arr.sort_via(|a, b| a >= b);\n    ///     assert(sorted_descending == [32, 42]); // does not verify\n    /// }\n    /// ```\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        // Safety: `sorted` array is checked to be:\n        // a. a permutation of `input`'s elements\n        // b. satisfying the predicate `ordering`\n        let sorted = unsafe { quicksort::quicksort(self, ordering) };\n\n        if !is_unconstrained() {\n            for i in 0..N - 1 {\n                assert(\n                    ordering(sorted[i], sorted[i + 1]),\n                    \"Array has not been sorted correctly according to `ordering`.\",\n                );\n            }\n            check_shuffle::check_shuffle(self, sorted);\n        }\n        sorted\n    }\n}\n\nimpl<let N: u32> [u8; N] {\n    /// Converts a byte array of type `[u8; N]` to a string. Note that this performs no UTF-8 validation -\n    /// the given array is interpreted as-is as a string.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let hi = [104, 105].as_str_unchecked();\n    ///     assert_eq(hi, \"hi\");\n    /// }\n    /// ```\n    #[builtin(array_as_str_unchecked)]\n    pub fn as_str_unchecked(self) -> str<N> {}\n}\n\nimpl<let N: u32> From<str<N>> for [u8; N] {\n    /// Returns an array of the string bytes.\n    fn from(s: str<N>) -> Self {\n        s.as_bytes()\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq([].map(|x| x + 1), []);\n    }\n\n    global arr_with_100_values: [u32; 100] = [\n        42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2, 54,\n        89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41, 19, 98,\n        53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21, 43, 86, 35,\n        21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15, 127, 81, 30, 8,\n        125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n    ];\n    global expected_with_100_values: [u32; 100] = [\n        0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30, 32,\n        32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58, 61, 62,\n        62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82, 84, 84, 86,\n        86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114, 114, 116, 118,\n        119, 120, 121, 123, 123, 123, 125, 126, 127,\n    ];\n    fn sort_u32(a: u32, b: u32) -> bool {\n        a <= b\n    }\n\n    #[test]\n    fn test_sort() {\n        let mut arr: [u32; 7] = [3, 6, 8, 10, 1, 2, 1];\n\n        let sorted = arr.sort();\n\n        let expected: [u32; 7] = [1, 1, 2, 3, 6, 8, 10];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_100_values() {\n        let mut arr: [u32; 100] = [\n            42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2,\n            54, 89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41,\n            19, 98, 53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21,\n            43, 86, 35, 21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15,\n            127, 81, 30, 8, 125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n        ];\n\n        let sorted = arr.sort();\n\n        let expected: [u32; 100] = [\n            0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30,\n            32, 32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58,\n            61, 62, 62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82,\n            84, 84, 86, 86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114,\n            114, 116, 118, 119, 120, 121, 123, 123, 123, 125, 126, 127,\n        ];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_100_values_comptime() {\n        let sorted = arr_with_100_values.sort();\n        assert(sorted == expected_with_100_values);\n    }\n\n    #[test]\n    fn test_sort_via() {\n        let mut arr: [u32; 7] = [3, 6, 8, 10, 1, 2, 1];\n\n        let sorted = arr.sort_via(sort_u32);\n\n        let expected: [u32; 7] = [1, 1, 2, 3, 6, 8, 10];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_via_100_values() {\n        let mut arr: [u32; 100] = [\n            42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2,\n            54, 89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41,\n            19, 98, 53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21,\n            43, 86, 35, 21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15,\n            127, 81, 30, 8, 125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n        ];\n\n        let sorted = arr.sort_via(sort_u32);\n\n        let expected: [u32; 100] = [\n            0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30,\n            32, 32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58,\n            61, 62, 62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82,\n            84, 84, 86, 86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114,\n            114, 116, 118, 119, 120, 121, 123, 123, 123, 125, 126, 127,\n        ];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq([].mapi(|i, x| i * x + 1), []);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_each(|_x| assert(false));\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_eachi(|_i, _x| assert(false));\n    }\n\n    #[test]\n    fn map_example() {\n        let a = [1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, [2, 4, 6]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = [1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        let mut i = 0;\n        let i_ref = &mut i;\n        a.for_each(|x| {\n            b_ref[*i_ref] = x * 2;\n            *i_ref += 1;\n        });\n        assert_eq(b, [2, 4, 6]);\n        assert_eq(i, 3);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { b_ref[i] = i + a * 2; });\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn concat() {\n        let arr1 = [1, 2, 3, 4];\n        let arr2 = [6, 7, 8, 9, 10, 11];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    }\n\n    #[test]\n    fn concat_zero_length_with_something() {\n        let arr1 = [];\n        let arr2 = [1];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_something_with_zero_length() {\n        let arr1 = [1];\n        let arr2 = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_zero_lengths() {\n        let arr1: [Field; 0] = [];\n        let arr2: [Field; 0] = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, []);\n    }\n}\n","path":"std/array/mod.nr"},"5":{"source":"use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { $crate::cmp::Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        if result {\n            for i in 0..self.len() {\n                result &= self[i].eq(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let name = quote { $crate::cmp::Ord };\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> $crate::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == $crate::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = $crate::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, name, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let self_len = self.len();\n        let other_len = other.len();\n        let min_len = if self_len < other_len {\n            self_len\n        } else {\n            other_len\n        };\n\n        let mut result = Ordering::equal();\n        for i in 0..min_len {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self_len.cmp(other_len)\n        }\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use super::{Eq, max, min, Ord};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0_u64, 1), 0);\n        assert_eq(min(0_u64, 0), 0);\n        assert_eq(min(1_u64, 1), 1);\n        assert_eq(min(255_u8, 0), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0_u64, 1), 1);\n        assert_eq(max(0_u64, 0), 0);\n        assert_eq(max(1_u64, 1), 1);\n        assert_eq(max(255_u8, 0), 255);\n    }\n\n    #[test]\n    fn correctly_handles_unequal_length_vectors() {\n        let vector_1 = [0, 1, 2, 3].as_vector();\n        let vector_2 = [0, 1, 2].as_vector();\n        assert(!vector_1.eq(vector_2));\n    }\n\n    #[test]\n    fn lexicographic_ordering_for_vectors() {\n        assert(\n            [2_u32].as_vector().cmp([1_u32, 1_u32, 1_u32].as_vector())\n                == super::Ordering::greater(),\n        );\n        assert(\n            [1_u32, 2_u32].as_vector().cmp([1_u32, 2_u32, 3_u32].as_vector())\n                == super::Ordering::less(),\n        );\n    }\n}\n","path":"std/cmp.nr"},"6":{"source":"use crate::{cmp::Eq, convert::From, runtime::is_unconstrained, static_assert};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a built-in vector except that it\n/// is bounded with a maximum possible length. `BoundedVec` is also not\n/// subject to the same restrictions vectors are (notably, nested vectors are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over vectors when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given vector to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_vector([2, 4].as_vector());\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_vector(&mut self, vector: [T]) {\n        let new_len = self.len + vector.len();\n        assert(new_len <= MaxLen, \"extend_from_vector out of bounds\");\n        for i in 0..vector.len() {\n            self.storage[self.len + i] = vector[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        if is_unconstrained() {\n            for i in 0..append_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        } else {\n            for i in 0..Len {\n                if i < append_len {\n                    self.storage[self.len + i] = vec.get_unchecked(i);\n                }\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        static_assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0, \"cannot pop from an empty vector\");\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        if is_unconstrained() {\n            for i in 0..self.len {\n                ret |= predicate(self.storage[i]);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..MaxLen {\n                exceeded_len |= i == self.len;\n                if !exceeded_len {\n                    ret |= predicate(self.storage[i]);\n                }\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element\n    /// in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.mapi(|i, value| i + value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(i, self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Calls a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_each(|value| result.push(value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Calls a closure on each element in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_eachi(|i, value| result.push(i + value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(i, self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use [`from_parts_unchecked`][Self::from_parts_unchecked] to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n\n        if is_unconstrained() {\n            for i in len..MaxLen {\n                array[i] = zeroed;\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i >= len {\n                    array[i] = zeroed;\n                }\n            }\n        }\n\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            let _ = vec.get(0);\n        }\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_beyond_length() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            let _ = vec.get(3);\n        }\n\n        #[test]\n        fn get_works_within_bounds() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(2), 3);\n            assert_eq(vec.get(4), 5);\n        }\n\n        #[test]\n        fn get_unchecked_works() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            assert_eq(vec.get_unchecked(0), 1);\n            assert_eq(vec.get_unchecked(2), 3);\n        }\n\n        #[test]\n        fn get_unchecked_works_past_len() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            assert_eq(vec.get_unchecked(4), 0);\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_setting_beyond_length() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            vec.set(3, 4);\n        }\n\n        #[test]\n        fn set_unchecked_operations() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n\n            vec.set_unchecked(0, 10);\n            assert_eq(vec.get(0), 10);\n        }\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn set_unchecked_operations_past_len() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n\n            vec.set_unchecked(3, 40);\n            assert_eq(vec.get(3), 40);\n        }\n\n        #[test]\n        fn set_preserves_other_elements() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n\n            vec.set(2, 30);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 30);\n            assert_eq(vec.get(3), 4);\n            assert_eq(vec.get(4), 5);\n        }\n    }\n\n    mod any {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn returns_false_if_predicate_not_satisfied() {\n            let vec: BoundedVec<bool, 4> = BoundedVec::from_array([false, false, false, false]);\n            let result = vec.any(|value| value);\n\n            assert(!result);\n        }\n\n        #[test]\n        fn returns_true_if_predicate_satisfied() {\n            let vec: BoundedVec<bool, 4> = BoundedVec::from_array([false, false, true, true]);\n            let result = vec.any(|value| value);\n\n            assert(result);\n        }\n\n        #[test]\n        fn returns_false_on_empty_boundedvec() {\n            let vec: BoundedVec<bool, 0> = BoundedVec::new();\n            let result = vec.any(|value| value);\n\n            assert(!result);\n        }\n\n        #[test]\n        fn any_with_complex_predicates() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n\n            assert(vec.any(|x| x > 3));\n            assert(!vec.any(|x| x > 10));\n            assert(vec.any(|x| x % 2 == 0)); // has a even number\n            assert(vec.any(|x| x == 3)); // has a specific value\n        }\n\n        #[test]\n        fn any_with_partial_vector() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n\n            assert(vec.any(|x| x == 1));\n            assert(vec.any(|x| x == 2));\n            assert(!vec.any(|x| x == 3));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn map_with_conditional_logic() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n\n            let result = vec.map(|x| if x % 2 == 0 { x * 2 } else { x });\n            let expected = BoundedVec::from_array([1, 4, 3, 8]);\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn map_preserves_length() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|x| x * 2);\n\n            assert_eq(result.len(), vec.len());\n            assert_eq(result.max_len(), vec.max_len());\n        }\n\n        #[test]\n        fn map_on_empty_vector() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let result = vec.map(|x| x * 2);\n            assert_eq(result, vec);\n            assert_eq(result.len(), 0);\n            assert_eq(result.max_len(), 5);\n        }\n    }\n\n    mod mapi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-mapi-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| i + value * 2);\n            // docs:end:bounded-vec-mapi-example\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.mapi(|_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn mapi_with_index_branching_logic() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n\n            let result = vec.mapi(|i, x| if i % 2 == 0 { x * 2 } else { x });\n            let expected = BoundedVec::from_array([2, 2, 6, 4]);\n            assert_eq(result, expected);\n        }\n    }\n\n    mod for_each {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // map in terms of for_each\n        fn for_each_map<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_each(|x| output_ref.push(f(x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-each-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_each(|value| { *acc_ref += value; });\n            // docs:end:bounded-vec-for-each-example\n            assert_eq(acc, 6);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| value * 2);\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_each_map(vec, |value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn for_each_on_empty_vector() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let mut count = 0;\n            let count_ref = &mut count;\n            vec.for_each(|_| { *count_ref += 1; });\n            assert_eq(count, 0);\n        }\n\n        #[test]\n        fn for_each_with_side_effects() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            let mut seen = BoundedVec::<u32, 3>::new();\n            let seen_ref = &mut seen;\n            vec.for_each(|x| seen_ref.push(x));\n            assert_eq(seen, vec);\n        }\n    }\n\n    mod for_eachi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // mapi in terms of for_eachi\n        fn for_eachi_mapi<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](u32, T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_eachi(|i, x| output_ref.push(f(i, x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-eachi-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_eachi(|i, value| { *acc_ref += i * value; });\n            // docs:end:bounded-vec-for-eachi-example\n\n            // 0 * 1 + 1 * 2 + 2 * 3\n            assert_eq(acc, 8);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| i + value * 2);\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_eachi_mapi(vec, |_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn for_eachi_on_empty_vector() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let mut count = 0;\n            let count_ref = &mut count;\n            vec.for_eachi(|_, _| { *count_ref += 1; });\n            assert_eq(count, 0);\n        }\n\n        #[test]\n        fn for_eachi_with_index_tracking() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([10, 20, 30]);\n            let mut indices = BoundedVec::<u32, 3>::new();\n            let indices_ref = &mut indices;\n            vec.for_eachi(|i, _| indices_ref.push(i));\n\n            let expected = BoundedVec::from_array([0, 1, 2]);\n            assert_eq(indices, expected);\n        }\n\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n\n        #[test]\n        fn from_array_preserves_order() {\n            let array = [5, 3, 1, 4, 2];\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array(array);\n            for i in 0..array.len() {\n                assert_eq(vec.get(i), array[i]);\n            }\n        }\n\n        #[test]\n        fn from_array_with_different_types() {\n            let bool_array = [true, false, true];\n            let bool_vec: BoundedVec<bool, 3> = BoundedVec::from_array(bool_array);\n            assert_eq(bool_vec.len(), 3);\n            assert_eq(bool_vec.get(0), true);\n            assert_eq(bool_vec.get(1), false);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n        use crate::convert::From;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n\n    mod push_pop {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn push_and_pop_operations() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n\n            assert_eq(vec.len(), 0);\n\n            vec.push(1);\n            assert_eq(vec.len(), 1);\n            assert_eq(vec.get(0), 1);\n\n            vec.push(2);\n            assert_eq(vec.len(), 2);\n            assert_eq(vec.get(1), 2);\n\n            let popped = vec.pop();\n            assert_eq(popped, 2);\n            assert_eq(vec.len(), 1);\n\n            let popped2 = vec.pop();\n            assert_eq(popped2, 1);\n            assert_eq(vec.len(), 0);\n        }\n\n        #[test(should_fail_with = \"push out of bounds\")]\n        fn push_to_full_vector() {\n            let mut vec: BoundedVec<u32, 2> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n            vec.push(3); // should panic\n        }\n\n        #[test(should_fail_with = \"cannot pop from an empty vector\")]\n        fn pop_from_empty_vector() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let _ = vec.pop(); // should panic\n        }\n\n        #[test]\n        fn push_pop_cycle() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n\n            // push to full\n            vec.push(1);\n            vec.push(2);\n            vec.push(3);\n            assert_eq(vec.len(), 3);\n\n            // pop all\n            assert_eq(vec.pop(), 3);\n            assert_eq(vec.pop(), 2);\n            assert_eq(vec.pop(), 1);\n            assert_eq(vec.len(), 0);\n\n            // push again\n            vec.push(4);\n            assert_eq(vec.len(), 1);\n            assert_eq(vec.get(0), 4);\n        }\n    }\n\n    mod extend {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn extend_from_array() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_array([2, 3]);\n\n            assert_eq(vec.len(), 3);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 3);\n        }\n\n        #[test]\n        fn extend_from_vector() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_vector([2, 3].as_vector());\n\n            assert_eq(vec.len(), 3);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 3);\n        }\n\n        #[test]\n        fn extend_from_bounded_vec() {\n            let mut vec1: BoundedVec<u32, 5> = BoundedVec::new();\n            let mut vec2: BoundedVec<u32, 3> = BoundedVec::new();\n\n            vec1.push(1);\n            vec2.push(2);\n            vec2.push(3);\n\n            vec1.extend_from_bounded_vec(vec2);\n\n            assert_eq(vec1.len(), 3);\n            assert_eq(vec1.get(0), 1);\n            assert_eq(vec1.get(1), 2);\n            assert_eq(vec1.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"extend_from_array out of bounds\")]\n        fn extend_array_beyond_max_len() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_array([2, 3, 4]); // should panic\n        }\n\n        #[test(should_fail_with = \"extend_from_vector out of bounds\")]\n        fn extend_vector_beyond_max_len() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_vector([2, 3, 4].as_vector()); // S]should panic\n        }\n\n        #[test(should_fail_with = \"extend_from_bounded_vec out of bounds\")]\n        fn extend_bounded_vec_beyond_max_len() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n            let other: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n            vec.extend_from_bounded_vec(other); // should panic\n        }\n\n        #[test]\n        fn extend_with_empty_collections() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let original_len = vec.len();\n\n            vec.extend_from_array([]);\n            assert_eq(vec.len(), original_len);\n\n            vec.extend_from_vector([].as_vector());\n            assert_eq(vec.len(), original_len);\n\n            let empty: BoundedVec<u32, 3> = BoundedVec::new();\n            vec.extend_from_bounded_vec(empty);\n            assert_eq(vec.len(), original_len);\n        }\n    }\n\n    mod storage {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn storage_consistency() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n\n            // test initial storage state\n            assert_eq(vec.storage(), [0, 0, 0, 0, 0]);\n\n            vec.push(1);\n            vec.push(2);\n\n            // test storage after modifications\n            assert_eq(vec.storage(), [1, 2, 0, 0, 0]);\n\n            // storage doesn't change length\n            assert_eq(vec.len(), 2);\n            assert_eq(vec.max_len(), 5);\n        }\n\n        #[test]\n        fn storage_after_pop() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n\n            let _ = vec.pop();\n            // after pop, the last element should be zeroed\n            assert_eq(vec.storage(), [1, 2, 0]);\n            assert_eq(vec.len(), 2);\n        }\n\n        #[test]\n        fn vector_immutable() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            let storage = vec.storage();\n\n            assert_eq(storage, [1, 2, 3]);\n\n            // Verify that the original vector is unchanged\n            assert_eq(vec.len(), 3);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 3);\n        }\n    }\n}\n","path":"std/collections/bounded_vec.nr"},"17":{"source":"use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\npub(crate) global PLO: Field = 53438638232309528389504892708671455233;\npub(crate) global PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n\n    #[test]\n    fn check_decompose_edge_cases() {\n        assert_eq(decompose(0), (0, 0));\n        assert_eq(decompose(TWO_POW_128 - 1), (TWO_POW_128 - 1, 0));\n        assert_eq(decompose(TWO_POW_128 + 1), (1, 1));\n        assert_eq(decompose(TWO_POW_128 * 2), (0, 2));\n        assert_eq(decompose(TWO_POW_128 * 2 + 0x1234567890), (0x1234567890, 2));\n    }\n\n    #[test]\n    fn check_decompose_large_values() {\n        let large_field = 0xffffffffffffffff;\n        let (lo, hi) = decompose(large_field);\n        assert_eq(large_field, lo + TWO_POW_128 * hi);\n\n        let large_value = large_field - TWO_POW_128;\n        let (lo2, hi2) = decompose(large_value);\n        assert_eq(large_value, lo2 + TWO_POW_128 * hi2);\n    }\n\n    #[test]\n    fn check_lt_comprehensive() {\n        assert(lt(0, 1));\n        assert(!lt(1, 0));\n        assert(!lt(0, 0));\n        assert(!lt(42, 42));\n\n        assert(lt(TWO_POW_128 - 1, TWO_POW_128));\n        assert(!lt(TWO_POW_128, TWO_POW_128 - 1));\n    }\n}\n","path":"std/field/bn254.nr"},"18":{"source":"pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        __assert_max_bit_size(self, BIT_SIZE);\n    }\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting array will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = __to_le_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting array will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = __to_be_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_le_radix(self, radix)\n    }\n\n    fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_be_radix(self, radix)\n    }\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(apply_range_constraint)]\nfn __assert_max_bit_size(value: Field, bit_size: u32) {}\n\n// `_radix` must be less than 256\n#[builtin(to_le_radix)]\nfn __to_le_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n// `_radix` must be less than 256\n#[builtin(to_be_radix)]\nfn __to_be_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n/// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n/// This array will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting array will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_le_bits)]\nfn __to_le_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n/// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n/// This array will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting array will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_be_bits)]\nfn __to_be_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime, static_assert};\n    use super::{\n        field_less_than, modulus_be_bits, modulus_be_bytes, modulus_le_bits, modulus_le_bytes,\n    };\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(\"radix must be greater than 1\");\n        }\n    }\n\n    // Updated test to account for Brillig restriction that radix must be greater than 2\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_brillig_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 1;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(\"radix must be greater than 1\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(\"radix must be less than or equal to 256\")\n        }\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    unconstrained fn not_enough_limbs_brillig() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    fn not_enough_limbs() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n\n    #[test]\n    unconstrained fn test_large_field_values_unconstrained() {\n        let large_field = 0xffffffffffffffff;\n\n        let bits: [u1; 64] = large_field.to_le_bits();\n        assert_eq(bits[0], 1);\n\n        let bytes: [u8; 8] = large_field.to_le_bytes();\n        assert_eq(Field::from_le_bytes::<8>(bytes), large_field);\n\n        let radix_bytes: [u8; 8] = large_field.to_le_radix(256);\n        assert_eq(Field::from_le_bytes::<8>(radix_bytes), large_field);\n    }\n\n    #[test]\n    fn test_large_field_values() {\n        let large_val = 0xffffffffffffffff;\n\n        let bits: [u1; 64] = large_val.to_le_bits();\n        assert_eq(bits[0], 1);\n\n        let bytes: [u8; 8] = large_val.to_le_bytes();\n        assert_eq(Field::from_le_bytes::<8>(bytes), large_val);\n\n        let radix_bytes: [u8; 8] = large_val.to_le_radix(256);\n        assert_eq(Field::from_le_bytes::<8>(radix_bytes), large_val);\n    }\n\n    #[test]\n    fn test_decomposition_edge_cases() {\n        let zero_bits: [u1; 8] = 0.to_le_bits();\n        assert_eq(zero_bits, [0; 8]);\n\n        let zero_bytes: [u8; 8] = 0.to_le_bytes();\n        assert_eq(zero_bytes, [0; 8]);\n\n        let one_bits: [u1; 8] = 1.to_le_bits();\n        let expected: [u1; 8] = [1, 0, 0, 0, 0, 0, 0, 0];\n        assert_eq(one_bits, expected);\n\n        let pow2_bits: [u1; 8] = 4.to_le_bits();\n        let expected: [u1; 8] = [0, 0, 1, 0, 0, 0, 0, 0];\n        assert_eq(pow2_bits, expected);\n    }\n\n    #[test]\n    fn test_pow_32() {\n        assert_eq(2.pow_32(3), 8);\n        assert_eq(3.pow_32(2), 9);\n        assert_eq(5.pow_32(0), 1);\n        assert_eq(7.pow_32(1), 7);\n\n        assert_eq(2.pow_32(10), 1024);\n\n        assert_eq(0.pow_32(5), 0);\n        assert_eq(0.pow_32(0), 1);\n\n        assert_eq(1.pow_32(100), 1);\n    }\n\n    #[test]\n    fn test_sgn0() {\n        assert_eq(0.sgn0(), 0);\n        assert_eq(2.sgn0(), 0);\n        assert_eq(4.sgn0(), 0);\n        assert_eq(100.sgn0(), 0);\n\n        assert_eq(1.sgn0(), 1);\n        assert_eq(3.sgn0(), 1);\n        assert_eq(5.sgn0(), 1);\n        assert_eq(101.sgn0(), 1);\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 8 limbs\")]\n    fn test_bit_decomposition_overflow() {\n        // 8 bits can't represent large field values\n        let large_val = 0x1000000000000000;\n        let _: [u1; 8] = large_val.to_le_bits();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 4 limbs\")]\n    fn test_byte_decomposition_overflow() {\n        // 4 bytes can't represent large field values\n        let large_val = 0x1000000000000000;\n        let _: [u8; 4] = large_val.to_le_bytes();\n    }\n\n    #[test]\n    fn test_to_from_be_bytes_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this byte produces the expected 32 BE bytes for (modulus - 1)\n            let mut p_minus_1_bytes: [u8; 32] = modulus_be_bytes().as_array();\n            assert(p_minus_1_bytes[32 - 1] > 0);\n            p_minus_1_bytes[32 - 1] -= 1;\n\n            let p_minus_1 = Field::from_be_bytes::<32>(p_minus_1_bytes);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 32 BE bytes produces the same bytes\n            let p_minus_1_converted_bytes: [u8; 32] = p_minus_1.to_be_bytes();\n            assert_eq(p_minus_1_converted_bytes, p_minus_1_bytes);\n\n            // checking that incrementing this byte produces 32 BE bytes for (modulus + 1)\n            let mut p_plus_1_bytes: [u8; 32] = modulus_be_bytes().as_array();\n            assert(p_plus_1_bytes[32 - 1] < 255);\n            p_plus_1_bytes[32 - 1] += 1;\n\n            let p_plus_1 = Field::from_be_bytes::<32>(p_plus_1_bytes);\n            assert_eq(p_plus_1, 1);\n\n            // checking that converting p_plus_1 to 32 BE bytes produces the same\n            // byte set to 1 as p_plus_1_bytes and otherwise zeroes\n            let mut p_plus_1_converted_bytes: [u8; 32] = p_plus_1.to_be_bytes();\n            assert_eq(p_plus_1_converted_bytes[32 - 1], 1);\n            p_plus_1_converted_bytes[32 - 1] = 0;\n            assert_eq(p_plus_1_converted_bytes, [0; 32]);\n\n            // checking that Field::from_be_bytes::<32> on the Field modulus produces 0\n            assert_eq(modulus_be_bytes().len(), 32);\n            let p = Field::from_be_bytes::<32>(modulus_be_bytes().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 32 BE bytes produces 32 zeroes\n            let p_bytes: [u8; 32] = 0.to_be_bytes();\n            assert_eq(p_bytes, [0; 32]);\n        }\n    }\n\n    #[test]\n    fn test_to_from_le_bytes_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this byte produces the expected 32 LE bytes for (modulus - 1)\n            let mut p_minus_1_bytes: [u8; 32] = modulus_le_bytes().as_array();\n            assert(p_minus_1_bytes[0] > 0);\n            p_minus_1_bytes[0] -= 1;\n\n            let p_minus_1 = Field::from_le_bytes::<32>(p_minus_1_bytes);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 32 BE bytes produces the same bytes\n            let p_minus_1_converted_bytes: [u8; 32] = p_minus_1.to_le_bytes();\n            assert_eq(p_minus_1_converted_bytes, p_minus_1_bytes);\n\n            // checking that incrementing this byte produces 32 LE bytes for (modulus + 1)\n            let mut p_plus_1_bytes: [u8; 32] = modulus_le_bytes().as_array();\n            assert(p_plus_1_bytes[0] < 255);\n            p_plus_1_bytes[0] += 1;\n\n            let p_plus_1 = Field::from_le_bytes::<32>(p_plus_1_bytes);\n            assert_eq(p_plus_1, 1);\n\n            // checking that converting p_plus_1 to 32 LE bytes produces the same\n            // byte set to 1 as p_plus_1_bytes and otherwise zeroes\n            let mut p_plus_1_converted_bytes: [u8; 32] = p_plus_1.to_le_bytes();\n            assert_eq(p_plus_1_converted_bytes[0], 1);\n            p_plus_1_converted_bytes[0] = 0;\n            assert_eq(p_plus_1_converted_bytes, [0; 32]);\n\n            // checking that Field::from_le_bytes::<32> on the Field modulus produces 0\n            assert_eq(modulus_le_bytes().len(), 32);\n            let p = Field::from_le_bytes::<32>(modulus_le_bytes().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 32 LE bytes produces 32 zeroes\n            let p_bytes: [u8; 32] = 0.to_le_bytes();\n            assert_eq(p_bytes, [0; 32]);\n        }\n    }\n\n    /// Convert a little endian bit array to a field element.\n    /// If the provided bit array overflows the field modulus then the Field will silently wrap around.\n    fn from_le_bits<let N: u32>(bits: [u1; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bits().len(),\n            \"N must be less than or equal to modulus_le_bits().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bits[i] as Field) * v;\n            v = v * 2;\n        }\n        result\n    }\n\n    /// Convert a big endian bit array to a field element.\n    /// If the provided bit array overflows the field modulus then the Field will silently wrap around.\n    fn from_be_bits<let N: u32>(bits: [u1; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bits[N - 1 - i] as Field) * v;\n            v = v * 2;\n        }\n        result\n    }\n\n    #[test]\n    fn test_to_from_be_bits_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this bit produces the expected 254 BE bits for (modulus - 1)\n            let mut p_minus_1_bits: [u1; 254] = modulus_be_bits().as_array();\n            assert(p_minus_1_bits[254 - 1] > 0);\n            p_minus_1_bits[254 - 1] -= 1;\n\n            let p_minus_1 = from_be_bits::<254>(p_minus_1_bits);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 254 BE bits produces the same bits\n            let p_minus_1_converted_bits: [u1; 254] = p_minus_1.to_be_bits();\n            assert_eq(p_minus_1_converted_bits, p_minus_1_bits);\n\n            // checking that incrementing this bit produces 254 BE bits for (modulus + 4)\n            let mut p_plus_4_bits: [u1; 254] = modulus_be_bits().as_array();\n            assert(p_plus_4_bits[254 - 3] < 1);\n            p_plus_4_bits[254 - 3] += 1;\n\n            let p_plus_4 = from_be_bits::<254>(p_plus_4_bits);\n            assert_eq(p_plus_4, 4);\n\n            // checking that converting p_plus_4 to 254 BE bits produces the same\n            // bit set to 1 as p_plus_4_bits and otherwise zeroes\n            let mut p_plus_4_converted_bits: [u1; 254] = p_plus_4.to_be_bits();\n            assert_eq(p_plus_4_converted_bits[254 - 3], 1);\n            p_plus_4_converted_bits[254 - 3] = 0;\n            assert_eq(p_plus_4_converted_bits, [0; 254]);\n\n            // checking that Field::from_be_bits::<254> on the Field modulus produces 0\n            assert_eq(modulus_be_bits().len(), 254);\n            let p = from_be_bits::<254>(modulus_be_bits().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 254 BE bytes produces 254 zeroes\n            let p_bits: [u1; 254] = 0.to_be_bits();\n            assert_eq(p_bits, [0; 254]);\n        }\n    }\n\n    #[test]\n    fn test_to_from_le_bits_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this bit produces the expected 254 LE bits for (modulus - 1)\n            let mut p_minus_1_bits: [u1; 254] = modulus_le_bits().as_array();\n            assert(p_minus_1_bits[0] > 0);\n            p_minus_1_bits[0] -= 1;\n\n            let p_minus_1 = from_le_bits::<254>(p_minus_1_bits);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 254 BE bits produces the same bits\n            let p_minus_1_converted_bits: [u1; 254] = p_minus_1.to_le_bits();\n            assert_eq(p_minus_1_converted_bits, p_minus_1_bits);\n\n            // checking that incrementing this bit produces 254 LE bits for (modulus + 4)\n            let mut p_plus_4_bits: [u1; 254] = modulus_le_bits().as_array();\n            assert(p_plus_4_bits[2] < 1);\n            p_plus_4_bits[2] += 1;\n\n            let p_plus_4 = from_le_bits::<254>(p_plus_4_bits);\n            assert_eq(p_plus_4, 4);\n\n            // checking that converting p_plus_4 to 254 LE bits produces the same\n            // bit set to 1 as p_plus_4_bits and otherwise zeroes\n            let mut p_plus_4_converted_bits: [u1; 254] = p_plus_4.to_le_bits();\n            assert_eq(p_plus_4_converted_bits[2], 1);\n            p_plus_4_converted_bits[2] = 0;\n            assert_eq(p_plus_4_converted_bits, [0; 254]);\n\n            // checking that Field::from_le_bits::<254> on the Field modulus produces 0\n            assert_eq(modulus_le_bits().len(), 254);\n            let p = from_le_bits::<254>(modulus_le_bits().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 254 LE bytes produces 254 zeroes\n            let p_bits: [u1; 254] = 0.to_le_bits();\n            assert_eq(p_bits, [0; 254]);\n        }\n    }\n}\n","path":"std/field/mod.nr"},"19":{"source":"// Exposed only for usage in `std::meta`\npub(crate) mod poseidon2;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\n\n#[foreign(sha256_compression)]\n// docs:start:sha256_compression\npub fn sha256_compression(input: [u32; 16], state: [u32; 8]) -> [u32; 8] {}\n// docs:end:sha256_compression\n\n#[foreign(keccakf1600)]\n// docs:start:keccakf1600\npub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {}\n// docs:end:keccakf1600\n\npub mod keccak {\n    #[deprecated(\"This function has been moved to std::hash::keccakf1600\")]\n    pub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {\n        super::keccakf1600(input)\n    }\n}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{\n    if crate::runtime::is_unconstrained() {\n        // Temporary measure while Barretenberg is main proving system.\n        // Please open an issue if you're working on another proving system and running into problems due to this.\n        crate::static_assert(\n            N <= 1024,\n            \"Barretenberg cannot prove blake3 hashes with inputs larger than 1024 bytes\",\n        );\n    }\n    __blake3(input)\n}\n\n#[foreign(blake3)]\nfn __blake3<let N: u32>(input: [u8; N]) -> [u8; 32] {}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars, true)[0].x\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Decompose the input 'bn254 scalar' into two 128 bits limbs.\n// It is called 'unsafe' because it does not assert the limbs are 128 bits\n// Assuming the limbs are 128 bits:\n// Assert the decomposition does not overflow the field size.\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    // Safety: xlo and xhi decomposition is checked below\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    // Check that the decomposition does not overflow the field size\n    let (a, b) = if xhi == crate::field::bn254::PHI {\n        (xlo, crate::field::bn254::PLO)\n    } else {\n        (xhi, crate::field::bn254::PHI)\n    };\n    crate::field::bn254::assert_lt(a, b);\n\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn poseidon2_permutation<let N: u32>(input: [Field; N], state_len: u32) -> [Field; N] {\n    assert_eq(input.len(), state_len);\n    poseidon2_permutation_internal(input)\n}\n\n#[foreign(poseidon2_permutation)]\nfn poseidon2_permutation_internal<let N: u32>(input: [Field; N]) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: TypeDefinition) -> Quoted {\n    let name = quote { $crate::hash::Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: $crate::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher {\n    type H: Hasher;\n\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    type H = H;\n\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u8 as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u16 as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u32 as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u64 as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n","path":"std/hash/mod.nr"},"42":{"source":"use crate::cmp::{Eq, Ord, Ordering};\nuse crate::default::Default;\nuse crate::hash::{Hash, Hasher};\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n","path":"std/option.nr"},"43":{"source":"pub fn panic<T, U>(message: T) -> U\nwhere\n    T: StringLike,\n{\n    assert(false, message);\n    crate::mem::zeroed()\n}\n\ntrait StringLike {}\n\nimpl<let N: u32> StringLike for str<N> {}\nimpl<let N: u32, T> StringLike for fmtstr<N, T> {}\n","path":"std/panic.nr"},"61":{"source":"use crate::oracle::capsules;\nuse protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// A dynamically sized array backed by PXE's non-volatile database (called capsules). Values are persisted until\n/// deleted, so they can be e.g. stored during simulation of a transaction and later retrieved during witness\n/// generation. All values are scoped per contract address, so external contracts cannot access them.\npub struct CapsuleArray<T> {\n    contract_address: AztecAddress,\n    /// The base slot is where the array length is stored in capsules. Array elements are stored in consecutive slots\n    /// after the base slot. For example, with base slot 5: the length is at slot 5, the first element (index 0) is at\n    /// slot 6, the second element (index 1) is at slot 7, and so on.\n    base_slot: Field,\n}\n\nimpl<T> CapsuleArray<T> {\n    /// Returns a CapsuleArray connected to a contract's capsules at a base slot. Array elements are stored in\n    /// contiguous slots following the base slot, so there should be sufficient space between array base slots to\n    /// accommodate elements. A reasonable strategy is to make the base slot a hash of a unique value.\n    pub unconstrained fn at(contract_address: AztecAddress, base_slot: Field) -> Self {\n        Self { contract_address, base_slot }\n    }\n\n    /// Returns the number of elements stored in the array.\n    pub unconstrained fn len(self) -> u32 {\n        // An uninitialized array defaults to a length of 0.\n        capsules::load(self.contract_address, self.base_slot).unwrap_or(0) as u32\n    }\n\n    /// Stores a value at the end of the array.\n    pub unconstrained fn push(self, value: T)\n    where\n        T: Serialize,\n    {\n        let current_length = self.len();\n\n        // The slot corresponding to the index `current_length` is the first slot immediately after the end of the\n        // array, which is where we want to place the new value.\n        capsules::store(self.contract_address, self.slot_at(current_length), value);\n\n        // Then we simply update the length.\n        let new_length = current_length + 1;\n        capsules::store(self.contract_address, self.base_slot, new_length);\n    }\n\n    /// Retrieves the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn get(self, index: u32) -> T\n    where\n        T: Deserialize,\n    {\n        assert(index < self.len(), \"Attempted to read past the length of a CapsuleArray\");\n\n        capsules::load(self.contract_address, self.slot_at(index)).unwrap()\n    }\n\n    /// Deletes the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn remove(self, index: u32) {\n        let current_length = self.len();\n        assert(index < current_length, \"Attempted to delete past the length of a CapsuleArray\");\n\n        // In order to be able to remove elements at arbitrary indices, we need to shift the entire contents of the\n        // array past the removed element one slot backward so that we don't end up with a gap and preserve the\n        // contiguous slots. We can skip this when deleting the last element however.\n        if index != current_length - 1 {\n            // The source and destination regions overlap, but `copy` supports this.\n            capsules::copy(\n                self.contract_address,\n                self.slot_at(index + 1),\n                self.slot_at(index),\n                current_length - index - 1,\n            );\n        }\n\n        // We can now delete the last element (which has either been copied to the slot immediately before it, or was\n        // the element we meant to delete in the first place) and update the length.\n        capsules::delete(self.contract_address, self.slot_at(current_length - 1));\n        capsules::store(self.contract_address, self.base_slot, current_length - 1);\n    }\n\n    /// Iterates over the entire array, calling the callback with all values and their array index. The order in which\n    /// values are processed is arbitrary.\n    ///\n    /// It is safe to delete the current element (and only the current element) from inside the callback via `remove`:\n    /// ```noir\n    /// array.for_each(|index, value| {\n    ///   if some_condition(value) {\n    ///     array.remove(index); // safe only for this index\n    ///   }\n    /// }\n    /// ```\n    ///\n    /// If all elements in the array need to iterated over and then removed, then using `for_each` results in optimal\n    /// efficiency.\n    ///\n    /// It is **not** safe to push new elements into the array from inside the callback.\n    pub unconstrained fn for_each<Env>(self, f: unconstrained fn[Env](u32, T) -> ())\n    where\n        T: Deserialize,\n    {\n        // Iterating over all elements is simple, but we want to do it in such a way that a) deleting the current\n        // element is safe to do, and b) deleting *all* elements is optimally efficient. This is because CapsuleArrays\n        // are typically used to hold pending tasks, so iterating them while clearing completed tasks (sometimes\n        // unconditionally, resulting in a full clear) is a very common access pattern.\n        //\n        // The way we achieve this is by iterating backwards: each element can always be deleted since it won't change\n        // any preceding (lower) indices, and if every element is deleted then every element will (in turn) be the last\n        // element. This results in an optimal full clear since `remove` will be able to skip the `capsules::copy` call\n        // to shift any elements past the deleted one (because there will be none).\n        let mut i = self.len();\n        while i > 0 {\n            i -= 1;\n            f(i, self.get(i));\n        }\n    }\n\n    unconstrained fn slot_at(self, index: u32) -> Field {\n        // Elements are stored immediately after the base slot, so we add 1 to it to compute the slot for the first\n        // element.\n        self.base_slot + 1 + index as Field\n    }\n}\n\nmod test {\n    use crate::test::helpers::test_environment::TestEnvironment;\n    use super::CapsuleArray;\n\n    global SLOT: Field = 1230;\n\n    #[test]\n    unconstrained fn empty_array() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array: CapsuleArray<Field> = CapsuleArray::at(contract_address, SLOT);\n            assert_eq(array.len(), 0);\n        });\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn empty_array_read() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n            let _: Field = array.get(0);\n        });\n    }\n\n    #[test]\n    unconstrained fn array_push() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n            array.push(5);\n\n            assert_eq(array.len(), 1);\n            assert_eq(array.get(0), 5);\n        });\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn read_past_len() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n            array.push(5);\n\n            let _ = array.get(1);\n        });\n    }\n\n    #[test]\n    unconstrained fn array_remove_last() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(5);\n            array.remove(0);\n\n            assert_eq(array.len(), 0);\n        });\n    }\n\n    #[test]\n    unconstrained fn array_remove_some() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(7);\n            array.push(8);\n            array.push(9);\n\n            assert_eq(array.len(), 3);\n            assert_eq(array.get(0), 7);\n            assert_eq(array.get(1), 8);\n            assert_eq(array.get(2), 9);\n\n            array.remove(1);\n\n            assert_eq(array.len(), 2);\n            assert_eq(array.get(0), 7);\n            assert_eq(array.get(1), 9);\n        });\n    }\n\n    #[test]\n    unconstrained fn array_remove_all() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(7);\n            array.push(8);\n            array.push(9);\n\n            array.remove(1);\n            array.remove(1);\n            array.remove(0);\n\n            assert_eq(array.len(), 0);\n        });\n    }\n\n    #[test]\n    unconstrained fn for_each_called_with_all_elements() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(4);\n            array.push(5);\n            array.push(6);\n\n            // We store all values that we were called with and check that all (value, index) tuples are present. Note that\n            // we do not care about the order in which each tuple was passed to the closure.\n            let called_with = &mut BoundedVec::<(u32, Field), 3>::new();\n            array.for_each(|index, value| { called_with.push((index, value)); });\n\n            assert_eq(called_with.len(), 3);\n            assert(called_with.any(|(index, value)| (index == 0) & (value == 4)));\n            assert(called_with.any(|(index, value)| (index == 1) & (value == 5)));\n            assert(called_with.any(|(index, value)| (index == 2) & (value == 6)));\n        });\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_some() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(4);\n            array.push(5);\n            array.push(6);\n\n            array.for_each(|index, _| {\n                if index == 1 {\n                    array.remove(index);\n                }\n            });\n\n            assert_eq(array.len(), 2);\n            assert_eq(array.get(0), 4);\n            assert_eq(array.get(1), 6);\n        });\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_all() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(4);\n            array.push(5);\n            array.push(6);\n\n            array.for_each(|index, _| { array.remove(index); });\n\n            assert_eq(array.len(), 0);\n        });\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_all_no_copy() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(4);\n            array.push(5);\n            array.push(6);\n\n            // We test that the utilityCopyCapsule was never called, which is the expensive operation we want to avoid.\n            let mock = std::test::OracleMock::mock(\"utilityCopyCapsule\");\n\n            array.for_each(|index, _| { array.remove(index); });\n\n            assert_eq(mock.times_called(), 0);\n        });\n    }\n}\n","path":"/Users/zac/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/capsules/mod.nr"},"71":{"source":"use crate::context::gas::GasOpts;\nuse crate::hash::{\n    compute_l1_to_l2_message_hash, compute_l1_to_l2_message_nullifier, compute_secret_hash,\n};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::constants::{MAX_U32_VALUE, NULL_MSG_SENDER_CONTRACT_ADDRESS};\nuse dep::protocol_types::traits::{Empty, FromField, Packable, Serialize, ToField};\n\n/// # PublicContext\n///\n/// The **main interface** between an #[external(\"public\")] function and the Aztec blockchain.\n///\n/// An instance of the PublicContext is initialized automatically at the outset\n/// of every public function, within the #[external(\"public\")] macro, so you'll never\n/// need to consciously instantiate this yourself.\n///\n/// The instance is always named `context`, and it will always be available\n/// within the body of every #[external(\"public\")] function in your smart contract.\n///\n/// Typical usage for a smart contract developer will be to call getter\n/// methods of the PublicContext.\n///\n/// _Pushing_ data and requests to the context is mostly handled within\n/// aztec-nr's own functions, so typically a smart contract developer won't\n/// need to call any setter methods directly.\n///\n/// ## Responsibilities\n/// - Exposes contextual data to a public function:\n///   - Data relating to how this public function was called:\n///     - msg_sender, this_address\n///   - Data relating to the current blockchain state:\n///     - timestamp, block_number, chain_id, version\n///   - Gas and fee information\n/// - Provides state access:\n///   - Read/write public storage (key-value mapping)\n///   - Check existence of notes and nullifiers\n///     (Some patterns use notes & nullifiers to store public (not private)\n///     information)\n///   - Enables consumption of L1->L2 messages.\n/// - Enables calls to other public smart contract functions:\n/// - Writes data to the blockchain:\n///   - Updates to public state variables\n///   - New public logs (for events)\n///   - New L2->L1 messages\n///   - New notes & nullifiers\n///     (E.g. pushing public info to notes/nullifiers, or for completing\n///     \"partial notes\")\n///\n/// ## Key Differences from Private Execution\n///\n/// Unlike private functions -- which are executed on the user's device and which\n/// can only reference historic state -- public functions are executed by a block\n/// proposer and are executed \"live\" on the _current_ tip of the chain.\n/// This means public functions can:\n/// - Read and write _current_ public state\n/// - Immediately see the effects of earlier transactions in the same block\n///\n/// Also, public functions are executed within a zkVM (the \"AVM\"), so that they\n/// can _revert_ whilst still ensuring payment to the proposer and prover.\n/// (Private functions cannot revert: they either succeed, or they cannot be\n/// included).\n///\n/// ## Optimising Public Functions\n///\n/// Using the AVM to execute public functions means they compile down to \"AVM\n/// bytecode\" instead of the ACIR that private functions (standalone circuits)\n/// compile to. Therefore the approach to optimising a public function is\n/// fundamentally different from optimising a public function.\n///\npub struct PublicContext {\n    pub args_hash: Option<Field>,\n    pub compute_args_hash: fn() -> Field,\n}\n\nimpl Eq for PublicContext {\n    fn eq(self, other: Self) -> bool {\n        (self.args_hash == other.args_hash)\n        // Can't compare the function compute_args_hash\n    }\n}\n\nimpl PublicContext {\n    /// Creates a new PublicContext instance.\n    ///\n    /// Low-level function: This is called automatically by the #[external(\"public\")]\n    /// macro, so you shouldn't need to be called directly by smart contract\n    /// developers.\n    ///\n    /// # Arguments\n    /// * `compute_args_hash` - Function to compute the args_hash\n    ///\n    /// # Returns\n    /// * A new PublicContext instance\n    ///\n    pub fn new(compute_args_hash: fn() -> Field) -> Self {\n        PublicContext { args_hash: Option::none(), compute_args_hash }\n    }\n\n    /// Emits a _public_ log that will be visible onchain to everyone.\n    ///\n    /// # Arguments\n    /// * `log` - The data to log, must implement Serialize trait\n    ///\n    pub fn emit_public_log<T>(_self: Self, log: T)\n    where\n        T: Serialize,\n    {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_public_log(Serialize::serialize(log).as_slice()) };\n    }\n\n    /// Checks if a given note hash exists in the note hash tree at a particular\n    /// leaf_index.\n    ///\n    /// # Arguments\n    /// * `note_hash` - The note hash to check for existence\n    /// * `leaf_index` - The index where the note hash should be located\n    ///\n    /// # Returns\n    /// * `bool` - True if the note hash exists at the specified index\n    ///\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: u64) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { note_hash_exists(note_hash, leaf_index) } == 1\n    }\n\n    /// Checks if a specific L1-to-L2 message exists in the L1-to-L2 message\n    /// tree at a particular leaf index.\n    ///\n    /// Common use cases include token bridging, cross-chain governance, and\n    /// triggering L2 actions based on L1 events.\n    ///\n    /// This function should be called before attempting to consume an L1-to-L2\n    /// message.\n    ///\n    /// # Arguments\n    /// * `msg_hash` - Hash of the L1-to-L2 message to check\n    /// * `msg_leaf_index` - The index where the message should be located\n    ///\n    /// # Returns\n    /// * `bool` - True if the message exists at the specified index\n    ///\n    /// # Advanced\n    /// * Uses the AVM l1_to_l2_msg_exists opcode for tree lookup\n    /// * Messages are copied from L1 Inbox to L2 by block proposers\n    ///\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        // TODO(alvaro): Make l1l2msg leaf index a u64 upstream\n        unsafe { l1_to_l2_msg_exists(msg_hash, msg_leaf_index as u64) } == 1\n    }\n\n    /// Checks if a specific nullifier has been emitted by a given contract.\n    ///\n    /// Whilst nullifiers are primarily intended as a _privacy-preserving_\n    /// record of a one-time action, they can also be used to efficiently\n    /// record _public_ one-time actions too. An example is to check\n    /// whether a contract has been published: we emit a nullifier that is\n    /// deterministic, but whose preimage is _not_ private. This is more\n    /// efficient than using mutable storage, and can be done directly\n    /// from a private function.\n    ///\n    /// Nullifiers can be tested for non-existence in public, which is not the\n    /// case in private. Because private functions do not have access to\n    /// the tip of the blockchain (but only the anchor block they are built\n    /// at) they can only prove nullifier non-existence in the past. But between\n    /// an anchor block and the block in which a tx is included, the nullifier\n    /// might have been inserted into the nullifier tree by some other\n    /// transaction.\n    /// Public functions _do_ have access to the tip of the state, and so\n    /// this pattern is safe.\n    ///\n    /// # Arguments\n    /// * `unsiloed_nullifier` - The raw nullifier value (before siloing with\n    ///                          the contract address that emitted it).\n    /// * `address` - The claimed contract address that emitted the nullifier\n    ///\n    /// # Returns\n    /// * `bool` - True if the nullifier has been emitted by the specified contract\n    ///\n    pub fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { nullifier_exists(unsiloed_nullifier, address.to_field()) } == 1\n    }\n\n    /// Consumes a message sent from Ethereum (L1) to Aztec (L2) -- effectively\n    /// marking it as \"read\".\n    ///\n    /// Use this function if you only want the message to ever be \"referred to\"\n    /// once. Once consumed using this method, the message cannot be consumed\n    /// again, because a nullifier is emitted.\n    /// If your use case wants for the message to be read unlimited times, then\n    /// you can always read any historic message from the L1-to-L2 messages tree,\n    /// using the `l1_to_l2_msg_exists` method. Messages never technically get\n    /// deleted from that tree.\n    ///\n    /// The message will first be inserted into an Aztec \"Inbox\" smart contract\n    /// on L1. It will not be available for consumption immediately. Messages\n    /// get copied-over from the L1 Inbox to L2 by the next Proposer in batches.\n    /// So you will need to wait until the messages are copied before you can\n    /// consume them.\n    ///\n    /// # Arguments\n    /// * `content` - The message content that was sent from L1\n    /// * `secret` - Secret value used for message privacy (if needed)\n    /// * `sender` - Ethereum address that sent the message\n    /// * `leaf_index` - Index of the message in the L1-to-L2 message tree\n    ///\n    /// # Advanced\n    /// * Validates message existence in the L1-to-L2 message tree\n    /// * Prevents double-consumption by emitting a nullifier\n    /// * Message hash is computed from all parameters + chain context\n    /// * Will revert if message doesn't exist or was already consumed\n    ///\n    pub fn consume_l1_to_l2_message(\n        self: Self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_l1_to_l2_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/\n            self.this_address(),\n            self.version(),\n            content,\n            secret_hash,\n            leaf_index,\n        );\n        let nullifier = compute_l1_to_l2_message_nullifier(message_hash, secret);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()),\n            \"L1-to-L2 message is already nullified\",\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index),\n            \"Tried to consume nonexistent L1-to-L2 message\",\n        );\n\n        self.push_nullifier(nullifier);\n    }\n\n    /// Sends an \"L2 -> L1 message\" from this function (Aztec, L2) to a smart\n    /// contract on Ethereum (L1). L1 contracts which are designed to\n    /// send/receive messages to/from Aztec are called \"Portal Contracts\".\n    ///\n    /// Common use cases include withdrawals, cross-chain asset transfers, and\n    /// triggering L1 actions based on L2 state changes.\n    ///\n    /// The message will be inserted into an Aztec \"Outbox\" contract on L1,\n    /// when this transaction's block is proposed to L1.\n    /// Sending the message will not result in any immediate state changes in\n    /// the target portal contract. The message will need to be manually\n    /// consumed from the Outbox through a separate Ethereum transaction: a user\n    /// will need to call a function of the portal contract -- a function\n    /// specifically designed to make a call to the Outbox to consume the\n    /// message.\n    /// The message will only be available for consumption once the _epoch_\n    /// proof has been submitted. Given that there are multiple Aztec blocks\n    /// within an epoch, it might take some time for this epoch proof to be\n    /// submitted -- especially if the block was near the start of an epoch.\n    ///\n    /// # Arguments\n    /// * `recipient` - Ethereum address that will receive the message\n    /// * `content` - Message content (32 bytes as a Field element)\n    ///\n    pub fn message_portal(_self: Self, recipient: EthAddress, content: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { send_l2_to_l1_msg(recipient, content) };\n    }\n\n    /// Calls a public function on another contract.\n    ///\n    /// Will revert if the called function reverts or runs out of gas.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract to call\n    /// * `function_selector` - Function to call on the target contract\n    /// * `args` - Arguments to pass to the function\n    /// * `gas_opts` - An optional allocation of gas to the called function.\n    ///\n    /// # Returns\n    /// * `[Field]` - Return data from the called function\n    ///\n    pub unconstrained fn call_public_function<let N: u32>(\n        _self: Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; N],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = [function_selector.to_field()].concat(args);\n\n        call(\n            gas_opts.l2_gas.unwrap_or(MAX_U32_VALUE),\n            gas_opts.da_gas.unwrap_or(MAX_U32_VALUE),\n            contract_address,\n            calldata,\n        );\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    /// Makes a read-only call to a public function on another contract.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state or emit events. Any nested calls are constrained to\n    /// also be staticcalls.\n    ///\n    /// Useful for querying data from other contracts safely.\n    ///\n    /// Will revert if the called function reverts or runs out of gas.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract to call\n    /// * `function_selector` - Function to call on the target contract\n    /// * `args` - Array of arguments to pass to the called function\n    /// * `gas_opts` - An optional allocation of gas to the called function.\n    ///\n    /// # Returns\n    /// * `[Field]` - Return data from the called function\n    ///\n    pub unconstrained fn static_call_public_function<let N: u32>(\n        _self: Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; N],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = [function_selector.to_field()].concat(args);\n\n        call_static(\n            gas_opts.l2_gas.unwrap_or(MAX_U32_VALUE),\n            gas_opts.da_gas.unwrap_or(MAX_U32_VALUE),\n            contract_address,\n            calldata,\n        );\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    /// Adds a new note hash to the Aztec blockchain's global Note Hash Tree.\n    ///\n    /// Notes are ordinarily constructed and emitted by _private_ functions, to\n    /// ensure that both the content of the note, and the contract that emitted\n    /// the note, stay private.\n    ///\n    /// There are however some useful patterns whereby a note needs to contain\n    /// _public_ data. The ability to push a new note_hash from a _public_\n    /// function means that notes can be injected with public data immediately\n    /// -- as soon as the public value is known. The slower alternative would\n    /// be to submit a follow-up transaction so that a private function can\n    /// inject the data. Both are possible on Aztec.\n    ///\n    /// Search \"Partial Note\" for a very common pattern which enables a note\n    /// to be \"partially\" populated with some data in a _private_ function, and\n    /// then later \"completed\" with some data in a public function.\n    ///\n    /// # Arguments\n    /// * `note_hash` - The hash of the note to add to the tree\n    ///\n    /// # Advanced\n    /// * The note hash will be siloed with the contract address by the protocol\n    ///\n    pub fn push_note_hash(_self: Self, note_hash: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_note_hash(note_hash) };\n    }\n\n    /// Adds a new nullifier to the Aztec blockchain's global Nullifier Tree.\n    ///\n    /// Whilst nullifiers are primarily intended as a _privacy-preserving_\n    /// record of a one-time action, they can also be used to efficiently\n    /// record _public_ one-time actions too. Hence why you're seeing this\n    /// function within the PublicContext.\n    /// An example is to check whether a contract has been published: we emit\n    /// a nullifier that is deterministic, but whose preimage is _not_ private.\n    ///\n    /// # Arguments\n    /// * `nullifier` - A unique field element that represents the consumed\n    ///   state\n    ///\n    /// # Advanced\n    /// * Nullifier is immediately added to the global nullifier tree\n    /// * Emitted nullifiers are immediately visible to all\n    ///   subsequent transactions in the same block\n    /// * Automatically siloed with the contract address by the protocol\n    /// * Used for preventing double-spending and ensuring one-time actions\n    ///\n    pub fn push_nullifier(_self: Self, nullifier: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_nullifier(nullifier) };\n    }\n\n    /// Returns the address of the current contract being executed.\n    ///\n    /// This is equivalent to `address(this)` in Solidity (hence the name).\n    /// Use this to identify the current contract's address, commonly needed for\n    /// access control or when interacting with other contracts.\n    ///\n    /// # Returns\n    /// * `AztecAddress` - The contract address of the current function being\n    ///                    executed.\n    ///\n    pub fn this_address(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            address()\n        }\n    }\n\n    /// Returns the contract address that initiated this function call.\n    ///\n    /// This is similar to `msg.sender` in Solidity (hence the name).\n    ///\n    /// Important Note: If the calling function is a _private_ function, then\n    /// it had the option of hiding its address when enqueuing this public\n    /// function call. In such cases, this `context.msg_sender()` method will\n    /// return `Option<AztecAddress>::none`.\n    /// If the calling function is a _public_ function, it will always return\n    /// an `Option<AztecAddress>::some` (i.e. a non-null value).\n    ///\n    /// # Returns\n    /// * `Option<AztecAddress>` - The address of the smart contract that called\n    ///   this function (be it an app contract or a user's account contract).\n    ///\n    /// # Advanced\n    /// * Value is provided by the AVM sender opcode\n    /// * In nested calls, this is the immediate caller, not the original\n    ///   transaction sender\n    ///\n    pub fn msg_sender(_self: Self) -> Option<AztecAddress> {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        let maybe_msg_sender = unsafe { sender() };\n        if maybe_msg_sender == NULL_MSG_SENDER_CONTRACT_ADDRESS {\n            Option::none()\n        } else {\n            Option::some(maybe_msg_sender)\n        }\n    }\n\n    /// \"Unsafe\" versus calling `context.msg_sender()`, because it doesn't\n    /// translate `NULL_MSG_SENDER_CONTRACT_ADDRESS` as\n    /// `Option<AztecAddress>::none`.\n    /// Used by some internal aztecnr functions.\n    pub fn msg_sender_unsafe(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            sender()\n        }\n    }\n\n    /// Returns the function selector of the currently-executing function.\n    ///\n    /// This is similar to `msg.sig` in Solidity, returning the first 4\n    /// bytes of the function signature.\n    ///\n    /// # Returns\n    /// * `FunctionSelector` - The 4-byte function identifier\n    ///\n    /// # Advanced\n    /// * Extracted from the first element of calldata\n    /// * Used internally for function dispatch in the AVM\n    ///\n    pub fn selector(_self: Self) -> FunctionSelector {\n        // The selector is the first element of the calldata when calling a public function through dispatch.\n        // Safety: AVM opcodes are constrained by the AVM itself\n        let raw_selector: [Field; 1] = unsafe { calldata_copy(0, 1) };\n        FunctionSelector::from_field(raw_selector[0])\n    }\n\n    /// Returns the hash of the arguments passed to the current function.\n    ///\n    /// Very low-level function: The #[external(\"public\")] macro uses this internally.\n    /// Smart contract developers typically won't need to access this\n    /// directly as arguments are automatically made available.\n    ///\n    /// # Returns\n    /// * `Field` - Hash of the function arguments\n    ///\n    pub fn get_args_hash(mut self) -> Field {\n        if !self.args_hash.is_some() {\n            self.args_hash = Option::some((self.compute_args_hash)());\n        }\n\n        self.args_hash.unwrap_unchecked()\n    }\n\n    /// Returns the \"transaction fee\" for the current transaction.\n    /// This is the final tx fee that will be deducted from the fee_payer's\n    /// \"fee-juice\" balance (in the protocol's Base Rollup circuit).\n    ///\n    /// # Returns\n    /// * `Field` - The actual, final cost of the transaction, taking into account:\n    ///             the actual gas used during the setup and app-logic phases,\n    ///             and the fixed amount of gas that's been allocated by the user\n    ///             for the teardown phase.\n    ///             I.e. effectiveL2FeePerGas * l2GasUsed + effectiveDAFeePerGas * daGasUsed\n    ///\n    /// This will return `0` during the \"setup\" and \"app-logic\" phases of\n    /// tx execution (because the final tx fee is not known at that time).\n    /// This will only return a nonzero value during the \"teardown\" phase of\n    /// execution, where the final tx fee can actually be computed.\n    ///\n    /// Regardless of _when_ this function is called during the teardown phase,\n    /// it will always return the same final tx fee value. The teardown phase\n    /// does not consume a variable amount of gas: it always consumes a\n    /// pre-allocated amount of gas, as specified by the user when they generate\n    /// their tx.\n    ///\n    pub fn transaction_fee(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            transaction_fee()\n        }\n    }\n\n    /// Returns the chain ID of the current network.\n    ///\n    /// This is similar to `block.chainid` in Solidity. Returns the unique\n    /// identifier for the blockchain network this transaction is executing on.\n    ///\n    /// Helps prevent cross-chain replay attacks. Useful if implementing\n    /// multi-chain contract logic.\n    ///\n    /// # Returns\n    /// * `Field` - The chain ID as a field element\n    ///\n    pub fn chain_id(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            chain_id()\n        }\n    }\n\n    /// Returns the Aztec protocol version that this transaction is executing\n    /// under. Different versions may have different rules, opcodes, or\n    /// cryptographic primitives.\n    ///\n    /// This is similar to how Ethereum has different EVM versions.\n    ///\n    /// Useful for forward/backward compatibility checks\n    ///\n    /// Not to be confused with contract versions; this is the protocol version.\n    ///\n    /// # Returns\n    /// * `Field` - The protocol version as a field element\n    ///\n    pub fn version(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            version()\n        }\n    }\n    /// Returns the current block number.\n    ///\n    /// This is similar to `block.number` in Solidity.\n    ///\n    /// Note: the current block number is only available within a public function\n    /// (as opposed to a private function).\n    ///\n    /// Note: the time intervals between blocks should not be relied upon as\n    /// being consistent:\n    /// - Timestamps of blocks fall within a range, rather than at exact regular\n    ///   intervals.\n    /// - Slots can be missed.\n    /// - Protocol upgrades can completely change the intervals between blocks\n    ///   (and indeed the current roadmap plans to reduce the time between\n    ///   blocks, eventually).\n    /// Use `context.timestamp()` for more-reliable time-based logic.\n    ///\n    /// # Returns\n    /// * `u32` - The current block number\n    ///\n    pub fn block_number(_self: Self) -> u32 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            block_number()\n        }\n    }\n\n    /// Returns the timestamp of the current block.\n    ///\n    /// This is similar to `block.timestamp` in Solidity.\n    ///\n    /// All functions of all transactions in a block share the exact same\n    /// timestamp (even though technically each transaction is executed\n    /// one-after-the-other).\n    ///\n    /// Important note: Timestamps of Aztec blocks are not at reliably-fixed\n    /// intervals. The proposer of the block has some flexibility to choose a\n    /// timestamp which is in a valid _range_: Obviously the timestamp of this\n    /// block must be strictly greater than that of the previous block, and must\n    /// must be less than the timestamp of whichever ethereum block the aztec\n    /// block is proposed to. Furthermore, if the timestamp is not deemed close\n    /// enough to the actual current time, the committee of validators will not\n    /// attest to the block.\n    ///\n    /// # Returns\n    /// * `u64` - Unix timestamp in seconds\n    ///\n    pub fn timestamp(_self: Self) -> u64 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            timestamp()\n        }\n    }\n\n    /// Returns the fee per unit of L2 gas for this transaction (aka the \"L2 gas\n    /// price\"), as chosen by the user.\n    ///\n    /// L2 gas covers the cost of executing public functions and handling\n    /// side-effects within the AVM.\n    ///\n    /// # Returns\n    /// * `u128` - Fee per unit of L2 gas\n    ///\n    /// Wallet developers should be mindful that the choice of gas price (which\n    /// is publicly visible) can leak information about the user, e.g.:\n    /// - which wallet software the user is using;\n    /// - the amount of time which has elapsed from the time the user's wallet\n    ///   chose a gas price (at the going rate), to the time of tx submission.\n    ///   This can give clues about the proving time, and hence the nature of\n    ///   the tx.\n    /// - the urgency of the transaction (which is kind of unavoidable, if the\n    ///   tx is indeed urgent).\n    /// - the wealth of the user.\n    /// - the exact user (if the gas price is explicitly chosen by the user to\n    ///   be some unique number like 0.123456789, or their favorite number).\n    /// Wallet devs might wish to consider fuzzing the choice of gas price.\n    ///\n    pub fn base_fee_per_l2_gas(_self: Self) -> u128 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            base_fee_per_l2_gas()\n        }\n    }\n\n    /// Returns the fee per unit of DA (Data Availability) gas (aka the \"DA gas\n    /// price\").\n    ///\n    /// DA gas covers the cost of making transaction data available on L1.\n    ///\n    /// See the warning in `fee_pre_l2_gas` for how gas prices can be leaky.\n    ///\n    /// # Returns\n    /// * `u128` - Fee per unit of DA gas\n    ///\n    pub fn base_fee_per_da_gas(_self: Self) -> u128 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            base_fee_per_da_gas()\n        }\n    }\n\n    /// Returns the remaining L2 gas available for this transaction.\n    ///\n    /// Different AVM opcodes consume different amounts of gas.\n    ///\n    /// # Returns\n    /// * `u32` - Remaining L2 gas units\n    ///\n    pub fn l2_gas_left(_self: Self) -> u32 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            l2_gas_left()\n        }\n    }\n\n    /// Returns the remaining DA (Data Availability) gas available for this\n    /// transaction.\n    ///\n    /// DA gas is consumed when emitting data that needs to be made available\n    /// on L1, such as public logs or state updates.\n    /// All of the side-effects from the private part of the tx also consume\n    /// DA gas before execution of any public functions even begins.\n    ///\n    /// # Returns\n    /// * `u32` - Remaining DA gas units\n    ///\n    pub fn da_gas_left(_self: Self) -> u32 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            da_gas_left()\n        }\n    }\n\n    /// Checks if the current execution is within a staticcall context, where\n    /// no state changes or logs are allowed to be emitted (by this function\n    /// or any nested function calls).\n    ///\n    /// # Returns\n    /// * `bool` - True if in staticcall context, false otherwise\n    ///\n    pub fn is_static_call(_self: Self) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { is_static_call() } == 1\n    }\n\n    /// Reads raw field values from public storage.\n    /// Reads N consecutive storage slots starting from the given slot.\n    ///\n    /// Very low-level function. Users should typically use the public state\n    /// variable abstractions to perform reads: PublicMutable & PublicImmutable.\n    ///\n    /// # Arguments\n    /// * `storage_slot` - The starting storage slot to read from\n    ///\n    /// # Returns\n    /// * `[Field; N]` - Array of N field values from consecutive storage slots\n    ///\n    /// # Generic Parameters\n    /// * `N` - the number of consecutive slots to return, starting from the\n    ///         `storage_slot`.\n    ///\n    pub fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\n        let mut out = [0; N];\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            out[i] = unsafe { storage_read(storage_slot + i as Field) };\n        }\n        out\n    }\n\n    /// Reads a typed value from public storage.\n    ///\n    /// Low-level function. Users should typically use the public state\n    /// variable abstractions to perform reads: PublicMutable & PublicImmutable.\n    ///\n    /// # Arguments\n    /// * `storage_slot` - The storage slot to read from\n    ///\n    /// # Returns\n    /// * `T` - The deserialized value from storage\n    ///\n    /// # Generic Parameters\n    /// * `T` - The type that the caller expects to read from the `storage_slot`.\n    ///\n    pub fn storage_read<T>(self, storage_slot: Field) -> T\n    where\n        T: Packable,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n\n    /// Writes raw field values to public storage.\n    /// Writes to N consecutive storage slots starting from the given slot.\n    ///\n    /// Very low-level function. Users should typically use the public state\n    /// variable abstractions to perform writes: PublicMutable & PublicImmutable.\n    ///\n    /// Public storage writes take effect immediately.\n    ///\n    /// # Arguments\n    /// * `storage_slot` - The starting storage slot to write to\n    /// * `values` - Array of N Fields to write to storage\n    ///\n    pub fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            unsafe { storage_write(storage_slot + i as Field, values[i]) };\n        }\n    }\n\n    /// Writes a typed value to public storage.\n    ///\n    /// Low-level function. Users should typically use the public state\n    /// variable abstractions to perform writes: PublicMutable & PublicImmutable.\n    ///\n    /// # Arguments\n    /// * `storage_slot` - The storage slot to write to\n    /// * `value` - The typed value to write to storage\n    ///\n    /// # Generic Parameters\n    /// * `T` - The type to write to storage.\n    ///\n    pub fn storage_write<T>(self, storage_slot: Field, value: T)\n    where\n        T: Packable,\n    {\n        self.raw_storage_write(storage_slot, value.pack());\n    }\n}\n\n// TODO: consider putting this oracle code in its own file.\n// Unconstrained opcode wrappers (do not use directly).\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> u32 {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn base_fee_per_l2_gas() -> u128 {\n    base_fee_per_l2_gas_opcode()\n}\nunconstrained fn base_fee_per_da_gas() -> u128 {\n    base_fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> u32 {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> u32 {\n    da_gas_left_opcode()\n}\nunconstrained fn is_static_call() -> u1 {\n    is_static_call_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: u64) -> u1 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u1 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_public_log(message: [Field]) {\n    emit_public_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: u64) -> u1 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\n\nunconstrained fn call<let N: u32>(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    args: [Field; N],\n) {\n    call_opcode(l2_gas_allocation, da_gas_allocation, address, N, args)\n}\n\nunconstrained fn call_static<let N: u32>(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    args: [Field; N],\n) {\n    call_static_opcode(l2_gas_allocation, da_gas_allocation, address, N, args)\n}\n\npub unconstrained fn calldata_copy<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {\n    calldata_copy_opcode(cdoffset, copy_size)\n}\n\n// `success_copy` is placed immediately after the CALL opcode to get the success value\nunconstrained fn success_copy() -> bool {\n    success_copy_opcode()\n}\n\nunconstrained fn returndata_size() -> u32 {\n    returndata_size_opcode()\n}\n\nunconstrained fn returndata_copy(rdoffset: u32, copy_size: u32) -> [Field] {\n    returndata_copy_opcode(rdoffset, copy_size)\n}\n\npub unconstrained fn avm_return(returndata: [Field]) {\n    return_opcode(returndata)\n}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\nunconstrained fn avm_revert(revertdata: [Field]) {\n    revert_opcode(revertdata)\n}\n\nunconstrained fn storage_read(storage_slot: Field) -> Field {\n    storage_read_opcode(storage_slot)\n}\n\nunconstrained fn storage_write(storage_slot: Field, value: Field) {\n    storage_write_opcode(storage_slot, value);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(|| 0)\n    }\n}\n\n// TODO: consider putting this oracle code in its own file.\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> u32 {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeBaseFeePerL2Gas)]\nunconstrained fn base_fee_per_l2_gas_opcode() -> u128 {}\n\n#[oracle(avmOpcodeBaseFeePerDaGas)]\nunconstrained fn base_fee_per_da_gas_opcode() -> u128 {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> u32 {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> u32 {}\n\n#[oracle(avmOpcodeIsStaticCall)]\nunconstrained fn is_static_call_opcode() -> u1 {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: u64) -> u1 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n// TODO(#11124): rename unencrypted to public in avm\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_public_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: u64) -> u1 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCalldataCopy)]\nunconstrained fn calldata_copy_opcode<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {}\n\n#[oracle(avmOpcodeReturndataSize)]\nunconstrained fn returndata_size_opcode() -> u32 {}\n\n#[oracle(avmOpcodeReturndataCopy)]\nunconstrained fn returndata_copy_opcode(rdoffset: u32, copy_size: u32) -> [Field] {}\n\n#[oracle(avmOpcodeReturn)]\nunconstrained fn return_opcode(returndata: [Field]) {}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\n#[oracle(avmOpcodeRevert)]\nunconstrained fn revert_opcode(revertdata: [Field]) {}\n\n// While the length parameter might seem unnecessary given that we have N we keep it around because at the AVM bytecode\n// level, we want to support non-comptime-known lengths for such opcodes, even if Noir code will not generally take that\n// route.\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode<let N: u32>(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    length: u32,\n    args: [Field; N],\n) {}\n\n// While the length parameter might seem unnecessary given that we have N we keep it around because at the AVM bytecode\n// level, we want to support non-comptime-known lengths for such opcodes, even if Noir code will not generally take that\n// route.\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode<let N: u32>(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    length: u32,\n    args: [Field; N],\n) {}\n\n#[oracle(avmOpcodeSuccessCopy)]\nunconstrained fn success_copy_opcode() -> bool {}\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode(storage_slot: Field) -> Field {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode(storage_slot: Field, value: Field) {}\n","path":"/Users/zac/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/context/public_context.nr"},"73":{"source":"use crate::oracle::{execution::get_utility_context, storage::storage_read};\nuse protocol_types::{address::AztecAddress, traits::Packable};\n\n// If you'll modify this struct don't forget to update utility_context.ts as well.\npub struct UtilityContext {\n    block_number: u32,\n    timestamp: u64,\n    contract_address: AztecAddress,\n    version: Field,\n    chain_id: Field,\n}\n\nimpl UtilityContext {\n    pub unconstrained fn new() -> Self {\n        get_utility_context()\n    }\n\n    pub unconstrained fn at(contract_address: AztecAddress) -> Self {\n        // We get a context with default contract address, and then we construct the final context with the provided\n        // contract address.\n        let default_context = get_utility_context();\n\n        Self {\n            block_number: default_context.block_number,\n            timestamp: default_context.timestamp,\n            contract_address,\n            version: default_context.version,\n            chain_id: default_context.chain_id,\n        }\n    }\n\n    pub unconstrained fn at_historical(contract_address: AztecAddress, block_number: u32) -> Self {\n        // We get a context with default contract address and block number, and then we construct the final context\n        // with the provided contract address and block number.\n        let default_context = get_utility_context();\n\n        Self {\n            block_number,\n            timestamp: default_context.timestamp,\n            contract_address,\n            version: default_context.version,\n            chain_id: default_context.chain_id,\n        }\n    }\n\n    pub fn block_number(self) -> u32 {\n        self.block_number\n    }\n\n    pub fn timestamp(self) -> u64 {\n        self.timestamp\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.contract_address\n    }\n\n    pub fn version(self) -> Field {\n        self.version\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.chain_id\n    }\n\n    pub unconstrained fn raw_storage_read<let N: u32>(\n        self: Self,\n        storage_slot: Field,\n    ) -> [Field; N] {\n        storage_read(self.this_address(), storage_slot, self.block_number())\n    }\n\n    pub unconstrained fn storage_read<T>(self, storage_slot: Field) -> T\n    where\n        T: Packable,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n}\n","path":"/Users/zac/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/context/utility_context.nr"},"74":{"source":"use crate::{\n    context::{\n        calls::{PrivateCall, PrivateStaticCall, PublicCall, PublicStaticCall},\n        private_context::PrivateContext,\n        public_context::PublicContext,\n        utility_context::UtilityContext,\n    },\n    event::{\n        event_emission::{emit_event_in_private, emit_event_in_public},\n        event_interface::EventInterface,\n        event_message::EventMessage,\n    },\n};\nuse protocol_types::{\n    address::AztecAddress,\n    constants::NULL_MSG_SENDER_CONTRACT_ADDRESS,\n    traits::{Deserialize, Serialize},\n};\n\n/// `ContractSelf` is the core interface for interacting with an Aztec contract's own state and context.\n///\n/// This struct is automatically injected into every #[external(...)] contract function by the Aztec macro system and is\n/// accessible through the `self` variable.\n///\n/// # Usage in Contract Functions\n///\n/// Once injected, you can use `self` to:\n/// - Access storage: `self.storage.balances.at(owner).read()`\n/// - Call contracts: `self.call(Token::at(address).transfer(recipient, amount))`\n/// - Emit events: `self.emit(event).deliver_to(recipient, delivery_mode)` (private) or `self.emit(event)` (public)\n/// - Get the contract address: `self.address`\n/// - Get the caller: `self.msg_sender()`\n/// - Access low-level Aztec.nr APIs through the context: `self.context`\n///\n/// # Example\n///\n/// ```noir\n/// #[external(\"private\")]\n/// fn withdraw(amount: u128, recipient: AztecAddress) {\n///     // Get the caller of this function\n///     let sender = self.msg_sender().unwrap();\n///\n///     // Access storage\n///     let token = self.storage.donation_token.get_note().get_address();\n///\n///     // Call contracts\n///     self.call(Token::at(token).transfer(recipient, amount));\n/// }\n/// ```\n///\n/// # Type Parameters\n///\n/// - `Context`: The execution context type - either `&mut PrivateContext`, `PublicContext`, or `UtilityContext`\n/// - `Storage`: The contract's storage struct (defined with `#[storage]`), or `()` if the contract has no storage\n/// - `CallSelf`: Macro-generated type for calling contract's own non-view functions\n/// - `EnqueueSelf`: Macro-generated type for enqueuing calls to the contract's own non-view functions\n/// - `CallSelfStatic`: Macro-generated type for calling contract's own view functions\n/// - `EnqueueSelfStatic`: Macro-generated type for enqueuing calls to the contract's own view functions\npub struct ContractSelf<Context, Storage, CallSelf, EnqueueSelf, CallSelfStatic, EnqueueSelfStatic, CallInternal> {\n    /// The address of this contract\n    pub address: AztecAddress,\n    /// The contract's storage instance, representing the struct to which the `#[storage]` macro was applied in your\n    /// contract. If the contract has no storage, the type of this will be `()`.\n    ///\n    /// This storage instance is specialized for the current execution context (private, public, or utility) and\n    /// provides access to the contract's state variables. Each state variable accepts the context as a generic\n    /// parameter, which determines its available functionality. For example, a PublicImmutable variable can be read\n    /// from any context (public, private, or utility) but can only be written to from public contexts.\n    ///\n    /// # Developer Note\n    /// If you've arrived here while trying to access your contract's storage while the `Storage` generic type is set to\n    /// unit type `()`, it means you haven't yet defined a Storage struct using the #[storage] macro in your contract.\n    /// For guidance on setting this up, please refer to our docs:\n    /// https://docs.aztec.network/developers/docs/guides/smart_contracts/storage\n    pub storage: Storage,\n    /// The execution context whose type is determined by the #[external(...)] attribute of the contract function based\n    /// on the external function type (private, public, or utility).\n    pub context: Context,\n\n    /// Provides type-safe methods for calling this contract's own non-view functions.\n    ///\n    /// In private and public contexts this will be a struct with appropriate methods;\n    /// in utility context it will be the unit type `()`.\n    ///\n    /// Example API:\n    /// ```noir\n    /// self.call_self.some_private_function(args)\n    /// ```\n    pub call_self: CallSelf,\n    /// Provides type-safe methods for enqueuing calls to this contract's own non-view functions.\n    ///\n    /// In private context this will be a struct with appropriate methods;\n    /// in public and utility contexts it will be the unit type `()`.\n    ///\n    /// Example API:\n    /// ```noir\n    /// self.enqueue_self.some_public_function(args)\n    /// ```\n    pub enqueue_self: EnqueueSelf,\n    /// Provides type-safe methods for calling this contract's own view functions.\n    ///\n    /// In private and public contexts this will be a struct with appropriate methods;\n    /// in utility context it will be the unit type `()`.\n    ///\n    /// Example API:\n    /// ```noir\n    /// self.call_self_static.some_view_function(args)\n    /// ```\n    pub call_self_static: CallSelfStatic,\n    /// Provides type-safe methods for enqueuing calls to this contract's own view functions.\n    ///\n    /// In private context this will be a struct with appropriate methods;\n    /// in public and utility contexts it will be the unit type `()`.\n    ///\n    /// Example API:\n    /// ```noir\n    /// self.enqueue_self_static.some_public_view_function(args)\n    /// ```\n    pub enqueue_self_static: EnqueueSelfStatic,\n    /// Provides type-safe methods for calling internal functions.\n    ///\n    /// In private and public contexts this will be a struct with appropriate methods;\n    /// in utility context it will be the unit type `()`.\n    ///\n    /// Example API:\n    /// ```noir\n    /// self.internal.some_internal_function(args)\n    /// ```\n    pub internal: CallInternal,\n}\n\n/// Implementation for `ContractSelf` in private execution contexts.\n///\n/// This implementation is used when a contract function is marked with `#[external(\"private\")]`.\n/// Private functions execute client-side and generate zero-knowledge proofs of their execution.\nimpl<Storage, CallSelf, EnqueueSelf, CallSelfStatic, EnqueueSelfStatic, CallInternal> ContractSelf<&mut PrivateContext, Storage, CallSelf, EnqueueSelf, CallSelfStatic, EnqueueSelfStatic, CallInternal> {\n    /// Creates a new `ContractSelf` instance for a private function.\n    ///\n    /// This constructor is called automatically by the macro system and should not be called directly.\n    pub fn new_private(\n        context: &mut PrivateContext,\n        storage: Storage,\n        call_self: CallSelf,\n        enqueue_self: EnqueueSelf,\n        call_self_static: CallSelfStatic,\n        enqueue_self_static: EnqueueSelfStatic,\n        internal: CallInternal,\n    ) -> Self {\n        Self {\n            context,\n            storage,\n            address: context.this_address(),\n            call_self,\n            enqueue_self,\n            call_self_static,\n            enqueue_self_static,\n            internal,\n        }\n    }\n\n    /// Returns the contract address that initiated this function call. This is similar to `msg.sender` in Solidity.\n    ///\n    /// Important Note: Since Aztec doesn't have a concept of an EoA ( Externally-owned Account), the msg_sender is\n    /// \"null\" for the first function call of every transaction. The first function call of a tx is likely to be a call\n    /// to the user's account contract, so this quirk will most often be handled by account contract developers.\n    ///\n    /// # Returns\n    /// * `Option<AztecAddress>` - The address of the smart contract that called this function (be it an app contract or\n    ///   a user's account contract). Returns `Option<AztecAddress>::none` for the first function call of the tx. No\n    ///   other _private_ function calls in the tx will have a `none` msg_sender, but _public_ function calls might (see\n    ///   the PublicContext).\n    ///\n    pub fn msg_sender(self) -> Option<AztecAddress> {\n        let maybe_msg_sender = self.context.msg_sender_unsafe();\n        if maybe_msg_sender == NULL_MSG_SENDER_CONTRACT_ADDRESS {\n            Option::none()\n        } else {\n            Option::some(maybe_msg_sender)\n        }\n    }\n\n    /// Emits an event privately.\n    ///\n    /// Unlike public events, private events do not reveal their contents publicly. They instead create an\n    /// [EventMessage] containing the private event information, which **MUST** be delivered to a recipient via\n    /// [EventMessage::deliver_to] in order for them to learn about the event. Multiple recipients can have the same\n    /// message be delivered to them.\n    ///\n    /// # Example\n    /// ```noir\n    /// #[event]\n    /// struct Transfer { from: AztecAddress, to: AztecAddress, amount: u128 }\n    ///\n    /// #[external(\"private\")]\n    /// fn transfer(to: AztecAddress, amount: u128) {\n    ///     let from = self.msg_sender().unwrap();\n    ///\n    ///     let message: EventMessage = self.emit(Transfer { from, to, amount });\n    ///     message.deliver_to(from, MessageDelivery.UNCONSTRAINED_OFFCHAIN);\n    ///     message.deliver_to(to, MessageDelivery.CONSTRAINED_ONCHAIN);\n    /// }\n    /// ```\n    ///\n    /// # Cost\n    ///\n    /// Private event emission always results in the creation of a nullifer, which acts as a commitment to the event and\n    /// is used by third parties to verify its authenticity. See [EventMessage::deliver_to] for the costs associated to\n    /// delivery.\n    ///\n    /// # Privacy\n    ///\n    /// The nullifier created when emitting a private event leaks nothing about the content of the event - it's a\n    /// commitment that includes a random value, so even with full knowledge of the event preimage determining if an\n    /// event was emitted or not requires brute-forcing the entire `Field` space.\n    pub fn emit<Event>(&mut self, event: Event) -> EventMessage<Event>\n    where\n        Event: EventInterface + Serialize,\n    {\n        emit_event_in_private(self.context, event)\n    }\n\n    /// Makes a call to the private function defined by the `call` parameter.\n    ///\n    /// # Arguments\n    /// * `call` - The object representing the private function to invoke.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    /// # Example\n    /// ```noir\n    /// self.call(Token::at(address).transfer_in_private(recipient, amount));\n    /// ```\n    ///\n    /// This enables contracts to interact with each other while maintaining\n    /// privacy. This \"composability\" of private contract functions is a key\n    /// feature of the Aztec network.\n    ///\n    /// If a user's transaction includes multiple private function calls, then\n    /// by the design of Aztec, the following information will remain private[1]:\n    /// - The function selectors and contract addresses of all private function\n    ///   calls will remain private, so an observer of the public mempool will\n    ///   not be able to look at a tx and deduce which private functions have\n    ///   been executed.\n    /// - The arguments and return values of all private function calls will\n    ///   remain private.\n    /// - The person who initiated the tx will remain private.\n    /// - The notes and nullifiers and private logs that are emitted by all\n    ///   private function calls will (if designed well) not leak any user\n    ///   secrets, nor leak which functions have been executed.\n    ///\n    /// [1] Caveats: Some of these privacy guarantees depend on how app\n    /// developers design their smart contracts. Some actions _can_ leak\n    /// information, such as:\n    /// - Calling an internal public function.\n    /// - Calling a public function and not setting msg_sender to Option::none\n    ///   (see https://github.com/AztecProtocol/aztec-packages/pull/16433)\n    /// - Calling any public function will always leak details about the nature\n    ///   of the transaction, so devs should be careful in their contract\n    ///   designs. If it can be done in a private function, then that will give\n    ///   the best privacy.\n    /// - Not padding the side-effects of a tx to some standardized, uniform\n    ///   size. The kernel circuits can take hints to pad side-effects, so a\n    ///   wallet should be able to request for a particular amount of padding.\n    ///   Wallets should ideally agree on some standard.\n    ///   - Padding should include:\n    ///     - Padding the lengths of note & nullifier arrays\n    ///     - Padding private logs with random fields, up to some standardized\n    ///       size.\n    /// See also: https://docs.aztec.network/developers/resources/considerations/privacy_considerations\n    ///\n    /// # Advanced\n    /// * The call is added to the private call stack and executed by kernel\n    ///   circuits after this function completes\n    /// * The called function can modify its own contract's private state\n    /// * Side effects from the called function are included in this transaction\n    /// * The call inherits the current transaction's context and gas limits\n    ///\n    pub fn call<let M: u32, let N: u32, T>(&mut self, call: PrivateCall<M, N, T>) -> T\n    where\n        T: Deserialize,\n    {\n        call.call(self.context)\n    }\n\n    /// Makes a read-only call to the private function defined by the `call` parameter.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state, emit L2->L1 messages, nor emit events. Any nested\n    /// calls are constrained to also be static calls.\n    ///\n    /// # Arguments\n    /// * `call` - The object representing the read-only private function to invoke.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    /// # Example\n    /// ```noir\n    /// self.view(Token::at(address).balance_of_private(recipient));\n    /// ```\n    pub fn view<let M: u32, let N: u32, T>(&mut self, call: PrivateStaticCall<M, N, T>) -> T\n    where\n        T: Deserialize,\n    {\n        call.view(self.context)\n    }\n\n    /// Enqueues a call to the public function defined by the `call` parameter,\n    /// to be executed later.\n    ///\n    /// Unlike private functions which execute immediately on the user's device,\n    /// public function calls are \"enqueued\" and executed some time later by a\n    /// block proposer.\n    ///\n    /// This means a public function cannot return any values back to a private\n    /// function, because by the time the public function is being executed,\n    /// the private function which called it has already completed execution.\n    /// (In fact, the private function has been executed and proven, along with\n    /// all other private function calls of the user's tx. A single proof of the\n    /// tx has been submitted to the Aztec network, and some time later a\n    /// proposer has picked the tx up from the mempool and begun executing all\n    /// of the enqueued public functions).\n    ///\n    /// # Privacy warning\n    /// Enqueueing a public function call is an inherently leaky action.\n    /// Many interesting applications will require some interaction with public\n    /// state, but smart contract developers should try to use public function\n    /// calls sparingly, and carefully.\n    /// _Internal_ public function calls are especially leaky, because they\n    /// completely leak which private contract made the call.\n    /// See also: https://docs.aztec.network/developers/resources/considerations/privacy_considerations\n    ///\n    /// # Arguments\n    /// * `call` - The interface representing the public function to enqueue.\n    ///\n    /// TODO(F-131): We should drop T from here because it is strange as there\n    /// is no return value. The PublicCall type seems to be defined\n    /// incorrectly.\n    pub fn enqueue<let M: u32, let N: u32, T>(&mut self, call: PublicCall<M, N, T>)\n    where\n        T: Deserialize,\n    {\n        call.enqueue(self.context)\n    }\n\n    /// Enqueues a read-only call to the public function defined by the `call` parameter.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state, emit L2->L1 messages, nor emit events. Any nested\n    /// calls are constrained to also be static calls.\n    ///\n    /// # Arguments\n    /// * `call` - The object representing the read-only public function to enqueue.\n    ///\n    /// # Example\n    /// ```noir\n    /// self.enqueue_view(MyContract::at(address).assert_timestamp_less_than(timestamp));\n    /// ```\n    ///\n    /// TODO(F-131): We should drop T from here because it is strange as there\n    /// is no return value. The PublicCall type seems to be defined\n    /// incorrectly.\n    pub fn enqueue_view<let M: u32, let N: u32, T>(&mut self, call: PublicStaticCall<M, N, T>)\n    where\n        T: Deserialize,\n    {\n        call.enqueue_view(self.context)\n    }\n\n    /// Enqueues a call to the public function defined by the `call` parameter,\n    /// to be executed later.\n    ///\n    /// As per `enqueue`, but hides this calling contract's address from the\n    /// target public function.\n    /// This means the origin of the call (msg_sender) will not be publicly\n    /// visible to any blockchain observers, nor to the target public function.\n    /// When the target public function reads `context.msg_sender()` it will\n    /// receive an `Option<AztecAddress>::none`.\n    ///\n    /// NOTES:\n    /// - Not all public functions will accept a msg_sender of \"none\". Many\n    ///   public functions will require that msg_sender is \"some\" and will\n    ///   revert otherwise. Therefore, if using `enqueue_incognito`, you must\n    ///   understand whether the function you're calling will accept a\n    ///   msg_sender of \"none\".\n    ///   Lots of public bookkeeping patterns rely on knowing which address made\n    ///   the call, so as to ascribe state against the caller's address.\n    ///   (There are patterns whereby bookkeeping could instead be done in\n    ///   private-land).\n    /// - If you are enqueueing a call to an _internal_ public function (i.e.\n    ///   a public function that will only accept calls from other functions\n    ///   of its own contract), then by definition a call to it cannot possibly\n    ///   be \"incognito\": the msg_sender must be its own address, and indeed the\n    ///   called public function will assert this. Tl;dr this is not usable for\n    ///   enqueued internal public calls.\n    ///\n    /// # Arguments\n    /// * `call` - The object representing the public function to enqueue.\n    ///\n    /// # Example\n    /// ```noir\n    /// self.enqueue_incognito(Token::at(address).increase_total_supply_by(amount));\n    /// ```\n    ///\n    /// Advanced:\n    /// - The kernel circuits will permit _any_ private function to set the\n    ///   msg_sender field of any enqueued public function call to\n    ///   NULL_MSG_SENDER_CONTRACT_ADDRESS.\n    /// - When the called public function calls `PublicContext::msg_sender()`,\n    ///   aztec-nr will translate NULL_MSG_SENDER_CONTRACT_ADDRESS into\n    ///   `Option<AztecAddress>::none` for familiarity to devs.\n    ///\n    /// TODO(F-131): We should drop T from here because it is strange as there\n    /// is no return value. The PublicCall type seems to be defined\n    /// incorrectly.\n    pub fn enqueue_incognito<let M: u32, let N: u32, T>(&mut self, call: PublicCall<M, N, T>)\n    where\n        T: Deserialize,\n    {\n        call.enqueue_incognito(self.context)\n    }\n\n    /// Enqueues a read-only call to the public function defined by the `call` parameter.\n    ///\n    /// As per `enqueue_view`, but hides this calling contract's address from\n    /// the target public function.\n    ///\n    /// See `enqueue_incognito` for more details relating to hiding msg_sender.\n    ///\n    /// # Arguments\n    /// * `call` - The object representing the read-only public function to enqueue.\n    ///\n    /// # Example\n    /// ```noir\n    /// self.enqueue_view_incognito(MyContract::at(address).assert_timestamp_less_than(timestamp));\n    /// ```\n    ///\n    /// TODO(F-131): We should drop T from here because it is strange as there\n    /// is no return value. The PublicCall type seems to be defined\n    /// incorrectly.\n    pub fn enqueue_view_incognito<let M: u32, let N: u32, T>(\n        &mut self,\n        call: PublicStaticCall<M, N, T>,\n    )\n    where\n        T: Deserialize,\n    {\n        call.enqueue_view_incognito(self.context)\n    }\n\n    /// Enqueues a call to the public function defined by the `call` parameter,\n    /// and designates it to be the teardown function for this tx. Only one teardown\n    /// function call can be made by a tx.\n    ///\n    /// Niche function: Only wallet developers and paymaster contract developers\n    /// (aka Fee-payment contracts) will need to make use of this function.\n    ///\n    /// Aztec supports a three-phase execution model: setup, app logic, teardown.\n    /// The phases exist to enable a fee payer to take on the risk of paying\n    /// a transaction fee, safe in the knowledge that their payment (in whatever\n    /// token or method the user chooses) will succeed, regardless of whether\n    /// the app logic will succeed. The \"setup\" phase ensures the fee payer\n    /// has sufficient balance to pay the proposer their fees.\n    /// The teardown phase is primarily intended to: calculate exactly\n    /// how much the user owes, based on gas consumption, and refund the user\n    /// any change.\n    ///\n    /// Note: in some cases, the cost of refunding the user (i.e. DA costs of\n    /// tx side-effects) might exceed the refund amount. For app logic with\n    /// fairly stable and predictable gas consumption, a material refund amount\n    /// is unlikely. For app logic with unpredictable gas consumption, a\n    /// refund might be important to the user (e.g. if a hefty function reverts\n    /// very early). Wallet/FPC/Paymaster developers should be mindful of this.\n    ///\n    /// See `enqueue` for more information about enqueuing public function calls.\n    ///\n    /// # Arguments\n    /// * `call` - The object representing the public function to designate as teardown.\n    ///\n    /// TODO(F-131): We should drop T from here because it is strange as there\n    /// is no return value. The PublicCall type seems to be defined\n    /// incorrectly.\n    pub fn set_as_teardown<let M: u32, let N: u32, T>(&mut self, call: PublicCall<M, N, T>)\n    where\n        T: Deserialize,\n    {\n        call.set_as_teardown(self.context)\n    }\n\n    /// Enqueues a call to the public function defined by the `call` parameter,\n    /// and designates it to be the teardown function for this tx. Only one teardown\n    /// function call can be made by a tx.\n    ///\n    /// As per `set_as_teardown`, but hides this calling contract's address from\n    /// the target public function.\n    ///\n    /// See `enqueue_incognito` for more details relating to hiding msg_sender.\n    ///\n    /// TODO(F-131): We should drop T from here because it is strange as there\n    /// is no return value. The PublicCall type seems to be defined\n    /// incorrectly.\n    pub fn set_as_teardown_incognito<let M: u32, let N: u32, T>(\n        &mut self,\n        call: PublicCall<M, N, T>,\n    )\n    where\n        T: Deserialize,\n    {\n        call.set_as_teardown_incognito(self.context)\n    }\n}\n\n/// Implementation for `ContractSelf` in public execution contexts.\n///\n/// This implementation is used when a contract function is marked with `#[external(\"public\")]`.\n/// Public functions are executed by the sequencer in the Aztec Virtual Machine (AVM) and can work only with public\n/// state.\nimpl<Storage, CallSelf, CallSelfStatic, CallInternal> ContractSelf<PublicContext, Storage, CallSelf, (), CallSelfStatic, (), CallInternal> {\n    /// Creates a new `ContractSelf` instance for a public function.\n    ///\n    /// This constructor is called automatically by the macro system and should not be called directly.\n    pub fn new_public(\n        context: PublicContext,\n        storage: Storage,\n        call_self: CallSelf,\n        call_self_static: CallSelfStatic,\n        internal: CallInternal,\n    ) -> Self {\n        Self {\n            context,\n            storage,\n            address: context.this_address(),\n            call_self,\n            enqueue_self: (),\n            call_self_static,\n            enqueue_self_static: (),\n            internal,\n        }\n    }\n\n    /// Returns the contract address that initiated this function call.\n    ///\n    /// This is similar to `msg.sender` in Solidity (hence the name).\n    ///\n    /// Important Note: If the calling function is a _private_ function, then it had the option of hiding its address\n    /// when enqueuing this public function call. In such cases, this `context.msg_sender()` method will return\n    /// `Option<AztecAddress>::none`. If the calling function is a _public_ function, it will always return an\n    /// `Option<AztecAddress>::some` (i.e. a non-null value).\n    ///\n    /// # Returns\n    /// * `Option<AztecAddress>` - The address of the smart contract that called this function (be it an app contract or\n    ///   a user's account contract).\n    ///\n    /// # Advanced\n    /// * Value is provided by the AVM sender opcode\n    /// * In nested calls, this is the immediate caller, not the original transaction sender\n    ///\n    pub fn msg_sender(self: Self) -> Option<AztecAddress> {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        let maybe_msg_sender = self.context.msg_sender_unsafe();\n        if maybe_msg_sender == NULL_MSG_SENDER_CONTRACT_ADDRESS {\n            Option::none()\n        } else {\n            Option::some(maybe_msg_sender)\n        }\n    }\n\n    /// Emits an event publicly.\n    ///\n    /// Public events are emitted as plaintext and are therefore visible to everyone. This is is the same as Solidity\n    /// events on EVM chains.\n    ///\n    /// Unlike private events, they don't require delivery of an event message.\n    ///\n    /// # Example\n    /// ```noir\n    /// #[event]\n    /// struct Update { value: Field }\n    ///\n    /// #[external(\"public\")]\n    /// fn publish_update(value: Field) {\n    ///     self.emit(Update { value });\n    /// }\n    /// ```\n    ///\n    /// # Cost\n    ///\n    /// Public event emission is achieved by emitting public transaction logs. A total of `N+1` fields are emitted,\n    /// where `N` is the serialization length of the event.\n    pub fn emit<Event>(&mut self, event: Event)\n    where\n        Event: EventInterface + Serialize,\n    {\n        emit_event_in_public(self.context, event);\n    }\n\n    /// Makes the call to the public function defined by the `call` parameter.\n    ///\n    /// Will revert if the called function reverts or runs out of gas.\n    ///\n    /// # Arguments\n    /// * `call` - The object representing the public function to invoke.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    /// # Example\n    /// ```noir\n    /// self.call(Token::at(address).transfer_in_public(recipient, amount));\n    /// ```\n    ///\n    pub unconstrained fn call<let M: u32, let N: u32, T>(self, call: PublicCall<M, N, T>) -> T\n    where\n        T: Deserialize,\n    {\n        call.call(self.context)\n    }\n\n    /// Makes the read-only call to the public function defined by the `call` parameter.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state or emit events. Any nested calls are constrained to\n    /// also be static calls.\n    ///\n    /// Will revert if the called function reverts or runs out of gas.\n    ///\n    /// # Arguments\n    /// * `call` - The object representing the read-only public function to invoke.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    /// # Example\n    /// ```noir\n    /// self.view(Token::at(address).balance_of_public(recipient));\n    /// ```\n    ///\n    pub unconstrained fn view<let M: u32, let N: u32, T>(self, call: PublicStaticCall<M, N, T>) -> T\n    where\n        T: Deserialize,\n    {\n        call.view(self.context)\n    }\n}\n\n/// Implementation for `ContractSelf` in utility execution contexts.\n///\n/// This implementation is used when a contract function is marked with `#[external(\"utility\")]`.\n/// Utility functions are unconstrained functions that can read private state for offchain queries.\n/// They are typically used for view functions that need to access private notes (e.g. a Token's balance_of function).\nimpl<Storage> ContractSelf<UtilityContext, Storage, (), (), (), (), ()> {\n    /// Creates a new `ContractSelf` instance for a utility function.\n    ///\n    /// This constructor is called automatically by the macro system and should not be called directly.\n    pub fn new_utility(context: UtilityContext, storage: Storage) -> Self {\n        Self {\n            context,\n            storage,\n            address: context.this_address(),\n            call_self: (),\n            enqueue_self: (),\n            call_self_static: (),\n            enqueue_self_static: (),\n            internal: (),\n        }\n    }\n}\n","path":"/Users/zac/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/contract_self.nr"},"75":{"source":"use crate::{\n    context::{PrivateContext, PublicContext},\n    event::{\n        event_interface::{compute_private_event_commitment, EventInterface},\n        event_message::EventMessage,\n    },\n    oracle::random::random,\n};\nuse protocol_types::traits::{Serialize, ToField};\n\n/// An event that was emitted in the current contract call.\npub struct NewEvent<Event> {\n    pub(crate) event: Event,\n    pub(crate) randomness: Field,\n    pub(crate) commitment: Field,\n}\n\n/// Equivalent to `self.emit(event)`: see [crate::contract_self::ContractSelf::emit].\npub fn emit_event_in_private<Event>(\n    context: &mut PrivateContext,\n    event: Event,\n) -> EventMessage<Event>\nwhere\n    Event: EventInterface + Serialize,\n{\n    // In private events, we automatically inject randomness to prevent event commitment preimage attacks and event\n    // commitment collisions (the commitments are included in the nullifier tree and duplicate nullifiers are by\n    // definition not allowed).\n\n    // Safety: We use the randomness to preserve the privacy of the event recipient by preventing brute-forcing,\n    // so a malicious sender could use non-random values to make the event less private. But they already know\n    // the full event pre-image anyway, and so the recipient already trusts them to not disclose this information.\n    // We can therefore assume that the sender will cooperate in the random value generation.\n    let randomness = unsafe { random() };\n\n    // The event commitment is emitted as a nullifier instead of as a note because these are simpler: nullifiers cannot\n    // be squashed, making kernel processing simpler, and they have no nonce that recipients need to discover.\n    let commitment = compute_private_event_commitment(event, randomness);\n    context.push_nullifier(commitment);\n\n    EventMessage::new(NewEvent { event, randomness, commitment }, context)\n}\n\n/// Equivalent to `self.emit(event)`: see [crate::contract_self::ContractSelf::emit].\npub fn emit_event_in_public<Event>(context: PublicContext, event: Event)\nwhere\n    Event: EventInterface + Serialize,\n{\n    let mut log_content = [0; <Event as Serialize>::N + 1];\n\n    let serialized_event = event.serialize();\n    for i in 0..serialized_event.len() {\n        log_content[i] = serialized_event[i];\n    }\n\n    // We put the selector in the \"last\" place, to avoid reading or assigning to an expression in an index\n    // TODO(F-224): change this order.\n    log_content[serialized_event.len()] = Event::get_event_type_id().to_field();\n\n    context.emit_public_log(log_content);\n}\n","path":"/Users/zac/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/event/event_emission.nr"},"78":{"source":"use dep::protocol_types::{\n    hash::poseidon2_hash_bytes,\n    traits::{Deserialize, Empty, FromField, Serialize, ToField},\n};\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct EventSelector {\n    // 1st 4-bytes (big-endian leftmost) of abi-encoding of an event.\n    inner: u32,\n}\n\nimpl FromField for EventSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for EventSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for EventSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl EventSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        EventSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n","path":"/Users/zac/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/event/event_selector.nr"},"80":{"source":"use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n        GENERATOR_INDEX__FUNCTION_ARGS, GENERATOR_INDEX__MESSAGE_NULLIFIER,\n        GENERATOR_INDEX__PUBLIC_BYTECODE, GENERATOR_INDEX__PUBLIC_CALLDATA,\n        GENERATOR_INDEX__SECRET_HASH, MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS,\n    },\n    hash::{poseidon2_hash_subarray, poseidon2_hash_with_separator, sha256_to_field},\n    point::Point,\n    traits::ToField,\n};\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_l1_to_l2_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field,\n    leaf_index: Field,\n) -> Field {\n    let mut hash_bytes = [0 as u8; 224];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n    let leaf_index_bytes: [u8; 32] = leaf_index.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n        hash_bytes[i + 192] = leaf_index_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret\npub fn compute_l1_to_l2_message_nullifier(message_hash: Field, secret: Field) -> Field {\n    poseidon2_hash_with_separator([message_hash, secret], GENERATOR_INDEX__MESSAGE_NULLIFIER)\n}\n\n// Computes the hash of input arguments or return values for private functions, or for authwit creation.\npub fn hash_args<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Computes the hash of calldata for public functions.\npub fn hash_calldata_array<let N: u32>(calldata: [Field; N]) -> Field {\n    poseidon2_hash_with_separator(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n}\n\n/**\n * Computes the public bytecode commitment for a contract class.\n * The commitment is `hash([separator, ...bytecode])` where bytecode omits the length prefix present\n * in `packed_bytecode`.\n *\n * @param packed_bytecode - The packed bytecode of the contract class. 0th word is the length in bytes.\n *    packed_bytecode is mutable so that we can avoid copying the array to construct one starting with\n *    separator instead of length.\n * @returns The public bytecode commitment.\n */\npub fn compute_public_bytecode_commitment(\n    mut packed_public_bytecode: [Field; MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS],\n) -> Field {\n    // First field element contains the length of the bytecode\n    let bytecode_length_in_bytes: u32 = packed_public_bytecode[0] as u32;\n    let bytecode_length_in_fields: u32 =\n        (bytecode_length_in_bytes / 31) + (bytecode_length_in_bytes % 31 != 0) as u32;\n    // Don't allow empty public bytecode.\n    // AVM doesn't handle execution of contracts that exist with empty bytecode.\n    assert(bytecode_length_in_fields != 0);\n    assert(bytecode_length_in_fields < MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS);\n\n    // Packed_bytecode's 0th entry is the length. Replace it with separator before hashing.\n    let separator = GENERATOR_INDEX__PUBLIC_BYTECODE.to_field();\n    packed_public_bytecode[0] = separator;\n\n    // `fields_to_hash` is the number of fields from the start of `packed_public_bytecode` that should be included in\n    // the hash. Fields after this length are ignored.\n    // +1 to account for the separator.\n    let num_fields_to_hash = bytecode_length_in_fields + 1;\n\n    poseidon2_hash_subarray(packed_public_bytecode, num_fields_to_hash)\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = [0; 100];\n    for i in 0..100 {\n        input[i] = i as Field;\n    }\n    let hash = hash_args(input);\n    dep::std::println(hash);\n    // Used in yarn-project/stdlib test snapshots:\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n\n#[test]\nunconstrained fn compute_calldata_hash() {\n    let mut input = [0; 100];\n    for i in 0..input.len() {\n        input[i] = i as Field;\n    }\n    let hash = hash_calldata_array(input);\n    // Used in cpp vm2 tests:\n    assert(hash == 0x191383c9f8964afd3ea8879a03b7dda65d6724773966d18dcf80e452736fc1f3);\n}\n\n#[test]\nunconstrained fn public_bytecode_commitment() {\n    let mut input = [0; MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS];\n    let len = 99;\n    for i in 1..len + 1 {\n        input[i] = i as Field;\n    }\n    input[0] = (len as Field) * 31;\n    let hash = compute_public_bytecode_commitment(input);\n    dep::std::println(hash);\n    // Used in cpp vm2 tests:\n    assert(hash == 0x16d621c3387156ef53754679e7b2c9be8f0bceeb44aa59a74991df3b0b42a0bf);\n}\n","path":"/Users/zac/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/hash.nr"},"101":{"source":"use crate::macros::{\n    calls_generation::{\n        external_functions::{\n            generate_external_function_calls, generate_external_function_self_calls_structs,\n        },\n        internal_functions::generate_call_internal_struct,\n    },\n    dispatch::generate_public_dispatch,\n    internals_functions_generation::{create_fn_abi_exports, process_functions},\n    notes::NOTES,\n    storage::STORAGE_LAYOUT_NAME,\n    utils::{\n        get_trait_impl_method, is_fn_contract_library_method, is_fn_external, is_fn_internal,\n        is_fn_test, module_has_storage,\n    },\n};\n\n/// Marks a contract as an Aztec contract, generating the interfaces for its functions and notes, as well as injecting\n/// the `sync_private_state` utility function.\n/// Note: This is a module annotation, so the returned quote gets injected inside the module (contract) itself.\npub comptime fn aztec(m: Module) -> Quoted {\n    // Functions that don't have #[external(...)], #[contract_library_method], or #[test] are not allowed in contracts.\n    check_each_fn_macroified(m);\n\n    // We generate new functions prefixed with `__aztec_nr_internals__` and we replace the original functions' bodies\n    // with `static_assert(false, ...)` to prevent them from being called directly from within the contract.\n    let functions = process_functions(m);\n\n    // We generate structs and their implementations necessary for convenient functions calls.\n    let interface = generate_contract_interface(m);\n    let self_call_structs = generate_external_function_self_calls_structs(m);\n    let call_internal_struct = generate_call_internal_struct(m);\n\n    // We generate ABI exports for all the external functions in the contract.\n    let fn_abi_exports = create_fn_abi_exports(m);\n\n    // We generate `_compute_note_hash_and_nullifier`, `sync_private_state` and `process_message`\n    // functions only if they are not already implemented. If they are implemented we just insert empty\n    // quotes.\n    let contract_library_method_compute_note_hash_and_nullifier = if !m.functions().any(|f| {\n        f.name() == quote { _compute_note_hash_and_nullifier }\n    }) {\n        generate_contract_library_method_compute_note_hash_and_nullifier()\n    } else {\n        quote {}\n    };\n    let sync_private_state_fn_and_abi_export = if !m.functions().any(|f| {\n        f.name() == quote { sync_private_state }\n    }) {\n        generate_sync_private_state()\n    } else {\n        quote {}\n    };\n\n    let process_message_fn_and_abi_export = if !m.functions().any(|f| {\n        f.name() == quote { process_message }\n    }) {\n        generate_process_message()\n    } else {\n        quote {}\n    };\n    let public_dispatch = generate_public_dispatch(m);\n\n    quote {\n        $interface\n        $self_call_structs\n        $call_internal_struct\n        $functions\n        $fn_abi_exports\n        $contract_library_method_compute_note_hash_and_nullifier\n        $public_dispatch\n        $sync_private_state_fn_and_abi_export\n        $process_message_fn_and_abi_export\n    }\n}\n\ncomptime fn generate_contract_interface(m: Module) -> Quoted {\n    let calls = generate_external_function_calls(m);\n\n    let module_name = m.name();\n\n    let has_storage_layout = module_has_storage(m) & STORAGE_LAYOUT_NAME.get(m).is_some();\n    let storage_layout_getter = if has_storage_layout {\n        let storage_layout_name = STORAGE_LAYOUT_NAME.get(m).unwrap();\n        quote {\n            pub fn storage_layout() -> StorageLayoutFields {\n                $storage_layout_name.fields\n            }\n        }\n    } else {\n        quote {}\n    };\n\n    let library_storage_layout_getter = if has_storage_layout {\n        quote {\n            #[contract_library_method]\n            $storage_layout_getter\n        }\n    } else {\n        quote {}\n    };\n\n    quote {\n        pub struct $module_name {\n            pub target_contract: dep::aztec::protocol_types::address::AztecAddress\n        }\n\n        impl $module_name {\n            $calls\n\n            pub fn at(\n                addr: aztec::protocol_types::address::AztecAddress\n            ) -> Self {\n                Self { target_contract: addr }\n            }\n\n            pub fn interface() -> Self {\n                Self { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n            }\n\n            $storage_layout_getter\n        }\n\n        #[contract_library_method]\n        pub fn at(\n            addr: aztec::protocol_types::address::AztecAddress\n        ) -> $module_name {\n            $module_name { target_contract: addr }\n        }\n\n        #[contract_library_method]\n        pub fn interface() -> $module_name {\n            $module_name { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n        }\n\n        $library_storage_layout_getter\n\n    }\n}\n\n/// Generates a contract library method called `_compute_note_hash_and_nullifier` which is used for note\n/// discovery (to create the `aztec::messages::discovery::ComputeNoteHashAndNullifier` function) and to implement the\n/// `compute_note_hash_and_nullifier` unconstrained contract function.\ncomptime fn generate_contract_library_method_compute_note_hash_and_nullifier() -> Quoted {\n    if NOTES.len() > 0 {\n        // Contracts that do define notes produce an if-else chain where `note_type_id` is matched against the\n        // `get_note_type_id()` function of each note type that we know of, in order to identify the note type. Once we\n        // know it we call we correct `unpack` method from the `Packable` trait to obtain the underlying note type, and\n        // compute the note hash (non-siloed) and inner nullifier (also non-siloed).\n\n        let mut if_note_type_id_match_statements_list = &[];\n        for i in 0..NOTES.len() {\n            let typ = NOTES.get(i);\n\n            let get_note_type_id = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteType },\n                quote { get_id },\n            );\n            let unpack = get_trait_impl_method(\n                typ,\n                quote { crate::protocol_types::traits::Packable },\n                quote { unpack },\n            );\n\n            let compute_note_hash = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_note_hash },\n            );\n\n            let compute_nullifier_unconstrained = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_nullifier_unconstrained },\n            );\n\n            let if_or_else_if = if i == 0 {\n                quote { if }\n            } else {\n                quote { else if }\n            };\n\n            if_note_type_id_match_statements_list = if_note_type_id_match_statements_list.push_back(\n                quote {\n                    $if_or_else_if note_type_id == $get_note_type_id() {\n                        // As an extra safety check we make sure that the packed_note BoundedVec has the expected\n                        // length, since we're about to interpret its raw storage as a fixed-size array by calling the\n                        // unpack function on it.\n                        let expected_len = <$typ as $crate::protocol_types::traits::Packable>::N;\n                        let actual_len = packed_note.len();\n                        assert(\n                            actual_len == expected_len,\n                            f\"Expected packed note of length {expected_len} but got {actual_len} for note type id {note_type_id}\"\n                        );\n\n                        let note = $unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n\n                        let note_hash = $compute_note_hash(note, owner, storage_slot, randomness);\n    \n                        // The message discovery process finds settled notes, that is, notes that were created in prior\n                        // transactions and are therefore already part of the note hash tree. We therefore compute the\n                        // nullification note hash by treating the note as a settled note with the provided note nonce.\n                        let note_hash_for_nullification = aztec::note::utils::compute_note_hash_for_nullification(\n                            aztec::note::retrieved_note::RetrievedNote{ \n                                note,\n                                contract_address,\n                                owner,\n                                randomness,\n                                storage_slot,\n                                metadata: aztec::note::note_metadata::SettledNoteMetadata::new(note_nonce).into()\n                            }\n                        );\n\n                        let inner_nullifier = $compute_nullifier_unconstrained(note, owner, note_hash_for_nullification);\n\n                        Option::some(\n                            aztec::messages::discovery::NoteHashAndNullifier {\n                                note_hash, inner_nullifier\n                            }\n                        )\n                    }\n                },\n            );\n        }\n\n        let if_note_type_id_match_statements = if_note_type_id_match_statements_list.join(quote {});\n\n        quote {\n            /// Unpacks an array into a note corresponding to `note_type_id` and then computes its note hash\n            /// (non-siloed) and inner nullifier (non-siloed) assuming the note has been inserted into the note hash\n            /// tree with `note_nonce`.\n            ///\n            /// The signature of this function notably matches the `aztec::messages::discovery::ComputeNoteHashAndNullifier` type,\n            /// and so it can be used to call functions from that module such as `discover_new_messages`, \n            /// `do_process_message` and `attempt_note_discovery`.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                owner: aztec::protocol_types::address::AztecAddress,\n                storage_slot: Field,\n                note_type_id: Field,\n                contract_address: aztec::protocol_types::address::AztecAddress,\n                randomness: Field,\n                note_nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                $if_note_type_id_match_statements\n                else {\n                    Option::none()\n                }\n            }\n        }\n    } else {\n        // Contracts with no notes still implement this function to avoid having special-casing, the implementation\n        // simply throws immediately.\n        quote {\n            /// This contract does not use private notes, so this function should never be called as it will\n            /// unconditionally fail.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                _packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                _owner: aztec::protocol_types::address::AztecAddress,\n                _storage_slot: Field,\n                _note_type_id: Field,\n                _contract_address: aztec::protocol_types::address::AztecAddress,\n                _randomness: Field,\n                _nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                panic(f\"This contract does not use private notes\")\n            }\n        }\n    }\n}\n\ncomptime fn generate_sync_private_state() -> Quoted {\n    quote {\n        pub struct sync_private_state_parameters {}\n\n        #[abi(functions)]\n        pub struct sync_private_state_abi {\n            parameters: sync_private_state_parameters,\n        }\n\n        #[aztec::macros::internals_functions_generation::abi_attributes::abi_utility]\n        unconstrained fn sync_private_state() {\n            let address = aztec::context::utility_context::UtilityContext::new().this_address();\n            \n            aztec::messages::discovery::discover_new_messages(address, _compute_note_hash_and_nullifier);\n        }\n    }\n}\n\ncomptime fn generate_process_message() -> Quoted {\n    quote {\n        pub struct process_message_parameters {\n            pub message_ciphertext: BoundedVec<Field, aztec::messages::encoding::MESSAGE_CIPHERTEXT_LEN>,\n            pub message_context: aztec::messages::processing::message_context::MessageContext,\n        }\n\n        #[abi(functions)]\n        pub struct process_message_abi {\n            parameters: process_message_parameters,\n        }\n\n        #[aztec::macros::internals_functions_generation::abi_attributes::abi_utility]\n        unconstrained fn process_message(\n            message_ciphertext: BoundedVec<Field, aztec::messages::encoding::MESSAGE_CIPHERTEXT_LEN>,\n            message_context: aztec::messages::processing::message_context::MessageContext,\n        ) {\n            let address = aztec::context::utility_context::UtilityContext::new().this_address();\n\n            aztec::messages::discovery::discover_new_messages(address, _compute_note_hash_and_nullifier);     \n            aztec::messages::discovery::process_message::process_message_ciphertext(\n                address,\n                _compute_note_hash_and_nullifier,\n                message_ciphertext,\n                message_context,\n            );\n        }\n    }\n}\n\n/// Checks if each function in the module is marked with either #[external(...)], #[contract_library_method], or #[test].\n/// Non-macroified functions are not allowed in contracts.\ncomptime fn check_each_fn_macroified(m: Module) {\n    for f in m.functions() {\n        let name = f.name();\n        if !is_fn_external(f)\n            & !is_fn_contract_library_method(f)\n            & !is_fn_internal(f)\n            & !is_fn_test(f) {\n            // We  don't suggest that #[contract_library_method] is allowed because we don't want to introduce another\n            // concept\n            panic(\n                f\"Function {name} must be marked as either #[external(...)], #[internal(...)], or #[test]\",\n            );\n        }\n    }\n}\n","path":"/Users/zac/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/macros/aztec.nr"},"106":{"source":"use crate::macros::internals_functions_generation::external_functions_registry::get_public_functions;\nuse super::utils::compute_fn_selector;\nuse poseidon::poseidon2::Poseidon2Hasher;\nuse protocol_types::meta::utils::get_params_len_quote;\nuse std::{collections::umap::UHashMap, hash::BuildHasherDefault, panic};\n\n/// Returns an `fn public_dispatch(...)` function for the given module that's assumed to be an Aztec contract.\npub comptime fn generate_public_dispatch(m: Module) -> Quoted {\n    let functions = get_public_functions(m);\n\n    let unit = get_type::<()>();\n\n    let seen_selectors =\n        &mut UHashMap::<Field, Quoted, BuildHasherDefault<Poseidon2Hasher>>::default();\n\n    let ifs = functions.map(|function: FunctionDefinition| {\n        let parameters = function.parameters();\n        let return_type = function.return_type();\n\n        let selector: Field = compute_fn_selector(function);\n        let fn_name = function.name();\n\n        // Since function selectors are computed as the first 4 bytes of the hash of the function signature,\n        // it's possible to have collisions. With the following check, we ensure it doesn't happen within\n        // the same contract.\n        if seen_selectors.contains_key(selector) {\n            let existing_fn = seen_selectors.get(selector).unwrap();\n            panic(\n                f\"Public function selector collision detected between functions '{fn_name}' and '{existing_fn}'\",\n            );\n        }\n        seen_selectors.insert(selector, fn_name);\n\n        let params_len_quote = get_params_len_quote(parameters);\n\n        let initial_read = if parameters.len() == 0 {\n            quote {}\n        } else {\n            // The initial calldata_copy offset is 1 to skip the Field selector\n            // The expected calldata is the serialization of\n            // - FunctionSelector: the selector of the function intended to dispatch\n            // - Parameters: the parameters of the function intended to dispatch\n            // That is, exactly what is expected for a call to the target function,\n            // but with a selector added at the beginning.\n            quote {\n                let input_calldata: [Field; $params_len_quote] = dep::aztec::context::public_context::calldata_copy(1, $params_len_quote);\n                let mut reader = dep::aztec::protocol_types::utils::reader::Reader::new(input_calldata);\n            }\n        };\n\n        let parameter_index: &mut u32 = &mut 0;\n        let reads = parameters.map(|param: (Quoted, Type)| {\n            let parameter_index_value = *parameter_index;\n            let param_name = f\"arg{parameter_index_value}\".quoted_contents();\n            let param_type = param.1;\n            let read = quote {\n                let $param_name: $param_type = reader.read_struct(dep::aztec::protocol_types::traits::Deserialize::deserialize);\n            };\n            *parameter_index += 1;\n            quote { $read }\n        });\n        let read = reads.join(quote { });\n\n        let mut args = &[];\n        for parameter_index in 0..parameters.len() {\n            let param_name = f\"arg{parameter_index}\".quoted_contents();\n            args = args.push_back(quote { $param_name });\n        }\n\n        // We call a function whose name is prefixed with `__aztec_nr_internals__`. This is necessary because the\n        // original function is intentionally made uncallable, preventing direct invocation within the contract.\n        // Instead, a new function with the same name, but prefixed by `__aztec_nr_internals__`, has been generated to\n        // be called here. For more details see the `process_functions` function.\n        let name = f\"__aztec_nr_internals__{fn_name}\".quoted_contents();\n        let args = args.join(quote { , });\n        let call = quote { $name($args) };\n\n        let return_code = if return_type == unit {\n            quote {\n                $call;\n                // Force early return.\n                dep::aztec::context::public_context::avm_return([]);\n            }\n        } else {\n            quote {\n                let return_value = dep::aztec::protocol_types::traits::Serialize::serialize($call);\n                dep::aztec::context::public_context::avm_return(return_value.as_slice());\n            }\n        };\n\n        let if_ = quote {\n            if selector == $selector {\n                $initial_read\n                $read\n                $return_code\n            }\n        };\n        if_\n    });\n\n    if ifs.len() == 0 {\n        // No dispatch function if there are no public functions\n        quote {}\n    } else {\n        let ifs = ifs.push_back(quote { panic(f\"Unknown selector {selector}\") });\n        let dispatch = ifs.join(quote {  });\n\n        let body = quote {\n            // We mark this as public because our whole system depends on public functions having this attribute.\n            #[aztec::macros::internals_functions_generation::abi_attributes::abi_public]\n            pub unconstrained fn public_dispatch(selector: Field) {\n                $dispatch\n            }\n        };\n\n        body\n    }\n}\n\ncomptime fn get_type<T>() -> Type {\n    let t: T = std::mem::zeroed();\n    std::meta::type_of(t)\n}\n","path":"/Users/zac/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/macros/dispatch.nr"},"109":{"source":"use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress,\n    constants::GENERATOR_INDEX__CONSTRUCTOR, hash::poseidon2_hash_with_separator, traits::ToField,\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext},\n    oracle::get_contract_instance::{\n        get_contract_instance, get_contract_instance_deployer_avm,\n        get_contract_instance_initialization_hash_avm,\n    },\n};\n\n// Used by `create_mark_as_initialized` (you won't find it through searching)\npub fn mark_as_initialized_public(context: PublicContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\n// Used by `create_mark_as_initialized` (you won't find it through searching)\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\n// Used by `create_init_check` (you won't find it through searching)\npub fn assert_is_initialized_public(context: PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\n// Used by `create_init_check` (you won't find it through searching)\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    context.push_nullifier_read_request(init_nullifier, context.this_address());\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\n// Used by `create_assert_correct_initializer_args` (you won't find it through searching)\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let deployer = get_contract_instance_deployer_avm(address).unwrap();\n    let initialization_hash = get_contract_instance_initialization_hash_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (deployer.is_zero()) | (deployer == context.msg_sender().unwrap()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\n// Used by `create_assert_correct_initializer_args` (you won't find it through searching)\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender().unwrap()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\n/// This function is not only used in macros but it's also used by external people to check that an instance has been\n/// initialized with the correct constructor arguments. Don't hide this unless you implement factory functionality.\npub fn compute_initialization_hash(\n    init_selector: FunctionSelector,\n    init_args_hash: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR,\n    )\n}\n","path":"/Users/zac/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/macros/functions/initialization_utils.nr"},"113":{"source":"use crate::macros::{\n    functions::auth_registry::AUTHORIZE_ONCE_REGISTRY,\n    utils::{is_fn_initializer, is_fn_only_self, is_fn_view},\n};\nuse std::meta::ctstring::AsCtString;\n\n/// Gathers all attributes relevant to the function's ABI and returns a quote that can be applied to the newly generated\n/// function. We apply the abi marker attributes instead of the original ones (e.g. abi_view instead of view) to avoid\n/// the relevant attribute's functionality from getting triggered.\npub(crate) comptime fn get_abi_relevant_attributes(f: FunctionDefinition) -> Quoted {\n    let mut attributes = quote {};\n\n    if is_fn_view(f) {\n        attributes = quote { $attributes #[aztec::macros::internals_functions_generation::abi_attributes::abi_view] };\n    }\n\n    if is_fn_only_self(f) {\n        attributes = quote { $attributes #[aztec::macros::internals_functions_generation::abi_attributes::abi_only_self] };\n    }\n\n    if is_fn_initializer(f) {\n        attributes = quote { $attributes #[aztec::macros::internals_functions_generation::abi_attributes::abi_initializer] };\n    }\n\n    attributes\n}\n\n/// Injects a call to `aztec::messages::discovery::discover_new_messages`, causing for new notes to be added to PXE and made\n/// available for the current execution.\npub(crate) comptime fn create_message_discovery_call() -> Quoted {\n    quote {\n        /// Safety: message discovery returns nothing and is performed solely for its side-effects. It is therefore\n        /// always safe to call.\n        unsafe {\n            dep::aztec::messages::discovery::discover_new_messages(\n                self.address,\n                _compute_note_hash_and_nullifier,\n            );\n        };\n    }\n}\n\n/// Injects an authwit verification check of the form:\n/// ```\n///   if (!from.eq(context.msg_sender().unwrap())) {\n///         assert_current_call_valid_authwit::<N>(&mut context, from);\n///     } else {\n///         assert(authwit_nonce, \"Invalid authwit nonce. When 'from' and 'msg_sender' are the same, authwit_nonce must be zero\");\n///     }\n/// ```\n/// where `from` and `authwit_nonce` are the names of the parameters that are expected to be present in the function definition.\n/// This check is injected by the `#[authorize_once(\"from_arg_name\", \"nonce_arg_name\")]`, which allows the user to define\n/// which parameters to use.\n///\n/// # Arguments\n/// * `f` - The function definition to inject the authwit verification check into. The function must have parameters\n///         matching the names specified in the `#[authorize_once]` attribute.\n/// * `is_private` - Whether the function is a private function (`true`) or a public function (`false`). This determines\n///                  which authwit verification method to use: `assert_current_call_valid_authwit` for private functions\n///                  or `assert_current_call_valid_authwit_public` for public functions.\npub(crate) comptime fn create_authorize_once_check(\n    f: FunctionDefinition,\n    is_private: bool,\n) -> Quoted {\n    let maybe_authorize_once_args = AUTHORIZE_ONCE_REGISTRY.get(f);\n    let authorize_once_args = if maybe_authorize_once_args.is_some() {\n        maybe_authorize_once_args.unwrap()\n    } else {\n        // We need to for authorize_once to have already executed so that we can retrieve its params - this depends on\n        // the order in which the attributes are applied.\n        panic(\n            f\"Functions marked with #[authorize_once] must have the #[external(\\\"private\\\")] or #[external(\\\"public\\\")] attribute placed last\",\n        )\n    };\n\n    let (from_arg_name, nonce_arg_name) = authorize_once_args;\n    let name: Quoted = f.name();\n\n    let from_arg_candidates =\n        f.parameters().filter(|(name, _)| name == f\"{from_arg_name}\".quoted_contents());\n    let (from_arg_name_quoted, from_arg_type) = if from_arg_candidates.len() == 1 {\n        from_arg_candidates[0]\n    } else {\n        panic(\n            f\"Function {name} does not have a {from_arg_name} parameter. Please specify which one to use in #[authorize_once(\\\"...\\\", \\\"authwit_nonce\\\")]\",\n        )\n    };\n    if from_arg_type\n        != quote { dep::protocol_types::address::aztec_address::AztecAddress }.as_type() {\n        panic(\n            f\"Argument {from_arg_name_quoted} in function {name} must be of type AztecAddress, but is of type {from_arg_type}\",\n        )\n    }\n\n    let nonce_arg_candidates =\n        f.parameters().filter(|(name, _)| name == f\"{nonce_arg_name}\".quoted_contents());\n    let (nonce_arg_name_quoted, nonce_arg_type) = if nonce_arg_candidates.len() == 1 {\n        nonce_arg_candidates[0]\n    } else {\n        panic(\n            f\"Function {name} does not have a {nonce_arg_name}. Please specify which one to use in #[authorize_once(\\\"from\\\", \\\"...\\\")]\",\n        )\n    };\n    if nonce_arg_type != quote { Field }.as_type() {\n        panic(\n            f\"Argument {nonce_arg_name_quoted} in function {name} must be of type Field, but is of type {nonce_arg_type}\",\n        );\n    }\n\n    let nonce_check_quote = f\"{nonce_arg_name_quoted} == 0\".quoted_contents();\n\n    let fn_call = if is_private {\n        let args_len = f.parameters().len();\n        quote { dep::aztec::authwit::auth::assert_current_call_valid_authwit::<$args_len> }\n    } else {\n        quote { dep::aztec::authwit::auth::assert_current_call_valid_authwit_public }\n    };\n    let invalid_nonce_message = f\"Invalid authwit nonce. When '{from_arg_name}' and 'msg_sender' are the same, '{nonce_arg_name}' must be zero\"\n        .as_ctstring()\n        .as_quoted_str();\n    quote {         \n        if (!$from_arg_name_quoted.eq(self.msg_sender().unwrap())) {\n            $fn_call(self.context, $from_arg_name_quoted);\n        } else {\n            assert($nonce_check_quote, $invalid_nonce_message);\n        }\n    }\n}\n","path":"/Users/zac/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/macros/internals_functions_generation/external/helpers.nr"},"116":{"source":"use crate::macros::{\n    internals_functions_generation::external::helpers::{\n        create_authorize_once_check, get_abi_relevant_attributes,\n    },\n    utils::{\n        fn_has_authorize_once, fn_has_noinitcheck, is_fn_initializer, is_fn_only_self, is_fn_view,\n        module_has_initializer, module_has_storage,\n    },\n};\nuse std::meta::ctstring::AsCtString;\n\npub(crate) comptime fn generate_public_external(f: FunctionDefinition) -> Quoted {\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Public functions undergo a lot of transformations from their Aztec.nr form.\n    let original_params = f.parameters();\n\n    let args_len_quote = if original_params.len() == 0 {\n        // If the function has no parameters, we set the args_len to 0.\n        quote { 0 }\n    } else {\n        // The following will give us <type_of_struct_member_1 as Serialize>::N + <type_of_struct_member_2 as Serialize>::N + ...\n        original_params\n            .map(|(_, param_type): (Quoted, Type)| {\n                quote {\n            <$param_type as $crate::protocol_types::traits::Serialize>::N\n        }\n            })\n            .join(quote {+})\n    };\n\n    let storage_init = if module_has_storage {\n        quote {\n            let storage = Storage::init(context);\n        }\n    } else {\n        // Contract does not have Storage defined, so we set storage to the unit type `()`. ContractSelf requires a\n        // storage struct in its constructor. Using an Option type would lead to worse developer experience and higher\n        // constraint counts so we use the unit type `()` instead.\n        quote {\n            let storage = ();\n        }\n    };\n\n    // Unlike in the private case, in public the `context` does not need to receive the hash of the original params.\n    let contract_self_creation = quote {\n        #[allow(unused_variables)]\n        let mut self = {\n            let context = dep::aztec::context::public_context::PublicContext::new(|| {\n            // We start from 1 because we skip the selector for the dispatch function.\n            let serialized_args : [Field; $args_len_quote] = dep::aztec::context::public_context::calldata_copy(1, $args_len_quote);\n            dep::aztec::hash::hash_args(serialized_args)\n            });\n            $storage_init\n            let self_address = context.this_address();\n            let call_self: CallSelf<aztec::context::public_context::PublicContext> = CallSelf { address: self_address, context };\n            let call_self_static: CallSelfStatic<aztec::context::public_context::PublicContext> = CallSelfStatic { address: self_address, context };\n            let internal: CallInternal<aztec::context::public_context::PublicContext> = CallInternal { context };\n            aztec::contract_self::ContractSelf::new_public(context, storage, call_self, call_self_static, internal)\n        };\n    };\n\n    let original_function_name = f.name();\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_only_self(f) {\n        let assertion_message =\n            f\"Function {original_function_name} can only be called by the same contract\";\n        quote { assert(self.msg_sender().unwrap() == self.address, $assertion_message); }\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        let assertion_message = f\"Function {original_function_name} can only be called statically\"\n            .as_ctstring()\n            .as_quoted_str();\n        quote { assert(self.context.is_static_call(), $assertion_message); }\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (\n            quote { aztec::macros::functions::initialization_utils::assert_initialization_matches_address_preimage_public(self.context); },\n            quote { aztec::macros::functions::initialization_utils::mark_as_initialized_public(self.context); },\n        )\n    } else {\n        (quote {}, quote {})\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !fn_has_noinitcheck(f) & !is_fn_initializer(f) {\n        quote { aztec::macros::functions::initialization_utils::assert_is_initialized_public(self.context); }\n    } else {\n        quote {}\n    };\n\n    // Inject the authwit check if the function is marked with #[authorize_once].\n    let authorize_once_check = if fn_has_authorize_once(f) {\n        create_authorize_once_check(f, false)\n    } else {\n        quote {}\n    };\n\n    let to_prepend = quote {\n        $contract_self_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $authorize_once_check\n    };\n\n    let to_append = quote {\n        $mark_as_initialized\n    };\n\n    let fn_name = f\"__aztec_nr_internals__{original_function_name}\".quoted_contents();\n    let body = f.body();\n    let return_type = f.return_type();\n\n    // New function parameters are the same as the original function's ones.\n    let params = original_params\n        .map(|(param_name, param_type)| quote { $param_name: $param_type })\n        .join(quote {, });\n\n    // Preserve all attributes that are relevant to the function's ABI.\n    let abi_relevant_attributes = get_abi_relevant_attributes(f);\n\n    // All public functions are automatically made unconstrained, even if they were not marked as such. This is because\n    // instead of compiling into a circuit, they will compile to bytecode that will be later transpiled into AVM\n    // bytecode.\n    quote {\n        #[aztec::macros::internals_functions_generation::abi_attributes::abi_public]\n        $abi_relevant_attributes\n        unconstrained fn $fn_name($params) -> pub $return_type {\n            $to_prepend\n            $body\n            $to_append\n        }\n    }\n}\n","path":"/Users/zac/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/macros/internals_functions_generation/external/public.nr"},"117":{"source":"use crate::macros::{\n    internals_functions_generation::external::helpers::create_message_discovery_call,\n    utils::module_has_storage,\n};\n\npub(crate) comptime fn generate_utility_external(f: FunctionDefinition) -> Quoted {\n    // Initialize Storage if module has storage\n    let storage_init = if module_has_storage(f.module()) {\n        quote {\n            let storage = Storage::init(context);\n        }\n    } else {\n        // Contract does not have Storage defined, so we set storage to the unit type `()`. ContractSelf requires a\n        // storage struct in its constructor. Using an Option type would lead to worse developer experience and higher\n        // constraint counts so we use the unit type `()` instead.\n        quote {\n            let storage = ();\n        }\n    };\n\n    // Create utility context\n    let contract_self_creation = quote {\n        #[allow(unused_variables)]\n        let mut self = {\n            let context = dep::aztec::context::utility_context::UtilityContext::new();\n            $storage_init\n            aztec::contract_self::ContractSelf::new_utility(context, storage)\n        };\n    };\n\n    // All utility functions perform message discovery, since they may need to access private notes that would be\n    // found during this process or they may be used to sync private events from TypeScript\n    // (`sync_private_state` function gets invoked by PXE::getPrivateEvents function).\n    let message_discovery_call = create_message_discovery_call();\n\n    // A quote to be injected at the beginning of the function body.\n    let to_prepend = quote {\n        dep::aztec::oracle::version::assert_compatible_oracle_version();\n        $contract_self_creation\n        $message_discovery_call\n    };\n\n    let original_function_name = f.name();\n    let fn_name = f\"__aztec_nr_internals__{original_function_name}\".quoted_contents();\n    let body = f.body();\n    let params = f\n        .parameters()\n        .map(|(param_name, param_type)| quote { $param_name: $param_type })\n        .join(quote {, });\n    let return_type = f.return_type();\n\n    quote {\n        #[aztec::macros::internals_functions_generation::abi_attributes::abi_utility]\n        unconstrained fn $fn_name($params) -> pub $return_type {\n            $to_prepend\n            $body\n        }\n    }\n}\n","path":"/Users/zac/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/macros/internals_functions_generation/external/utility.nr"},"126":{"source":"use protocol_types::{address::AztecAddress, debug_log::{debug_log, debug_log_format}};\n\npub mod nonce_discovery;\npub mod partial_notes;\npub mod private_events;\npub mod private_notes;\npub mod process_message;\n\nuse crate::{\n    messages::{\n        discovery::{\n            private_notes::MAX_NOTE_PACKED_LEN, process_message::process_message_ciphertext,\n        },\n        processing::{\n            get_private_logs, pending_tagged_log::PendingTaggedLog,\n            validate_enqueued_notes_and_events,\n        },\n    },\n    utils::array,\n};\n\npub struct NoteHashAndNullifier {\n    /// The result of NoteHash::compute_note_hash\n    pub note_hash: Field,\n    /// The result of NoteHash::compute_nullifier_unconstrained (since all of message discovery is unconstrained)\n    pub inner_nullifier: Field,\n}\n\n/// A function which takes a note's packed content, address of the emitting contract, note nonce, storage slot and note\n/// type ID and attempts to compute its note hash (not hashed by note nonce nor siloed by address) and inner nullifier\n/// (not siloed by address).\n///\n/// This function must be user-provided as its implementation requires knowledge of how note type IDs are allocated in a\n/// contract. The `#[aztec]` macro automatically creates such a contract library method called\n/// `_compute_note_hash_and_nullifier`, which looks something like this:\n///\n/// ```\n/// |packed_note, owner, storage_slot, note_type_id, contract_address, randomness, note_nonce| {\n///     if note_type_id == MyNoteType::get_id() {\n///         assert(packed_note.len() == MY_NOTE_TYPE_SERIALIZATION_LENGTH);\n///\n///         let note = MyNoteType::unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n///\n///         let note_hash = note.compute_note_hash(owner, storage_slot, randomness);\n///         let note_hash_for_nullification = aztec::note::utils::compute_note_hash_for_nullification(\n///             RetrievedNote{ note, contract_address, metadata: SettledNoteMetadata::new(note_nonce).into() },\n///             storage_slot\n///         );\n///\n///         let inner_nullifier = note.compute_nullifier_unconstrained(owner, note_hash_for_nullification);\n///\n///         Option::some(\n///             aztec::messages::discovery::NoteHashAndNullifier {\n///                 note_hash, inner_nullifier\n///             }\n///         )\n///     } else if note_type_id == MyOtherNoteType::get_id() {\n///           ... // Similar to above but calling MyOtherNoteType::unpack_content\n///     } else {\n///         Option::none() // Unknown note type ID\n///     };\n/// }\n/// ```\npub type ComputeNoteHashAndNullifier<Env> = unconstrained fn[Env](/* packed_note */BoundedVec<Field, MAX_NOTE_PACKED_LEN>, /* owner */ AztecAddress, /* storage_slot */ Field, /* note_type_id */ Field, /* contract_address */ AztecAddress, /* randomness */ Field, /* note nonce */ Field) -> Option<NoteHashAndNullifier>;\n\n/// Performs the message discovery process, in which private logs are downloaded and inspected to find new private\n/// notes, partial notes and events, etc., and pending partial notes are processed to search for their completion logs.\n/// This is the mechanism via which a contract updates its knowledge of its private state.\n///\n/// Note that the state is synchronized up to the latest block synchronized by PXE. That should be close to the chain\n/// tip as block synchronization is performed before contract function simulation is done.\n///\n/// Receives the address of the contract on which discovery is performed along with its\n/// `compute_note_hash_and_nullifier` function.\npub unconstrained fn discover_new_messages<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    debug_log(\"Performing message discovery\");\n\n    // First we process all private logs, which can contain different kinds of messages e.g. private notes, partial\n    // notes, private events, etc.\n    let mut logs = get_private_logs(contract_address);\n    logs.for_each(|i, pending_tagged_log: PendingTaggedLog| {\n        debug_log_format(\n            \"Processing log with tag {0}\",\n            [pending_tagged_log.log.get(0)],\n        );\n\n        // We remove the tag from the pending tagged log and process the message ciphertext contained in it.\n        let message_ciphertext = array::subbvec(pending_tagged_log.log, 1);\n\n        process_message_ciphertext(\n            contract_address,\n            compute_note_hash_and_nullifier,\n            message_ciphertext,\n            pending_tagged_log.context,\n        );\n        logs.remove(i);\n    });\n\n    // Then we process all pending partial notes, regardless of whether they were found in the current or previous\n    // executions.\n    partial_notes::fetch_and_process_partial_note_completion_logs(\n        contract_address,\n        compute_note_hash_and_nullifier,\n    );\n\n    // Finally we validate all notes and events that were found as part of the previous processes, resulting in them\n    // being added to PXE's database and retrievable via oracles (get_notes) and our TS API (PXE::getPrivateEvents).\n    validate_enqueued_notes_and_events(contract_address);\n}\n","path":"/Users/zac/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/messages/discovery/mod.nr"},"127":{"source":"use crate::messages::discovery::{ComputeNoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::MAX_NOTE_HASHES_PER_TX,\n    debug_log::debug_log_format,\n    hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n    traits::ToField,\n};\n\n/// A struct with the discovered information of a complete note, required for delivery to PXE. Note that this is *not*\n/// the complete note information, since it does not include content, storage slot, etc.\npub struct DiscoveredNoteInfo {\n    pub note_nonce: Field,\n    pub note_hash: Field,\n    pub inner_nullifier: Field,\n}\n\n/// Searches for note nonces that will result in a note that was emitted in a transaction. While rare, it is possible\n/// for multiple notes to have the exact same packed content and storage slot but different nonces, resulting in\n/// different unique note hashes. Because of this this function returns a *vector* of discovered notes, though in most\n/// cases it will contain a single element.\n///\n/// Due to how nonces are computed, this function requires knowledge of the transaction in which the note was created,\n/// more specifically the list of all unique note hashes in it plus the value of its first nullifier.\npub unconstrained fn attempt_note_nonce_discovery<Env>(\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    contract_address: AztecAddress,\n    owner: AztecAddress,\n    storage_slot: Field,\n    randomness: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) -> BoundedVec<DiscoveredNoteInfo, MAX_NOTE_HASHES_PER_TX> {\n    let discovered_notes = &mut BoundedVec::new();\n\n    debug_log_format(\n        \"Attempting nonce discovery on {0} potential notes on contract {1} for storage slot {2}\",\n        [unique_note_hashes_in_tx.len() as Field, contract_address.to_field(), storage_slot],\n    );\n\n    // We need to find nonces (typically just one) that result in a note hash that, once siloed into a unique note hash,\n    // is one of the note hashes created by the transaction.\n    unique_note_hashes_in_tx.for_eachi(|i, expected_unique_note_hash| {\n        // Nonces are computed by hashing the first nullifier in the transaction with the index of the note in the\n        // new note hashes array. We therefore know for each note in every transaction what its nonce is.\n        let candidate_nonce = compute_note_hash_nonce(first_nullifier_in_tx, i);\n\n        // Given note nonce, note content and metadata, we can compute the note hash and silo it to check if it matches\n        // the note hash at the array index we're currently processing.\n        // TODO(#11157): handle failed note_hash_and_nullifier computation\n        let hashes = compute_note_hash_and_nullifier(\n            packed_note,\n            owner,\n            storage_slot,\n            note_type_id,\n            contract_address,\n            randomness,\n            candidate_nonce,\n        )\n            .expect(f\"Failed to compute a note hash for note type {note_type_id}\");\n\n        let siloed_note_hash = compute_siloed_note_hash(contract_address, hashes.note_hash);\n        let unique_note_hash = compute_unique_note_hash(candidate_nonce, siloed_note_hash);\n\n        if unique_note_hash == expected_unique_note_hash {\n            // Note that while we did check that the note hash is the preimage of the expected unique note hash, we\n            // perform no validations on the nullifier - we fundamentally cannot, since only the application knows\n            // how to compute nullifiers. We simply trust it to have provided the correct one: if it hasn't, then\n            // PXE may fail to realize that a given note has been nullified already, and calls to the application\n            // could result in invalid transactions (with duplicate nullifiers). This is not a concern because an\n            // application already has more direct means of making a call to it fail the transaction.\n            discovered_notes.push(\n                DiscoveredNoteInfo {\n                    note_nonce: candidate_nonce,\n                    note_hash: hashes.note_hash,\n                    inner_nullifier: hashes.inner_nullifier,\n                },\n            );\n\n            // We don't exit the loop - it is possible (though rare) for the exact same note content to be present\n            // multiple times in the same transaction with different nonces. This typically doesn't happen due to\n            // notes containing random values in order to hide their contents.\n        }\n    });\n\n    debug_log_format(\n        \"Found valid nonces for a total of {0} notes\",\n        [discovered_notes.len() as Field],\n    );\n\n    *discovered_notes\n}\n\nmod test {\n    use crate::{\n        messages::discovery::{NoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN},\n        note::{\n            note_interface::{NoteHash, NoteType},\n            note_metadata::SettledNoteMetadata,\n            retrieved_note::RetrievedNote,\n            utils::compute_note_hash_for_nullification,\n        },\n        oracle::random::random,\n        test::mocks::mock_note::MockNote,\n        utils::array,\n    };\n\n    use dep::protocol_types::{\n        address::AztecAddress,\n        hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n        traits::{FromField, Packable},\n    };\n\n    use super::attempt_note_nonce_discovery;\n\n    // This implementation could be simpler, but this serves as a nice example of the expected flow in a real\n    // implementation, and as a sanity check that the interface is sufficient.\n    unconstrained fn compute_note_hash_and_nullifier(\n        packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n        owner: AztecAddress,\n        storage_slot: Field,\n        note_type_id: Field,\n        contract_address: AztecAddress,\n        randomness: Field,\n        note_nonce: Field,\n    ) -> Option<NoteHashAndNullifier> {\n        if note_type_id == MockNote::get_id() {\n            let note = MockNote::unpack(array::subarray(packed_note.storage(), 0));\n            let note_hash = note.compute_note_hash(owner, storage_slot, randomness);\n\n            let note_hash_for_nullification = compute_note_hash_for_nullification(\n                RetrievedNote {\n                    note,\n                    contract_address,\n                    owner,\n                    randomness,\n                    storage_slot,\n                    metadata: SettledNoteMetadata::new(note_nonce).into(),\n                },\n            );\n\n            let inner_nullifier =\n                note.compute_nullifier_unconstrained(owner, note_hash_for_nullification);\n\n            Option::some(NoteHashAndNullifier { note_hash, inner_nullifier })\n        } else {\n            Option::none()\n        }\n    }\n\n    global VALUE: Field = 7;\n    global FIRST_NULLIFIER_IN_TX: Field = 47;\n    global CONTRACT_ADDRESS: AztecAddress = AztecAddress::from_field(13);\n    global OWNER: AztecAddress = AztecAddress::from_field(14);\n    global STORAGE_SLOT: Field = 99;\n    global RANDOMNESS: Field = 99;\n\n    #[test]\n    unconstrained fn no_note_hashes() {\n        let unique_note_hashes_in_tx = BoundedVec::new();\n        let packed_note = BoundedVec::new();\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            OWNER,\n            STORAGE_SLOT,\n            RANDOMNESS,\n            MockNote::get_id(),\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    #[test(should_fail_with = \"Failed to compute a note hash\")]\n    unconstrained fn failed_hash_computation() {\n        let unique_note_hashes_in_tx = BoundedVec::from_array([random()]);\n        let packed_note = BoundedVec::new();\n        let note_type_id = 0; // This note type id is unknown to compute_note_hash_and_nullifier\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            OWNER,\n            STORAGE_SLOT,\n            RANDOMNESS,\n            note_type_id,\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    struct NoteAndData {\n        note: MockNote,\n        note_nonce: Field,\n        note_hash: Field,\n        unique_note_hash: Field,\n        inner_nullifier: Field,\n    }\n\n    unconstrained fn construct_note(value: Field, note_index_in_tx: u32) -> NoteAndData {\n        let note_nonce = compute_note_hash_nonce(FIRST_NULLIFIER_IN_TX, note_index_in_tx);\n\n        let retrieved_note = MockNote::new(value)\n            .contract_address(CONTRACT_ADDRESS)\n            .owner(OWNER)\n            .randomness(RANDOMNESS)\n            .storage_slot(STORAGE_SLOT)\n            .note_metadata(SettledNoteMetadata::new(note_nonce).into())\n            .build_retrieved_note();\n        let note = retrieved_note.note;\n\n        let note_hash = note.compute_note_hash(OWNER, STORAGE_SLOT, RANDOMNESS);\n        let unique_note_hash = compute_unique_note_hash(\n            note_nonce,\n            compute_siloed_note_hash(CONTRACT_ADDRESS, note_hash),\n        );\n        let inner_nullifier = note.compute_nullifier_unconstrained(\n            OWNER,\n            compute_note_hash_for_nullification(retrieved_note),\n        );\n\n        NoteAndData { note, note_nonce, note_hash, unique_note_hash, inner_nullifier }\n    }\n\n    #[test]\n    unconstrained fn single_note() {\n        let note_index_in_tx = 2;\n        let note_and_data = construct_note(VALUE, note_index_in_tx);\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(note_index_in_tx, note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            OWNER,\n            STORAGE_SLOT,\n            RANDOMNESS,\n            MockNote::get_id(),\n            BoundedVec::from_array(note_and_data.note.pack()),\n        );\n\n        assert_eq(discovered_notes.len(), 1);\n        let discovered_note = discovered_notes.get(0);\n\n        assert_eq(discovered_note.note_nonce, note_and_data.note_nonce);\n        assert_eq(discovered_note.note_hash, note_and_data.note_hash);\n        assert_eq(discovered_note.inner_nullifier, note_and_data.inner_nullifier);\n    }\n\n    #[test]\n    unconstrained fn multiple_notes_same_preimage() {\n        let first_note_index_in_tx = 3;\n        let first_note_and_data = construct_note(VALUE, first_note_index_in_tx);\n\n        let second_note_index_in_tx = 5;\n        let second_note_and_data = construct_note(VALUE, second_note_index_in_tx);\n\n        // Both notes have the same preimage (and therefore packed representation), so both should be found in the same\n        // call.\n        assert_eq(first_note_and_data.note, second_note_and_data.note);\n        let packed_note = first_note_and_data.note.pack();\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(first_note_index_in_tx, first_note_and_data.unique_note_hash);\n        unique_note_hashes_in_tx.set(second_note_index_in_tx, second_note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            OWNER,\n            STORAGE_SLOT,\n            RANDOMNESS,\n            MockNote::get_id(),\n            BoundedVec::from_array(packed_note),\n        );\n\n        assert_eq(discovered_notes.len(), 2);\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.note_nonce == first_note_and_data.note_nonce)\n                & (discovered_note.note_hash == first_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == first_note_and_data.inner_nullifier)\n        }));\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.note_nonce == second_note_and_data.note_nonce)\n                & (discovered_note.note_hash == second_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == second_note_and_data.inner_nullifier)\n        }));\n    }\n}\n","path":"/Users/zac/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/messages/discovery/nonce_discovery.nr"},"128":{"source":"use crate::{\n    capsules::CapsuleArray,\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n        processing::{\n            enqueue_note_for_validation, get_pending_partial_notes_completion_logs,\n            log_retrieval_response::LogRetrievalResponse,\n        },\n    },\n    utils::array,\n};\n\nuse protocol_types::{\n    address::AztecAddress,\n    debug_log::debug_log_format,\n    hash::sha256_to_field,\n    traits::{Deserialize, FromField, Serialize},\n};\n\n/// [ owner, storage slot, randomness, note_completion_log_tag ]\nglobal PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 4;\nglobal PARTIAL_NOTE_PRIVATE_MSG_CONTENT_OWNER_INDEX: u32 = 0;\nglobal PARTIAL_NOTE_PRIVATE_MSG_CONTENT_STORAGE_SLOT_INDEX: u32 = 1;\nglobal PARTIAL_NOTE_PRIVATE_MSG_CONTENT_RANDOMNESS_INDEX: u32 = 2;\nglobal PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NOTE_COMPLETION_LOG_TAG_INDEX: u32 = 3;\n\n/// Partial notes have a maximum packed length of their private fields bound by extra content in their private message\n/// (e.g. the storage slot, note completion log tag, etc.).\npub global MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\n/// The slot in the PXE capsules where we store a `CapsuleArray` of `DeliveredPendingPartialNote`.\npub global DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT\".as_bytes(),\n);\n\n/// A partial note that was delivered but is still pending completion. Contains the information necessary to find the\n/// log that will complete it and lead to a note being discovered and delivered.\n#[derive(Serialize, Deserialize)]\npub(crate) struct DeliveredPendingPartialNote {\n    pub(crate) note_completion_log_tag: Field,\n    pub(crate) owner: AztecAddress,\n    pub(crate) storage_slot: Field,\n    pub(crate) randomness: Field,\n    pub(crate) note_type_id: Field,\n    pub(crate) packed_private_note_content: BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>,\n    pub(crate) recipient: AztecAddress,\n}\n\npub unconstrained fn process_partial_note_private_msg(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    // We store the information of the partial note we found in a persistent capsule in PXE, so that we can later search\n    // for the public log that will complete it.\n    let pending = decode_partial_note_private_msg(msg_metadata, msg_content, recipient);\n\n    CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    )\n        .push(pending);\n}\n\n/// Searches for logs that would result in the completion of pending partial notes, ultimately resulting in the notes\n/// being delivered to PXE if completed.\npub unconstrained fn fetch_and_process_partial_note_completion_logs<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    let pending_partial_notes = CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    );\n\n    debug_log_format(\n        \"{} pending partial notes\",\n        [pending_partial_notes.len() as Field],\n    );\n\n    // Each of the pending partial notes might get completed by a log containing its public values. For performance\n    // reasons, we fetch all of these logs concurrently and then process them one by one, minimizing the amount of time\n    // waiting for the node roundtrip.\n    let maybe_completion_logs =\n        get_pending_partial_notes_completion_logs(contract_address, pending_partial_notes);\n\n    // Each entry in the maybe completion logs array corresponds to the entry in the pending partial notes array at the\n    // same index. This means we can use the same index as we iterate through the responses to get both the partial note\n    // and the log that might complete it.\n    assert_eq(maybe_completion_logs.len(), pending_partial_notes.len());\n\n    maybe_completion_logs.for_each(|i, maybe_log: Option<LogRetrievalResponse>| {\n        // We clear the completion logs as we read them so that the array is empty by the time we next query it.\n        // TODO(#14943): use volatile arrays to avoid having to manually clear this.\n        maybe_completion_logs.remove(i);\n\n        let pending_partial_note = pending_partial_notes.get(i);\n\n        if maybe_log.is_none() {\n            debug_log_format(\n                \"Found no completion logs for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n\n            // Note that we're not removing the pending partial note from the capsule array, so we will continue\n            // searching for this tagged log when performing message discovery in the future until we either find it or\n            // the entry is somehow removed from the array.\n        } else {\n            debug_log_format(\n                \"Completion log found for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n            let log = maybe_log.unwrap();\n\n            // Public fields are assumed to all be placed at the end of the packed representation, so we combine the\n            // private and public packed fields (i.e. the contents of the private message and public log plaintext to get\n            // the complete packed content.\n            let complete_packed_note = array::append(\n                pending_partial_note.packed_private_note_content,\n                log.log_payload,\n            );\n\n            let discovered_notes = attempt_note_nonce_discovery(\n                log.unique_note_hashes_in_tx,\n                log.first_nullifier_in_tx,\n                compute_note_hash_and_nullifier,\n                contract_address,\n                pending_partial_note.owner,\n                pending_partial_note.storage_slot,\n                pending_partial_note.randomness,\n                pending_partial_note.note_type_id,\n                complete_packed_note,\n            );\n\n            // TODO(#11627): is there anything reasonable we can do if we get a log but it doesn't result in a note\n            // being found?\n            if discovered_notes.len() == 0 {\n                panic(\n                    f\"A partial note's completion log did not result in any notes being found - this should never happen\",\n                );\n            }\n\n            debug_log_format(\n                \"Discovered {0} notes for partial note with tag {1}\",\n                [discovered_notes.len() as Field, pending_partial_note.note_completion_log_tag],\n            );\n\n            discovered_notes.for_each(|discovered_note| {\n                enqueue_note_for_validation(\n                    contract_address,\n                    pending_partial_note.owner,\n                    pending_partial_note.storage_slot,\n                    pending_partial_note.randomness,\n                    discovered_note.note_nonce,\n                    complete_packed_note,\n                    discovered_note.note_hash,\n                    discovered_note.inner_nullifier,\n                    log.tx_hash,\n                    pending_partial_note.recipient,\n                );\n            });\n\n            // Because there is only a single log for a given tag, once we've processed the tagged log then we\n            // simply delete the pending work entry, regardless of whether it was actually completed or not.\n            pending_partial_notes.remove(i);\n        }\n    });\n}\n\nfn decode_partial_note_private_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n    recipient: AztecAddress,\n) -> DeliveredPendingPartialNote {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    // The following ensures that the message content contains at least the minimum number of fields required for a\n    // valid partial note private message. (Refer to the description of\n    // PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN for more information about these fields.)\n    assert(\n        msg_content.len() >= PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all partial note private messages must have at least {PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the partial note private message encoding below must be updated as well.\n    std::static_assert(\n        PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 4,\n        \"unexpected value for PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have four fields that are not the partial note's packed representation,\n    // which are the owner, the storage slot, the randomness, and the note completion log tag.\n    let owner = AztecAddress::from_field(msg_content.get(\n        PARTIAL_NOTE_PRIVATE_MSG_CONTENT_OWNER_INDEX,\n    ));\n    let storage_slot = msg_content.get(PARTIAL_NOTE_PRIVATE_MSG_CONTENT_STORAGE_SLOT_INDEX);\n    let randomness = msg_content.get(PARTIAL_NOTE_PRIVATE_MSG_CONTENT_RANDOMNESS_INDEX);\n    let note_completion_log_tag =\n        msg_content.get(PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NOTE_COMPLETION_LOG_TAG_INDEX);\n\n    let packed_private_note_content: BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN> = array::subbvec(\n        msg_content,\n        PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n    );\n\n    DeliveredPendingPartialNote {\n        note_completion_log_tag,\n        owner,\n        storage_slot,\n        randomness,\n        note_type_id,\n        packed_private_note_content,\n        recipient,\n    }\n}\n","path":"/Users/zac/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/messages/discovery/partial_notes.nr"},"129":{"source":"use crate::{\n    event::event_selector::EventSelector,\n    messages::{encoding::MAX_MESSAGE_CONTENT_LEN, processing::enqueue_event_for_validation},\n    utils::array,\n};\nuse protocol_types::{\n    address::AztecAddress, constants::GENERATOR_INDEX__EVENT_COMMITMENT,\n    hash::poseidon2_hash_with_separator_bounded_vec, traits::FromField,\n};\n\n/// The number of fields in a private event message content that are not the event's serialized representation\n/// (1 field for randomness).\nglobal PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN: u32 = 1;\n\n/// The maximum length of the packed representation of an event's contents. This is limited by private log size,\n/// encryption overhead and extra fields in the message (e.g. message type id, randomness, etc.).\npub global MAX_EVENT_SERIALIZED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN;\n\npub unconstrained fn process_private_event_msg(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n    tx_hash: Field,\n) {\n    // In the case of events, the msg metadata is the event selector.\n    let event_type_id = EventSelector::from_field(msg_metadata as Field);\n\n    assert(\n        msg_content.len() > PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN,\n        f\"Invalid private event message: all private event messages must have at least {PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN} fields\",\n    );\n\n    // If PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the private event message encoding below must be updated as well.\n    std::static_assert(\n        PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN == 1,\n        \"unexpected value for PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN\",\n    );\n\n    let serialized_event_with_randomness = msg_content;\n\n    let event_commitment = poseidon2_hash_with_separator_bounded_vec(\n        serialized_event_with_randomness,\n        GENERATOR_INDEX__EVENT_COMMITMENT,\n    );\n\n    // Randomness was injected into the event payload in `emit_event_in_private` but we have already used it\n    // to compute the event commitment, so we can safely discard it now.\n    let serialized_event = array::subbvec(\n        serialized_event_with_randomness,\n        PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN,\n    );\n\n    enqueue_event_for_validation(\n        contract_address,\n        event_type_id,\n        serialized_event,\n        event_commitment,\n        tx_hash,\n        recipient,\n    );\n}\n","path":"/Users/zac/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/messages/discovery/private_events.nr"},"130":{"source":"use crate::{\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n        processing::enqueue_note_for_validation,\n    },\n    utils::array,\n};\nuse protocol_types::{\n    address::AztecAddress, constants::MAX_NOTE_HASHES_PER_TX, debug_log::debug_log_format,\n    traits::FromField,\n};\n\n/// The number of fields in a private note message content that are not the note's packed representation.\n// See the call to `std::static_assert` below to see what's in these fields.\nglobal PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 3;\nglobal PRIVATE_NOTE_MSG_CONTENT_OWNER_INDEX: u32 = 0;\nglobal PRIVATE_NOTE_MSG_CONTENT_STORAGE_SLOT_INDEX: u32 = 1;\nglobal PRIVATE_NOTE_MSG_CONTENT_RANDOMNESS_INDEX: u32 = 2;\n\n/// The maximum length of the packed representation of a note's contents. This is limited by private log size,\n/// encryption overhead and extra fields in the message (e.g. message type id, storage slot, randomness, etc.).\npub global MAX_NOTE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\npub unconstrained fn process_private_note_msg<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    let (note_type_id, owner, storage_slot, randomness, packed_note) =\n        decode_private_note_msg(msg_metadata, msg_content);\n\n    attempt_note_discovery(\n        contract_address,\n        tx_hash,\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        recipient,\n        compute_note_hash_and_nullifier,\n        owner,\n        storage_slot,\n        randomness,\n        note_type_id,\n        packed_note,\n    );\n}\n\n/// Attempts discovery of a note given information about its contents and the transaction in which it is\n/// suspected the note was created.\npub unconstrained fn attempt_note_discovery<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    owner: AztecAddress,\n    storage_slot: Field,\n    randomness: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) {\n    let discovered_notes = attempt_note_nonce_discovery(\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        compute_note_hash_and_nullifier,\n        contract_address,\n        owner,\n        storage_slot,\n        randomness,\n        note_type_id,\n        packed_note,\n    );\n\n    debug_log_format(\n        \"Discovered {0} notes from a private message\",\n        [discovered_notes.len() as Field],\n    );\n\n    discovered_notes.for_each(|discovered_note| {\n        enqueue_note_for_validation(\n            contract_address,\n            owner,\n            storage_slot,\n            randomness,\n            discovered_note.note_nonce,\n            packed_note,\n            discovered_note.note_hash,\n            discovered_note.inner_nullifier,\n            tx_hash,\n            recipient,\n        );\n    });\n}\n\nfn decode_private_note_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) -> (Field, AztecAddress, Field, Field, BoundedVec<Field, MAX_NOTE_PACKED_LEN>) {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        msg_content.len() > PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all private note messages must have at least {PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the private note message encoding below must be updated as well.\n    std::static_assert(\n        PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 3,\n        \"unexpected value for PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have two fields that are not the note's packed representation, which are the owner and the storage slot.\n    let owner = AztecAddress::from_field(msg_content.get(PRIVATE_NOTE_MSG_CONTENT_OWNER_INDEX));\n    let storage_slot = msg_content.get(PRIVATE_NOTE_MSG_CONTENT_STORAGE_SLOT_INDEX);\n    let randomness = msg_content.get(PRIVATE_NOTE_MSG_CONTENT_RANDOMNESS_INDEX);\n    let packed_note = array::subbvec(msg_content, PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN);\n\n    (note_type_id, owner, storage_slot, randomness, packed_note)\n}\n","path":"/Users/zac/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/messages/discovery/private_notes.nr"},"131":{"source":"use crate::messages::{\n    discovery::{\n        ComputeNoteHashAndNullifier, partial_notes::process_partial_note_private_msg,\n        private_events::process_private_event_msg, private_notes::process_private_note_msg,\n    },\n    encoding::{decode_message, MESSAGE_CIPHERTEXT_LEN, MESSAGE_PLAINTEXT_LEN},\n    encryption::{aes128::AES128, message_encryption::MessageEncryption},\n    msg_type::{\n        PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID, PRIVATE_EVENT_MSG_TYPE_ID, PRIVATE_NOTE_MSG_TYPE_ID,\n    },\n    processing::message_context::MessageContext,\n};\n\nuse protocol_types::{address::AztecAddress, debug_log::{debug_log, debug_log_format}};\n\n/// Processes a message that can contain notes, partial notes, or events.\n///\n/// Notes result in nonce discovery being performed prior to delivery, which requires knowledge of the transaction hash\n/// in which the notes would've been created (typically the same transaction in which the log was emitted), along with\n/// the list of unique note hashes in said transaction and the `compute_note_hash_and_nullifier` function. Once\n/// discovered, the notes are enqueued for validation.\n///\n/// Partial notes result in a pending partial note entry being stored in a PXE capsule, which will later be retrieved to\n/// search for the note's completion public log.\n///\n/// Events are processed by computing an event commitment from the serialized event data and its randomness field, then\n/// enqueueing the event data and commitment for validation.\npub unconstrained fn process_message_ciphertext<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    message_ciphertext: BoundedVec<Field, MESSAGE_CIPHERTEXT_LEN>,\n    message_context: MessageContext,\n) {\n    let message_plaintext_option = AES128::decrypt(message_ciphertext, message_context.recipient);\n\n    if message_plaintext_option.is_some() {\n        process_message_plaintext(\n            contract_address,\n            compute_note_hash_and_nullifier,\n            message_plaintext_option.unwrap(),\n            message_context,\n        );\n    } else {\n        debug_log_format(\n            \"Found invalid message from tx {0}, ignoring\",\n            [message_context.tx_hash],\n        );\n    }\n}\n\npub unconstrained fn process_message_plaintext<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    message_plaintext: BoundedVec<Field, MESSAGE_PLAINTEXT_LEN>,\n    message_context: MessageContext,\n) {\n    // The first thing to do after decrypting the message is to determine what type of message we're processing. We\n    // have 3 message types: private notes, partial notes and events.\n\n    // We decode the message to obtain the message type id, metadata and content.\n    let (msg_type_id, msg_metadata, msg_content) = decode_message(message_plaintext);\n\n    if msg_type_id == PRIVATE_NOTE_MSG_TYPE_ID {\n        debug_log(\"Processing private note msg\");\n\n        process_private_note_msg(\n            contract_address,\n            message_context.tx_hash,\n            message_context.unique_note_hashes_in_tx,\n            message_context.first_nullifier_in_tx,\n            message_context.recipient,\n            compute_note_hash_and_nullifier,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID {\n        debug_log(\"Processing partial note private msg\");\n\n        process_partial_note_private_msg(\n            contract_address,\n            message_context.recipient,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PRIVATE_EVENT_MSG_TYPE_ID {\n        debug_log(\"Processing private event msg\");\n\n        process_private_event_msg(\n            contract_address,\n            message_context.recipient,\n            msg_metadata,\n            msg_content,\n            message_context.tx_hash,\n        );\n    } else {\n        debug_log_format(\"Unknown msg type id {0}\", [msg_type_id as Field]);\n    }\n}\n","path":"/Users/zac/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/messages/discovery/process_message.nr"},"132":{"source":"// TODO(#12750): don't make these values assume we're using AES.\nuse crate::utils::array;\nuse protocol_types::constants::PRIVATE_LOG_CIPHERTEXT_LEN;\n\n// We reassign to the constant here to communicate the distinction between a log and a message. In Aztec.nr, unlike in\n// protocol circuits, we have a concept of a message that can be emitted either as a private log or as an offchain\n// message. Message is a piece of data that is to be eventually delivered to a contract via the `process_message(...)`\n// utility function function that is injected by the #[aztec] macro.\n// Note: PRIVATE_LOG_CIPHERTEXT_LEN is an amount of fields,\n// so MESSAGE_CIPHERTEXT_LEN is the size of the message in fields.\npub global MESSAGE_CIPHERTEXT_LEN: u32 = PRIVATE_LOG_CIPHERTEXT_LEN;\n\n// TODO(#12750): The global variables below should not be here as they are AES128 specific.\n// ciphertext_length (2) + 14 bytes pkcs#7 AES padding.\npub(crate) global HEADER_CIPHERTEXT_SIZE_IN_BYTES: u32 = 16;\n\npub global EPH_PK_X_SIZE_IN_FIELDS: u32 = 1;\npub global EPH_PK_SIGN_BYTE_SIZE_IN_BYTES: u32 = 1;\n\n// (17 - 1) * 31 - 16 - 1 = 479\n// Note: We multiply by 31 because ciphertext bytes are stored in fields using bytes_to_fields, which packs 31 bytes per\n// field (since a Field is ~254 bits and can safely store 31 whole bytes).\nglobal MESSAGE_PLAINTEXT_SIZE_IN_BYTES: u32 = (MESSAGE_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS)\n    * 31\n    - HEADER_CIPHERTEXT_SIZE_IN_BYTES\n    - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES;\n// The plaintext bytes represent Field values that were originally serialized using fields_to_bytes, which converts each\n// Field to 32 bytes. To convert the plaintext bytes back to fields, we divide by 32.\n// 479 / 32 = 14\npub global MESSAGE_PLAINTEXT_LEN: u32 = MESSAGE_PLAINTEXT_SIZE_IN_BYTES / 32;\n\npub global MESSAGE_EXPANDED_METADATA_LEN: u32 = 1;\n\n// The standard message layout is composed of:\n//  - an initial field called the 'expanded metadata'\n//  - an arbitrary number of fields following that called the 'message content'\n//\n// ```\n// message: [ msg_expanded_metadata, ...msg_content ]\n// ```\n//\n// The expanded metadata itself is interpreted as a u128, of which:\n//  - the upper 64 bits are the message type id\n//  - the lower 64 bits are called the 'message metadata'\n//\n// ```\n// msg_expanded_metadata: [  msg_type_id    |  msg_metadata  ]\n//                        <---  64 bits --->|<--- 64 bits --->\n// ```\n//\n// The meaning of the message metadata and message content depend on the value of the message type id. Note that there\n// is nothing special about the message metadata, it _can_ be considered part of the content. It just has a different\n// name to make it distinct from the message content given that it is not a full field.\n\n/// The maximum length of a message's content, i.e. not including the expanded message metadata.\npub global MAX_MESSAGE_CONTENT_LEN: u32 = MESSAGE_PLAINTEXT_LEN - MESSAGE_EXPANDED_METADATA_LEN;\n\n/// Encodes a message following aztec-nr's standard message encoding. This message can later be decoded with\n/// `decode_message` to retrieve the original values.\n///\n/// - The `msg_type` is an identifier that groups types of messages that are all processed the same way, e.g. private\n/// notes or events. Possible values are defined in `aztec::messages::msg_type`.\n/// - The `msg_metadata` and `msg_content` are the values stored in the message, whose meaning depends on the\n///  `msg_type`. The only special thing about `msg_metadata` that separates it from `msg_content` is that it is a u64\n/// instead of a full Field (due to details of how messages are encoded), allowing applications that can fit values into\n/// this smaller variable to achieve higher data efficiency.\npub fn encode_message<let N: u32>(\n    msg_type: u64,\n    msg_metadata: u64,\n    msg_content: [Field; N],\n) -> [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] {\n    std::static_assert(\n        msg_content.len() <= MAX_MESSAGE_CONTENT_LEN,\n        \"Invalid message content: it must have a length of at most MAX_MESSAGE_CONTENT_LEN\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n    let mut message: [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] = std::mem::zeroed();\n\n    message[0] = to_expanded_metadata(msg_type, msg_metadata);\n    for i in 0..msg_content.len() {\n        message[MESSAGE_EXPANDED_METADATA_LEN + i] = msg_content[i];\n    }\n\n    message\n}\n\n/// Decodes a standard aztec-nr message, i.e. one created via `encode_message`, returning the original encoded values.\n///\n/// Note that `encode_message` returns a fixed size array while this function takes a `BoundedVec`: this is because\n/// prior to decoding the message type is unknown, and consequentially not known at compile time. If working with\n/// fixed-size messages, consider using `BoundedVec::from_array` to convert them.\npub unconstrained fn decode_message(\n    message: BoundedVec<Field, MESSAGE_PLAINTEXT_LEN>,\n) -> (u64, u64, BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>) {\n    assert(\n        message.len() >= MESSAGE_EXPANDED_METADATA_LEN,\n        f\"Invalid message: it must have at least {MESSAGE_EXPANDED_METADATA_LEN} fields\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n\n    let msg_expanded_metadata = message.get(0);\n    let (msg_type_id, msg_metadata) = from_expanded_metadata(msg_expanded_metadata);\n    let msg_content = array::subbvec(message, MESSAGE_EXPANDED_METADATA_LEN);\n\n    (msg_type_id, msg_metadata, msg_content)\n}\n\nglobal U64_SHIFT_MULTIPLIER: Field = 2.pow_32(64);\n\nfn to_expanded_metadata(msg_type: u64, msg_metadata: u64) -> Field {\n    // We use multiplication instead of bit shifting operations to shift the type bits as bit shift operations are\n    // expensive in circuits.\n    let type_field: Field = (msg_type as Field) * U64_SHIFT_MULTIPLIER;\n    let msg_metadata_field = msg_metadata as Field;\n\n    type_field + msg_metadata_field\n}\n\nfn from_expanded_metadata(input: Field) -> (u64, u64) {\n    input.assert_max_bit_size::<128>();\n    let msg_metadata = (input as u64);\n    let msg_type = ((input - (msg_metadata as Field)) / U64_SHIFT_MULTIPLIER) as u64;\n    // Use division instead of bit shift since bit shifts are expensive in circuits\n    (msg_type, msg_metadata)\n}\n\nmod tests {\n    use crate::utils::array::subarray::subarray;\n    use super::{\n        decode_message, encode_message, from_expanded_metadata, MAX_MESSAGE_CONTENT_LEN,\n        to_expanded_metadata,\n    };\n\n    global U64_MAX: u64 = (2.pow_32(64) - 1) as u64;\n    global U128_MAX: Field = (2.pow_32(128) - 1);\n\n    #[test]\n    unconstrained fn encode_decode_empty_message(msg_type: u64, msg_metadata: u64) {\n        let encoded = encode_message(msg_type, msg_metadata, []);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_short_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN / 2],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_full_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn to_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let packed = to_expanded_metadata(U64_MAX, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let packed = to_expanded_metadata(U64_MAX, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let packed = to_expanded_metadata(0, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let packed = to_expanded_metadata(0, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn from_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let input = U128_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let input = (U128_MAX - U64_MAX as Field);\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let input = U64_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let input = 0;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn to_from_expanded_metadata(original_msg_type: u64, original_msg_metadata: u64) {\n        let packed = to_expanded_metadata(original_msg_type, original_msg_metadata);\n        let (unpacked_msg_type, unpacked_msg_metadata) = from_expanded_metadata(packed);\n\n        assert_eq(original_msg_type, unpacked_msg_type);\n        assert_eq(original_msg_metadata, unpacked_msg_metadata);\n    }\n}\n","path":"/Users/zac/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/messages/encoding.nr"},"133":{"source":"use dep::protocol_types::{\n    address::AztecAddress,\n    constants::{GENERATOR_INDEX__SYMMETRIC_KEY, GENERATOR_INDEX__SYMMETRIC_KEY_2},\n    hash::poseidon2_hash_with_separator,\n    point::Point,\n    public_keys::AddressPoint,\n};\n\nuse crate::{\n    keys::{ecdh_shared_secret::derive_ecdh_shared_secret, ephemeral::generate_ephemeral_key_pair},\n    messages::{\n        encoding::{\n            EPH_PK_SIGN_BYTE_SIZE_IN_BYTES, EPH_PK_X_SIZE_IN_FIELDS,\n            HEADER_CIPHERTEXT_SIZE_IN_BYTES, MESSAGE_CIPHERTEXT_LEN, MESSAGE_PLAINTEXT_LEN,\n        },\n        encryption::message_encryption::MessageEncryption,\n        logs::arithmetic_generics_utils::{\n            get_arr_of_size__message_bytes__from_PT,\n            get_arr_of_size__message_bytes_padding__from_PT,\n        },\n    },\n    oracle::{\n        aes128_decrypt::aes128_decrypt_oracle, random::random, shared_secret::get_shared_secret,\n    },\n    utils::{\n        array,\n        conversion::{\n            bytes_to_fields::{bytes_from_fields, bytes_to_fields},\n            fields_to_bytes::{fields_from_bytes, fields_to_bytes},\n        },\n        point::{get_sign_of_point, point_from_x_coord_and_sign},\n        random::get_random_bytes,\n    },\n};\n\nuse std::aes128::aes128_encrypt;\n\n/**\n * Computes N close-to-uniformly-random 256 bits from a given ECDH shared_secret.\n *\n * NEVER re-use the same iv and sym_key.\n * DO NOT call this function more than once with the same shared_secret.\n *\n * This function is only known to be safe if shared_secret is computed by combining a \n * random ephemeral key with an address point. See big comment within the body of the function.\n * See big comment within the body of the function.\n */\nfn extract_many_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2_unsafe<let N: u32>(\n    shared_secret: Point,\n) -> [[u8; 32]; N] {\n    /*\n     * Unsafe because of https://eprint.iacr.org/2010/264.pdf Page 13, Lemma 2 (and the * two paragraphs below it).\n     *\n     * If you call this function, you need to be careful and aware of how the arg\n     * `shared_secret` has been derived.\n     *\n     * The paper says that the way you derive aes keys and IVs should be fine with poseidon2\n     * (modelled as a RO), as long as you _don't_ use Poseidon2 as a PRG to generate the * two exponents x & y which multiply to the shared secret S:\n     *\n     * S = [x*y]*G.\n     *\n     * (Otherwise, you would have to \"key\" poseidon2, i.e. generate a uniformly string K\n     * which can be public and compute Hash(x) as poseidon(K,x)).\n     * In that lemma, k would be 2*254=508, and m would be the number of points on the * grumpkin curve (which is close to r according to the Hasse bound).\n     *\n     * Our shared secret S is [esk * address_sk] * G, and the question is: * Can we compute hash(S) using poseidon2 instead of sha256?\n     *\n     * Well, esk is random and not generated with poseidon2, so that's good.\n     * What about address_sk?\n     * Well, address_sk = poseidon2(stuff) + ivsk, so there was some\n     * discussion about whether address_sk is independent of poseidon2.\n     * Given that ivsk is random and independent of poseidon2, the address_sk is also\n     * independent of poseidon2.\n     *\n     * Tl;dr: we believe it's safe to hash S = [esk * address_sk] * G using poseidon2,\n     * in order to derive a symmetric key.\n     *\n     * If you're calling this function for a differently-derived `shared_secret`, be\n     * careful.\n     *\n     */\n\n    /* The output of this function needs to be 32 random bytes.\n     * A single field won't give us 32 bytes of entropy.\n     * So we compute two \"random\" fields, by poseidon-hashing with two different\n     * generators.\n     * We then extract the last 16 (big endian) bytes of each \"random\" field.\n     * Note: we use to_be_bytes because it's slightly more efficient. But we have to\n     * be careful not to take bytes from the \"big end\", because the \"big\" byte is\n     * not uniformly random over the byte: it only has < 6 bits of randomness, because\n     * it's the big end of a 254-bit field element.\n     */\n\n    let mut all_bytes: [[u8; 32]; N] = std::mem::zeroed();\n    // We restrict N to be < 2^8, because of how we compute the domain separator\n    // from k below (where k <= N must be 8 bits). In practice, it's extremely\n    // unlikely that an app will want to compute >= 256 ciphertexts.\n    std::static_assert(N < 256, \"N too large\");\n    for k in 0..N {\n        // We augment the domain separator with the loop index, so that we can\n        // generate N lots of randomness.\n        let k_shift = (k as u16 << 8);\n        let separator_1 = k_shift + GENERATOR_INDEX__SYMMETRIC_KEY as u16;\n        let separator_2 = k_shift + GENERATOR_INDEX__SYMMETRIC_KEY_2 as u16;\n\n        let rand1: Field =\n            poseidon2_hash_with_separator([shared_secret.x, shared_secret.y], separator_1);\n        let rand2: Field =\n            poseidon2_hash_with_separator([shared_secret.x, shared_secret.y], separator_2);\n\n        let rand1_bytes: [u8; 32] = rand1.to_be_bytes();\n        let rand2_bytes: [u8; 32] = rand2.to_be_bytes();\n\n        let mut bytes: [u8; 32] = [0; 32];\n        for i in 0..16 {\n            // We take bytes from the \"little end\" of the be-bytes arrays:\n            let j = 32 - i - 1;\n            bytes[i] = rand1_bytes[j];\n            bytes[16 + i] = rand2_bytes[j];\n        }\n\n        all_bytes[k] = bytes;\n    }\n\n    all_bytes\n}\n\nfn derive_aes_symmetric_key_and_iv_from_uniformly_random_256_bits<let N: u32>(\n    many_random_256_bits: [[u8; 32]; N],\n) -> [([u8; 16], [u8; 16]); N] {\n    // Many (sym_key, iv) pairs:\n    let mut many_pairs: [([u8; 16], [u8; 16]); N] = std::mem::zeroed();\n    for k in 0..N {\n        let random_256_bits = many_random_256_bits[k];\n        let mut sym_key = [0; 16];\n        let mut iv = [0; 16];\n        for i in 0..16 {\n            sym_key[i] = random_256_bits[i];\n            iv[i] = random_256_bits[i + 16];\n        }\n        many_pairs[k] = (sym_key, iv);\n    }\n\n    many_pairs\n}\n\npub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2_unsafe<let N: u32>(\n    shared_secret: Point,\n) -> [([u8; 16], [u8; 16]); N] {\n    let many_random_256_bits: [[u8; 32]; N] = extract_many_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2_unsafe(\n        shared_secret,\n    );\n\n    derive_aes_symmetric_key_and_iv_from_uniformly_random_256_bits(many_random_256_bits)\n}\n\npub struct AES128 {}\n\nimpl MessageEncryption for AES128 {\n    fn encrypt<let PlaintextLen: u32>(\n        plaintext: [Field; PlaintextLen],\n        recipient: AztecAddress,\n    ) -> [Field; MESSAGE_CIPHERTEXT_LEN] {\n        // AES 128 operates on bytes, not fields, so we need to convert the fields to bytes.\n        // (This process is then reversed when processing the message in `do_process_message`)\n        let plaintext_bytes = fields_to_bytes(plaintext);\n\n        // *****************************************************************************\n        // Compute the shared secret\n        // *****************************************************************************\n\n        let (eph_sk, eph_pk) = generate_ephemeral_key_pair();\n\n        let eph_pk_sign_byte: u8 = get_sign_of_point(eph_pk) as u8;\n\n        // (not to be confused with the tagging shared secret)\n        // TODO (#17158): Currently we unwrap the Option returned by derive_ecdh_shared_secret.\n        // We need to handle the case where the ephemeral public key is invalid to prevent potential DoS vectors.\n        let ciphertext_shared_secret = derive_ecdh_shared_secret(\n            eph_sk,\n            recipient\n                .to_address_point()\n                .unwrap_or(\n                    // Safety: if the recipient is an invalid address, then it is not possible to encrypt a message for\n                    // them because we cannot establish a shared secret. This is never expected to occur during normal\n                    // operation. However, it is technically possible for us to receive an invalid address, and we must\n                    // therefore handle it.\n                    // We could simply fail, but that'd introduce a potential security issue in which an attacker forces\n                    // a contract to encrypt a message for an invalid address, resulting in an impossible transaction -\n                    // this is sometimes called a 'king of the hill' attack.\n                    // We choose instead to not fail and encrypt the plaintext regardless using the shared secret that\n                    // results from a random valid address. The sender is free to choose this address and hence shared\n                    // secret, but this has no security implications as they already know not only the full plaintext\n                    // but also the ephemeral private key anyway.\n                    unsafe { random_address_point() },\n                )\n                .inner,\n        );\n        // TODO: also use this shared secret for deriving note randomness.\n\n        // *****************************************************************************\n        // Convert the plaintext into whatever format the encryption function expects\n        // *****************************************************************************\n\n        // Already done for this strategy: AES expects bytes.\n\n        // *****************************************************************************\n        // Encrypt the plaintext\n        // *****************************************************************************\n\n        // It is safe to call the `unsafe` function here, because we know the `shared_secret`\n        // was derived using an AztecAddress (the recipient). See the block comment\n        // at the start of this unsafe target function for more info.\n        let pairs = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2_unsafe::<2>(\n            ciphertext_shared_secret,\n        );\n        let (body_sym_key, body_iv) = pairs[0];\n        let (header_sym_key, header_iv) = pairs[1];\n\n        let ciphertext_bytes = aes128_encrypt(plaintext_bytes, body_iv, body_sym_key);\n\n        // |full_pt| = |pt_length| + |pt|\n        // |pt_aes_padding| = 16 - (|full_pt| % 16)\n        // or... since a % b is the same as a - b * (a // b) (integer division), so:\n        // |pt_aes_padding| = 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        // |ct| = |full_pt| + |pt_aes_padding|\n        //      = |full_pt| + 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        //      = 16 + 16 * (|full_pt| // 16)\n        //      = 16 * (1 + |full_pt| // 16)\n        std::static_assert(\n            ciphertext_bytes.len() == 16 * (1 + (PlaintextLen * 32) / 16),\n            \"unexpected ciphertext length\",\n        );\n\n        // *****************************************************************************\n        // Compute the header ciphertext\n        // *****************************************************************************\n\n        // Header contains only the length of the ciphertext stored in 2 bytes.\n        let mut header_plaintext: [u8; 2] = [0 as u8; 2];\n        let ciphertext_bytes_length = ciphertext_bytes.len();\n        header_plaintext[0] = (ciphertext_bytes_length >> 8) as u8;\n        header_plaintext[1] = ciphertext_bytes_length as u8;\n\n        // Note: the aes128_encrypt builtin fn automatically appends bytes to the\n        // input, according to pkcs#7; hence why the output `header_ciphertext_bytes` is 16\n        // bytes larger than the input in this case.\n        let header_ciphertext_bytes = aes128_encrypt(header_plaintext, header_iv, header_sym_key);\n        // I recall that converting a slice to an array incurs constraints, so I'll check the length this way instead:\n        std::static_assert(\n            header_ciphertext_bytes.len() == HEADER_CIPHERTEXT_SIZE_IN_BYTES,\n            \"unexpected ciphertext header length\",\n        );\n\n        // *****************************************************************************\n        // Prepend / append more bytes of data to the ciphertext, before converting back\n        // to fields.\n        // *****************************************************************************\n\n        let mut message_bytes_padding_to_mult_31 =\n            get_arr_of_size__message_bytes_padding__from_PT::<PlaintextLen * 32>();\n        // Safety: this randomness won't be constrained to be random. It's in the\n        // interest of the executor of this fn to encrypt with random bytes.\n        message_bytes_padding_to_mult_31 = unsafe { get_random_bytes() };\n\n        let mut message_bytes = get_arr_of_size__message_bytes__from_PT::<PlaintextLen * 32>();\n\n        std::static_assert(\n            message_bytes.len() % 31 == 0,\n            \"Unexpected error: message_bytes.len() should be divisible by 31, by construction.\",\n        );\n\n        message_bytes[0] = eph_pk_sign_byte;\n        let mut offset = 1;\n        for i in 0..header_ciphertext_bytes.len() {\n            message_bytes[offset + i] = header_ciphertext_bytes[i];\n        }\n        offset += header_ciphertext_bytes.len();\n\n        for i in 0..ciphertext_bytes.len() {\n            message_bytes[offset + i] = ciphertext_bytes[i];\n        }\n        offset += ciphertext_bytes.len();\n\n        for i in 0..message_bytes_padding_to_mult_31.len() {\n            message_bytes[offset + i] = message_bytes_padding_to_mult_31[i];\n        }\n        offset += message_bytes_padding_to_mult_31.len();\n\n        // Ideally we would be able to have a static assert where we check that the offset would be such that we've\n        // written to the entire log_bytes array, but we cannot since Noir does not treat the offset as a comptime\n        // value (despite the values that it goes through being known at each stage). We instead check that the\n        // computation used to obtain the offset computes the expected value (which we _can_ do in a static check), and\n        // then add a cheap runtime check to also validate that the offset matches this.\n        std::static_assert(\n            1\n                + header_ciphertext_bytes.len()\n                + ciphertext_bytes.len()\n                + message_bytes_padding_to_mult_31.len()\n                == message_bytes.len(),\n            \"unexpected message length\",\n        );\n        assert(offset == message_bytes.len(), \"unexpected encrypted message length\");\n\n        // *****************************************************************************\n        // Convert bytes back to fields\n        // *****************************************************************************\n\n        // TODO(#12749): As Mike pointed out, we need to make messages produced by different encryption schemes\n        // indistinguishable from each other and for this reason the output here and in the last for-loop of this function\n        // should cover a full field.\n        let message_bytes_as_fields = bytes_to_fields(message_bytes);\n\n        // *****************************************************************************\n        // Prepend / append fields, to create the final message\n        // *****************************************************************************\n\n        let mut ciphertext: [Field; MESSAGE_CIPHERTEXT_LEN] = [0; MESSAGE_CIPHERTEXT_LEN];\n\n        ciphertext[0] = eph_pk.x;\n\n        let mut offset = 1;\n        for i in 0..message_bytes_as_fields.len() {\n            ciphertext[offset + i] = message_bytes_as_fields[i];\n        }\n        offset += message_bytes_as_fields.len();\n\n        for i in offset..MESSAGE_CIPHERTEXT_LEN {\n            // We need to get a random value that fits in 31 bytes to not leak information about the size of the message\n            // (all the \"real\" message fields contain at most 31 bytes because of the way we convert the bytes to fields).\n            // TODO(#12749): Long term, this is not a good solution.\n\n            // Safety: we assume that the sender wants for the message to be private - a malicious one could simply reveal its\n            // contents publicly. It is therefore fine to trust the sender to provide random padding.\n            let field_bytes = unsafe { get_random_bytes::<31>() };\n            ciphertext[i] = Field::from_be_bytes::<31>(field_bytes);\n        }\n\n        ciphertext\n    }\n\n    unconstrained fn decrypt(\n        ciphertext: BoundedVec<Field, MESSAGE_CIPHERTEXT_LEN>,\n        recipient: AztecAddress,\n    ) -> Option<BoundedVec<Field, MESSAGE_PLAINTEXT_LEN>> {\n        let eph_pk_x = ciphertext.get(0);\n\n        let ciphertext_without_eph_pk_x_fields = array::subbvec::<Field, MESSAGE_CIPHERTEXT_LEN, MESSAGE_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS>(\n            ciphertext,\n            EPH_PK_X_SIZE_IN_FIELDS,\n        );\n\n        // Convert the ciphertext represented as fields to a byte representation (its original format)\n        let ciphertext_without_eph_pk_x = bytes_from_fields(ciphertext_without_eph_pk_x_fields);\n\n        // First byte of the ciphertext represents the ephemeral public key sign\n        let eph_pk_sign_bool = ciphertext_without_eph_pk_x.get(0) != 0;\n\n        // With the sign and the x-coordinate of the ephemeral public key, we can reconstruct the point. This may fail\n        // however, as not all x-coordinates are on the curve. In that case, we simply return `Option::none`.\n        point_from_x_coord_and_sign(eph_pk_x, eph_pk_sign_bool).map(|eph_pk| {\n            // Derive shared secret\n            let ciphertext_shared_secret = get_shared_secret(recipient, eph_pk);\n\n            // Derive symmetric keys:\n            let pairs = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2_unsafe::<2>(\n                ciphertext_shared_secret,\n            );\n            let (body_sym_key, body_iv) = pairs[0];\n            let (header_sym_key, header_iv) = pairs[1];\n\n            // Extract the header ciphertext\n            let header_start = EPH_PK_SIGN_BYTE_SIZE_IN_BYTES; // Skip eph_pk_sign byte\n            let header_ciphertext: [u8; HEADER_CIPHERTEXT_SIZE_IN_BYTES] =\n                array::subarray(ciphertext_without_eph_pk_x.storage(), header_start);\n            // We need to convert the array to a BoundedVec because the oracle expects a BoundedVec as it's designed to work\n            // with messages with unknown length at compile time. This would not be necessary here as the header ciphertext length\n            // is fixed. But we do it anyway to not have to have duplicate oracles.\n            let header_ciphertext_bvec =\n                BoundedVec::<u8, HEADER_CIPHERTEXT_SIZE_IN_BYTES>::from_array(header_ciphertext);\n\n            // Decrypt header\n            let header_plaintext =\n                aes128_decrypt_oracle(header_ciphertext_bvec, header_iv, header_sym_key);\n\n            // Extract ciphertext length from header (2 bytes, big-endian)\n            let ciphertext_length =\n                ((header_plaintext.get(0) as u32) << 8) | (header_plaintext.get(1) as u32);\n\n            // Extract and decrypt main ciphertext\n            let ciphertext_start = header_start + HEADER_CIPHERTEXT_SIZE_IN_BYTES;\n            let ciphertext_with_padding: [u8; (MESSAGE_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES] =\n                array::subarray(ciphertext_without_eph_pk_x.storage(), ciphertext_start);\n            let ciphertext: BoundedVec<u8, (MESSAGE_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES> =\n                BoundedVec::from_parts(ciphertext_with_padding, ciphertext_length);\n\n            // Decrypt main ciphertext and return it\n            let plaintext_bytes = aes128_decrypt_oracle(ciphertext, body_iv, body_sym_key);\n\n            // Each field of the original note message was serialized to 32 bytes so we convert the bytes back to fields.\n            fields_from_bytes(plaintext_bytes)\n        })\n    }\n}\n\n/// Produces a random valid address point, i.e. one that is on the curve. This is equivalent to calling\n/// [AztecAddress::to_address_point] on a random valid address.\nunconstrained fn random_address_point() -> AddressPoint {\n    let mut result = std::mem::zeroed();\n\n    loop {\n        // We simply produce random x coordinates until we find one that is on the curve. About half of the x\n        // coordinates fulfill this condition, so this should only take a few iterations at most.\n        let x_coord = random();\n        let point = point_from_x_coord_and_sign(x_coord, true);\n        if point.is_some() {\n            result = AddressPoint { inner: point.unwrap() };\n            break;\n        }\n    }\n\n    result\n}\n\nmod test {\n    use crate::{\n        keys::ecdh_shared_secret::derive_ecdh_shared_secret,\n        messages::{\n            encoding::MESSAGE_PLAINTEXT_LEN, encryption::message_encryption::MessageEncryption,\n        },\n        test::helpers::test_environment::TestEnvironment,\n    };\n    use super::{AES128, random_address_point};\n    use protocol_types::{address::AztecAddress, traits::FromField};\n    use std::{embedded_curve_ops::EmbeddedCurveScalar, test::OracleMock};\n\n    #[test]\n    unconstrained fn encrypt_decrypt_deterministic() {\n        let env = TestEnvironment::new();\n\n        // Message decryption requires oracles that are only available during private execution\n        env.private_context(|_| {\n            let plaintext = [1, 2, 3];\n\n            let recipient = AztecAddress::from_field(\n                0x25afb798ea6d0b8c1618e50fdeafa463059415013d3b7c75d46abf5e242be70c,\n            );\n\n            // Mock random values for deterministic test\n            let eph_sk = 0x1358d15019d4639393d62b97e1588c095957ce74a1c32d6ec7d62fe6705d9538;\n            let _ = OracleMock::mock(\"utilityGetRandomField\").returns(eph_sk).times(1);\n\n            let randomness = 0x0101010101010101010101010101010101010101010101010101010101010101;\n            let _ = OracleMock::mock(\"utilityGetRandomField\").returns(randomness).times(1000000);\n\n            let _ = OracleMock::mock(\"privateGetNextAppTagAsSender\").returns(42);\n\n            // Encrypt the message\n            let encrypted_message = BoundedVec::from_array(AES128::encrypt(plaintext, recipient));\n\n            // Mock shared secret for deterministic test\n            let shared_secret = derive_ecdh_shared_secret(\n                EmbeddedCurveScalar::from_field(eph_sk),\n                recipient.to_address_point().unwrap().inner,\n            );\n\n            let _ = OracleMock::mock(\"utilityGetSharedSecret\").returns(shared_secret);\n\n            // Decrypt the message\n            let decrypted = AES128::decrypt(encrypted_message, recipient).unwrap();\n\n            // The decryption function spits out a BoundedVec because it's designed to work with messages with unknown length\n            // at compile time. For this reason we need to convert the original input to a BoundedVec.\n            let plaintext_bvec = BoundedVec::<Field, MESSAGE_PLAINTEXT_LEN>::from_array(plaintext);\n\n            // Verify decryption matches original plaintext\n            assert_eq(\n                decrypted,\n                plaintext_bvec,\n                \"Decrypted bytes should match original plaintext\",\n            );\n\n            // The following is a workaround of \"struct is never constructed\" Noir compilation error (we only ever use\n            // static methods of the struct).\n            let _ = AES128 {};\n        });\n    }\n\n    #[test]\n    unconstrained fn encrypt_decrypt_random() {\n        // Same as `encrypt_decrypt_deterministic`, except we don't mock any of the oracles and rely on\n        // `TestEnvironment` instead.\n        let mut env = TestEnvironment::new();\n\n        let recipient = env.create_light_account();\n\n        env.private_context(|_| {\n            let plaintext = [1, 2, 3];\n            let ciphertext = AES128::encrypt(plaintext, recipient);\n\n            assert_eq(\n                AES128::decrypt(BoundedVec::from_array(ciphertext), recipient).unwrap(),\n                BoundedVec::from_array(plaintext),\n            );\n        });\n    }\n\n    #[test]\n    unconstrained fn encrypt_to_invalid_address() {\n        // x = 3 is a non-residue for this curve, resulting in an invalid address\n        let invalid_address = AztecAddress { inner: 3 };\n\n        // We just test that we produced some output and did not crash - the result is gibberish as it is encrypted\n        // using a public key for which we do not know the private key.\n        let _ = AES128::encrypt([1, 2, 3, 4], invalid_address);\n    }\n\n    #[test]\n    unconstrained fn random_address_point_produces_valid_points() {\n        // About half of random addresses are invalid, so testing just a couple gives us high confidence that\n        // `random_address_point` is indeed producing valid addresses.\n        for _ in 0..10 {\n            let random_address = AztecAddress { inner: random_address_point().inner.x };\n            assert(random_address.to_address_point().is_some());\n        }\n    }\n\n    #[test]\n    unconstrained fn decrypt_invalid_ephemeral_public_key() {\n        let mut env = TestEnvironment::new();\n\n        let recipient = env.create_light_account();\n\n        env.private_context(|_| {\n            let plaintext = [1, 2, 3, 4];\n            let ciphertext = AES128::encrypt(plaintext, recipient);\n\n            // The first field of the ciphertext is the x-coordinate of the ephemeral public key. We set it to a known\n            // non-residue (3), causing `decrypt` to fail to produce a decryption shared secret.\n            let mut bad_ciphertext = BoundedVec::from_array(ciphertext);\n            bad_ciphertext.set(0, 3);\n\n            assert(AES128::decrypt(bad_ciphertext, recipient).is_none());\n        });\n    }\n}\n","path":"/Users/zac/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/messages/encryption/aes128.nr"},"150":{"source":"pub(crate) mod event_validation_request;\npub mod message_context;\npub(crate) mod note_validation_request;\npub(crate) mod log_retrieval_request;\npub(crate) mod log_retrieval_response;\npub(crate) mod pending_tagged_log;\n\nuse crate::{\n    capsules::CapsuleArray,\n    event::event_selector::EventSelector,\n    messages::{\n        discovery::{\n            partial_notes::DeliveredPendingPartialNote, private_events::MAX_EVENT_SERIALIZED_LEN,\n            private_notes::MAX_NOTE_PACKED_LEN,\n        },\n        processing::{\n            log_retrieval_request::LogRetrievalRequest,\n            log_retrieval_response::LogRetrievalResponse,\n            note_validation_request::NoteValidationRequest, pending_tagged_log::PendingTaggedLog,\n        },\n    },\n    oracle,\n};\nuse event_validation_request::EventValidationRequest;\nuse protocol_types::{address::AztecAddress, hash::sha256_to_field};\n\n// Base slot for the pending tagged log array to which the fetch_tagged_logs oracle inserts found private logs.\nglobal PENDING_TAGGED_LOG_ARRAY_BASE_SLOT: Field =\n    sha256_to_field(\"AZTEC_NR::PENDING_TAGGED_LOG_ARRAY_BASE_SLOT\".as_bytes());\n\nglobal NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\nglobal EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\nglobal LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\nglobal LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\n/// Searches for private logs emitted by `contract_address` that might contain messages for one of the local accounts,\n/// and stores them in a `CapsuleArray` which is then returned.\npub(crate) unconstrained fn get_private_logs(\n    contract_address: AztecAddress,\n) -> CapsuleArray<PendingTaggedLog> {\n    // We will eventually perform log discovery via tagging here, but for now we simply call the `fetchTaggedLogs`\n    // oracle. This makes PXE synchronize tags, download logs and store the pending tagged logs in a capsule array.\n    oracle::message_processing::fetch_tagged_logs(PENDING_TAGGED_LOG_ARRAY_BASE_SLOT);\n\n    CapsuleArray::at(contract_address, PENDING_TAGGED_LOG_ARRAY_BASE_SLOT)\n}\n\n/// Enqueues a note for validation by PXE, so that it becomes aware of a note's existence allowing for later retrieval\n/// via `get_notes` oracle. The note will be scoped to `contract_address`, meaning other contracts will not be able to\n/// access it unless authorized.\n///\n/// In order for the note validation and insertion to occur, `validate_enqueued_notes_and_events` must be later called.\n/// For optimal performance, accumulate as many note validation requests as possible and then validate them all at the\n/// end (which results in PXE minimizing the number of network round-trips).\n///\n/// The `packed_note` is what `getNotes` will later return. PXE indexes notes by `storage_slot`, so this value\n/// is typically used to filter notes that correspond to different state variables. `note_hash` and `nullifier` are\n/// the inner hashes, i.e. the raw hashes returned by `NoteHash::compute_note_hash` and\n/// `NoteHash::compute_nullifier`. PXE will verify that the siloed unique note hash was inserted into the tree\n/// at `tx_hash`, and will store the nullifier to later check for nullification.\n///\n/// `owner` is the address used in note hash and nullifier computation, often requiring knowledge of their\n/// nullifier secret key.\n///\n/// `recipient` is the account to which the note message was delivered (i.e. the address the message was encrypted to).\n/// This determines which PXE account can see the note - other accounts will not be able to access it (e.g. other\n/// accounts will not be able to see one another's token balance notes, even in the same PXE) unless authorized. In most\n/// cases `recipient` equals `owner`, but they can differ in scenarios like delegated discovery.\npub(crate) unconstrained fn enqueue_note_for_validation(\n    contract_address: AztecAddress,\n    owner: AztecAddress,\n    storage_slot: Field,\n    randomness: Field,\n    note_nonce: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) {\n    // We store requests in a `CapsuleArray`, which PXE will later read from and deserialize into its version of the\n    // Noir `NoteValidationRequest`\n    CapsuleArray::at(contract_address, NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT).push(\n        NoteValidationRequest {\n            contract_address,\n            owner,\n            storage_slot,\n            randomness,\n            note_nonce,\n            packed_note,\n            note_hash,\n            nullifier,\n            tx_hash,\n            recipient,\n        },\n    )\n}\n\n/// Enqueues an event for validation by PXE, so that it can be efficiently validated and then inserted into the event\n/// store.\n///\n/// In order for the event validation and insertion to occur, `validate_enqueued_notes_and_events` must be later\n/// called. For optimal performance, accumulate as many event validation requests as possible and then validate them\n/// all at the end (which results in PXE minimizing the number of network round-trips).\npub(crate) unconstrained fn enqueue_event_for_validation(\n    contract_address: AztecAddress,\n    event_type_id: EventSelector,\n    serialized_event: BoundedVec<Field, MAX_EVENT_SERIALIZED_LEN>,\n    event_commitment: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) {\n    // We store requests in a `CapsuleArray`, which PXE will later read from and deserialize into its version of the\n    // Noir `EventValidationRequest`\n    CapsuleArray::at(contract_address, EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT).push(\n        EventValidationRequest {\n            contract_address,\n            event_type_id,\n            serialized_event,\n            event_commitment,\n            tx_hash,\n            recipient,\n        },\n    )\n}\n\n/// Validates all note and event validation requests enqueued via `enqueue_note_for_validation` and\n/// `enqueue_event_for_validation`, inserting them into the note database and event store respectively, making them\n/// queryable via `get_notes` oracle and our TS API (PXE::getPrivateEvents).\n///\n/// This automatically clears both validation request queues, so no further work needs to be done by the caller.\npub(crate) unconstrained fn validate_enqueued_notes_and_events(contract_address: AztecAddress) {\n    oracle::message_processing::validate_enqueued_notes_and_events(\n        contract_address,\n        NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT,\n        EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT,\n    );\n}\n\n/// Efficiently queries the node for logs that result in the completion of all `DeliveredPendingPartialNote`s stored in\n/// a `CapsuleArray` by performing all node communication concurrently. Returns a second `CapsuleArray` with Options for\n/// the responses that correspond to the pending partial notes at the same index.\n///\n/// For example, given an array with pending partial notes `[ p1, p2, p3 ]`, where `p1` and `p3` have corresponding\n/// completion logs but `p2` does not, the returned `CapsuleArray` will have contents\n/// `[some(p1_log), none(), some(p3_log)]`.\npub(crate) unconstrained fn get_pending_partial_notes_completion_logs(\n    contract_address: AztecAddress,\n    pending_partial_notes: CapsuleArray<DeliveredPendingPartialNote>,\n) -> CapsuleArray<Option<LogRetrievalResponse>> {\n    let log_retrieval_requests =\n        CapsuleArray::at(contract_address, LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT);\n\n    // We create a LogRetrievalRequest for each PendingPartialNote in the CapsuleArray. Because we need the indices in\n    // the request array to match the indices in the partial note array, we can't use CapsuleArray::for_each, as that\n    // function has arbitrary iteration order. Instead, we manually iterate the array from the beginning and push into\n    // the requests array, which we expect to be empty.\n    let mut i = 0;\n    let pending_partial_notes_count = pending_partial_notes.len();\n    while i < pending_partial_notes_count {\n        let pending_partial_note = pending_partial_notes.get(i);\n        log_retrieval_requests.push(\n            LogRetrievalRequest {\n                contract_address,\n                unsiloed_tag: pending_partial_note.note_completion_log_tag,\n            },\n        );\n        i += 1;\n    }\n\n    oracle::message_processing::bulk_retrieve_logs(\n        contract_address,\n        LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT,\n        LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT,\n    );\n\n    CapsuleArray::at(contract_address, LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT)\n}\n","path":"/Users/zac/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/messages/processing/mod.nr"},"170":{"source":"use protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// Stores arbitrary information in a per-contract non-volatile database, which can later be retrieved with `load`. If\n/// data was already stored at this slot, it is overwritten.\npub unconstrained fn store<T>(contract_address: AztecAddress, slot: Field, value: T)\nwhere\n    T: Serialize,\n{\n    let serialized = value.serialize();\n    store_oracle(contract_address, slot, serialized);\n}\n\n/// Returns data previously stored via `storeCapsule` in the per-contract non-volatile database. Returns Option::none() if\n/// nothing was stored at the given slot.\npub unconstrained fn load<T>(contract_address: AztecAddress, slot: Field) -> Option<T>\nwhere\n    T: Deserialize,\n{\n    let serialized_option = load_oracle(contract_address, slot, <T as Deserialize>::N);\n    serialized_option.map(|arr| Deserialize::deserialize(arr))\n}\n\n/// Deletes data in the per-contract non-volatile database. Does nothing if no data was present.\npub unconstrained fn delete(contract_address: AztecAddress, slot: Field) {\n    delete_oracle(contract_address, slot);\n}\n\n/// Copies a number of contiguous entries in the per-contract non-volatile database. This allows for efficient data\n/// structures by avoiding repeated calls to `loadCapsule` and `storeCapsule`.\n/// Supports overlapping source and destination regions (which will result in the overlapped source values being\n/// overwritten). All copied slots must exist in the database (i.e. have been stored and not deleted)\npub unconstrained fn copy(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {\n    copy_oracle(contract_address, src_slot, dst_slot, num_entries);\n}\n\n#[oracle(utilityStoreCapsule)]\nunconstrained fn store_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    values: [Field; N],\n) {}\n\n/// We need to pass in `array_len` (the value of N) as a parameter to tell the oracle how many fields the response must\n/// have.\n///\n/// Note that the oracle returns an Option<[Field; N]> because we cannot return an Option<T> directly. That would\n/// require for the oracle resolver to know the shape of T (e.g. if T were a struct of 3 u32 values then the expected\n/// response shape would be 3 single items, whereas it were a struct containing `u32, [Field;10], u32` then the expected\n/// shape would be single, array, single.). Instead, we return the serialization and deserialize in Noir.\n#[oracle(utilityLoadCapsule)]\nunconstrained fn load_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    array_len: u32,\n) -> Option<[Field; N]> {}\n\n#[oracle(utilityDeleteCapsule)]\nunconstrained fn delete_oracle(contract_address: AztecAddress, slot: Field) {}\n\n#[oracle(utilityCopyCapsule)]\nunconstrained fn copy_oracle(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {}\n\nmod test {\n    // These tests are sort of redundant since we already test the oracle implementation directly in TypeScript, but\n    // they are cheap regardless and help ensure both that the TXE implementation works accordingly and that the Noir\n    // oracles are hooked up correctly.\n\n    use crate::{\n        oracle::capsules::{copy, delete, load, store},\n        test::{helpers::test_environment::TestEnvironment, mocks::mock_struct::MockStruct},\n    };\n    use protocol_types::{address::AztecAddress, traits::{FromField, ToField}};\n\n    global SLOT: Field = 1;\n\n    #[test]\n    unconstrained fn stores_and_loads() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let value = MockStruct::new(5, 6);\n            store(contract_address, SLOT, value);\n\n            assert_eq(load(contract_address, SLOT).unwrap(), value);\n        });\n    }\n\n    #[test]\n    unconstrained fn store_overwrites() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let value = MockStruct::new(5, 6);\n            store(contract_address, SLOT, value);\n\n            let new_value = MockStruct::new(7, 8);\n            store(contract_address, SLOT, new_value);\n\n            assert_eq(load(contract_address, SLOT).unwrap(), new_value);\n        });\n    }\n\n    #[test]\n    unconstrained fn loads_empty_slot() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n            assert_eq(loaded_value, Option::none());\n        });\n    }\n\n    #[test]\n    unconstrained fn deletes_stored_value() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let value = MockStruct::new(5, 6);\n            store(contract_address, SLOT, value);\n            delete(contract_address, SLOT);\n\n            let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n            assert_eq(loaded_value, Option::none());\n        });\n    }\n\n    #[test]\n    unconstrained fn deletes_empty_slot() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            delete(contract_address, SLOT);\n            let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n            assert_eq(loaded_value, Option::none());\n        });\n    }\n\n    #[test]\n    unconstrained fn copies_non_overlapping_values() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let src = 5;\n\n            let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n            store(contract_address, src, values[0]);\n            store(contract_address, src + 1, values[1]);\n            store(contract_address, src + 2, values[2]);\n\n            let dst = 10;\n            copy(contract_address, src, dst, 3);\n\n            assert_eq(load(contract_address, dst).unwrap(), values[0]);\n            assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n            assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n        });\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_src_ahead() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let src = 1;\n\n            let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n            store(contract_address, src, values[0]);\n            store(contract_address, src + 1, values[1]);\n            store(contract_address, src + 2, values[2]);\n\n            let dst = 2;\n            copy(contract_address, src, dst, 3);\n\n            assert_eq(load(contract_address, dst).unwrap(), values[0]);\n            assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n            assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n            // src[1] and src[2] should have been overwritten since they are also dst[0] and dst[1]\n            assert_eq(load(contract_address, src).unwrap(), values[0]); // src[0] (unchanged)\n            assert_eq(load(contract_address, src + 1).unwrap(), values[0]); // dst[0]\n            assert_eq(load(contract_address, src + 2).unwrap(), values[1]); // dst[1]\n        });\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_dst_ahead() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let src = 2;\n\n            let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n            store(contract_address, src, values[0]);\n            store(contract_address, src + 1, values[1]);\n            store(contract_address, src + 2, values[2]);\n\n            let dst = 1;\n            copy(contract_address, src, dst, 3);\n\n            assert_eq(load(contract_address, dst).unwrap(), values[0]);\n            assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n            assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n            // src[0] and src[1] should have been overwritten since they are also dst[1] and dst[2]\n            assert_eq(load(contract_address, src).unwrap(), values[1]); // dst[1]\n            assert_eq(load(contract_address, src + 1).unwrap(), values[2]); // dst[2]\n            assert_eq(load(contract_address, src + 2).unwrap(), values[2]); // src[2] (unchanged)\n        });\n    }\n\n    #[test(should_fail_with = \"copy empty slot\")]\n    unconstrained fn cannot_copy_empty_values() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            copy(contract_address, SLOT, SLOT, 1);\n        });\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_store_other_contract() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n            let value = MockStruct::new(5, 6);\n            store(other_contract_address, SLOT, value);\n        });\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_load_other_contract() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n            let _: Option<MockStruct> = load(other_contract_address, SLOT);\n        });\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_delete_other_contract() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n            delete(other_contract_address, SLOT);\n        });\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_copy_other_contract() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n            copy(other_contract_address, SLOT, SLOT, 0);\n        });\n    }\n}\n","path":"/Users/zac/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/oracle/capsules.nr"},"172":{"source":"use crate::context::utility_context::UtilityContext;\n\n#[oracle(utilityGetUtilityContext)]\nunconstrained fn get_utility_context_oracle() -> UtilityContext {}\n\n/// Returns a utility context built from the global variables of anchor block and the contract address of the function\n/// being executed.\npub unconstrained fn get_utility_context() -> UtilityContext {\n    get_utility_context_oracle()\n}\n","path":"/Users/zac/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/oracle/execution.nr"},"174":{"source":"use protocol_types::{\n    address::AztecAddress, contract_class_id::ContractClassId, contract_instance::ContractInstance,\n    traits::FromField,\n};\n\n// NOTE: this is for use in private only\n#[oracle(utilityGetContractInstance)]\nunconstrained fn get_contract_instance_oracle(_address: AztecAddress) -> ContractInstance {}\n\n// NOTE: this is for use in private only\nunconstrained fn get_contract_instance_internal(address: AztecAddress) -> ContractInstance {\n    get_contract_instance_oracle(address)\n}\n\n// NOTE: this is for use in private only\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    // Safety: The to_address function combines all values in the instance object to produce an address,\n    // so by checking that we get the expected address we validate the entire struct.\n    let instance = unsafe { get_contract_instance_internal(address) };\n    assert_eq(instance.to_address(), address);\n\n    instance\n}\n\nstruct GetContractInstanceResult {\n    exists: bool,\n    member: Field,\n}\n\n// These oracles each return a ContractInstance member\n// plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstanceDeployer)]\nunconstrained fn get_contract_instance_deployer_oracle_avm(\n    _address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {}\n#[oracle(avmOpcodeGetContractInstanceClassId)]\nunconstrained fn get_contract_instance_class_id_oracle_avm(\n    _address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {}\n#[oracle(avmOpcodeGetContractInstanceInitializationHash)]\nunconstrained fn get_contract_instance_initialization_hash_oracle_avm(\n    _address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {}\n\nunconstrained fn get_contract_instance_deployer_internal_avm(\n    address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {\n    get_contract_instance_deployer_oracle_avm(address)\n}\nunconstrained fn get_contract_instance_class_id_internal_avm(\n    address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {\n    get_contract_instance_class_id_oracle_avm(address)\n}\nunconstrained fn get_contract_instance_initialization_hash_internal_avm(\n    address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {\n    get_contract_instance_initialization_hash_oracle_avm(address)\n}\n\npub fn get_contract_instance_deployer_avm(address: AztecAddress) -> Option<AztecAddress> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let GetContractInstanceResult { exists, member } =\n        unsafe { get_contract_instance_deployer_internal_avm(address)[0] };\n    if exists {\n        Option::some(AztecAddress::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_class_id_avm(address: AztecAddress) -> Option<ContractClassId> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let GetContractInstanceResult { exists, member } =\n        unsafe { get_contract_instance_class_id_internal_avm(address)[0] };\n    if exists {\n        Option::some(ContractClassId::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_initialization_hash_avm(address: AztecAddress) -> Option<Field> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let GetContractInstanceResult { exists, member } =\n        unsafe { get_contract_instance_initialization_hash_internal_avm(address)[0] };\n    if exists {\n        Option::some(member)\n    } else {\n        Option::none()\n    }\n}\n","path":"/Users/zac/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/oracle/get_contract_instance.nr"},"182":{"source":"use protocol_types::address::AztecAddress;\n\n/// Finds new private logs that may have been sent to all registered accounts in PXE in the current contract and makes\n/// them available for later processing in Noir by storing them in a capsule array.\npub unconstrained fn fetch_tagged_logs(pending_tagged_log_array_base_slot: Field) {\n    fetch_tagged_logs_oracle(pending_tagged_log_array_base_slot);\n}\n\n#[oracle(utilityFetchTaggedLogs)]\nunconstrained fn fetch_tagged_logs_oracle(pending_tagged_log_array_base_slot: Field) {}\n\n// This must be a single oracle and not one for notes and one for events because the entire point is to validate\n// all notes and events in one go, minimizing node round-trips.\npub(crate) unconstrained fn validate_enqueued_notes_and_events(\n    contract_address: AztecAddress,\n    note_validation_requests_array_base_slot: Field,\n    event_validation_requests_array_base_slot: Field,\n) {\n    validate_enqueued_notes_and_events_oracle(\n        contract_address,\n        note_validation_requests_array_base_slot,\n        event_validation_requests_array_base_slot,\n    );\n}\n\n#[oracle(utilityValidateEnqueuedNotesAndEvents)]\nunconstrained fn validate_enqueued_notes_and_events_oracle(\n    contract_address: AztecAddress,\n    note_validation_requests_array_base_slot: Field,\n    event_validation_requests_array_base_slot: Field,\n) {}\n\npub(crate) unconstrained fn bulk_retrieve_logs(\n    contract_address: AztecAddress,\n    log_retrieval_requests_array_base_slot: Field,\n    log_retrieval_responses_array_base_slot: Field,\n) {\n    bulk_retrieve_logs_oracle(\n        contract_address,\n        log_retrieval_requests_array_base_slot,\n        log_retrieval_responses_array_base_slot,\n    );\n}\n\n#[oracle(utilityBulkRetrieveLogs)]\nunconstrained fn bulk_retrieve_logs_oracle(\n    contract_address: AztecAddress,\n    log_retrieval_requests_array_base_slot: Field,\n    log_retrieval_responses_array_base_slot: Field,\n) {}\n","path":"/Users/zac/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/oracle/message_processing.nr"},"187":{"source":"use protocol_types::{address::aztec_address::AztecAddress, point::Point};\n\n// TODO(#12656): return an app-siloed secret + document this\n#[oracle(utilityGetSharedSecret)]\nunconstrained fn get_shared_secret_oracle(address: AztecAddress, ephPk: Point) -> Point {}\n\n/// Returns an app-siloed shared secret between `address` and someone who knows the secret key behind an\n/// ephemeral public key `ephPk`. The app-siloing means that contracts cannot retrieve secrets that belong to\n/// other contracts, and therefore cannot e.g. decrypt their messages. This is an important security consideration\n/// given that both the `address` and `ephPk` are public information.\n///\n/// The shared secret `S` is computed as:\n/// `let S =  (ivsk + h) * ephPk`\n/// where `ivsk + h` is the 'preaddress' i.e. the preimage of the address, also called the address secret.\n/// TODO(#12656): app-silo this secret\npub unconstrained fn get_shared_secret(address: AztecAddress, ephPk: Point) -> Point {\n    get_shared_secret_oracle(address, ephPk)\n}\n","path":"/Users/zac/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/oracle/shared_secret.nr"},"188":{"source":"use dep::protocol_types::{address::AztecAddress, traits::{Packable, ToField}};\n\n#[oracle(utilityStorageRead)]\nunconstrained fn storage_read_oracle<let N: u32>(\n    address: Field,\n    storage_slot: Field,\n    block_number: u32,\n    length: u32,\n) -> [Field; N] {}\n\npub unconstrained fn raw_storage_read<let N: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32,\n) -> [Field; N] {\n    storage_read_oracle(address.to_field(), storage_slot, block_number, N)\n}\n\npub unconstrained fn storage_read<T>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32,\n) -> T\nwhere\n    T: Packable,\n{\n    T::unpack(raw_storage_read(address, storage_slot, block_number))\n}\n\nmod tests {\n    use crate::oracle::storage::{raw_storage_read, storage_read};\n    use dep::protocol_types::{address::AztecAddress, traits::{FromField, Packable}};\n\n    use crate::test::mocks::mock_struct::MockStruct;\n    use std::test::OracleMock;\n\n    global address: AztecAddress = AztecAddress::from_field(29);\n    global slot: Field = 7;\n    global block_number: u32 = 17;\n\n    #[test]\n    unconstrained fn test_raw_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"utilityStorageRead\").returns(written.pack());\n\n        let read: [Field; 2] = raw_storage_read(address, slot, block_number);\n        assert_eq(read[0], 13);\n        assert_eq(read[1], 42);\n    }\n\n    #[test]\n    unconstrained fn test_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"utilityStorageRead\").returns(written.pack());\n\n        let read: MockStruct = storage_read(address, slot, block_number);\n        assert_eq(read.a, 13);\n        assert_eq(read.b, 42);\n    }\n}\n","path":"/Users/zac/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/oracle/storage.nr"},"189":{"source":"/// The ORACLE_VERSION constant is used to check that the oracle interface is in sync between PXE and Aztec.nr. We need\n/// to version the oracle interface to ensure that developers get a reasonable error message if they use incompatible\n/// versions of Aztec.nr and PXE. The TypeScript counterpart is in `oracle_version.ts`.\n///\n/// @dev Whenever a contract function or Noir test is run, the `utilityAssertCompatibleOracleVersion` oracle is called and\n/// if the oracle version is incompatible an error is thrown.\npub global ORACLE_VERSION: Field = 5;\n\n/// Asserts that the version of the oracle is compatible with the version expected by the contract.\npub fn assert_compatible_oracle_version() {\n    // Safety: This oracle call returns nothing: we only call it to check Aztec.nr and Oracle interface versions are\n    // compatible. It is therefore always safe to call.\n    unsafe {\n        assert_compatible_oracle_version_wrapper();\n    }\n}\n\nunconstrained fn assert_compatible_oracle_version_wrapper() {\n    assert_compatible_oracle_version_oracle(ORACLE_VERSION);\n}\n\n#[oracle(utilityAssertCompatibleOracleVersion)]\nunconstrained fn assert_compatible_oracle_version_oracle(version: Field) {}\n\nmod test {\n    use super::{assert_compatible_oracle_version_oracle, ORACLE_VERSION};\n\n    #[test]\n    unconstrained fn compatible_oracle_version() {\n        assert_compatible_oracle_version_oracle(ORACLE_VERSION);\n    }\n\n    #[test(should_fail_with = \"Incompatible oracle version. TXE is using version\")]\n    unconstrained fn incompatible_oracle_version() {\n        let arbitrary_incorrect_version = 318183437;\n        assert_compatible_oracle_version_oracle(arbitrary_incorrect_version);\n    }\n}\n","path":"/Users/zac/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/oracle/version.nr"},"193":{"source":"use crate::state_vars::state_variable::StateVariable;\nuse dep::protocol_types::{storage::map::derive_storage_slot_in_map, traits::ToField};\n\n/// Map\n///\n/// A key-value storage container that maps keys to state variables, similar\n/// to Solidity mappings.\n///\n/// `Map` enables you to associate keys (like addresses or other identifiers)\n/// with state variables in your Aztec smart contract. This is conceptually\n/// similar to Solidity's `mapping(K => V)` syntax, where you can store and\n/// retrieve values by their associated keys.\n///\n/// You can declare a state variable contained within a Map in your contract's\n/// #[storage] struct.\n///\n/// For example, you might use\n/// `Map<AztecAddress, PublicMutable<FieldNote, Context>, Context>` to track\n/// token balances for different users, similar to how you'd use\n/// `mapping(address => uint256)` in Solidity.\n///\n/// > Aside: the verbose `Context` in the declaration is a consequence of\n/// > leveraging Noir's regular syntax for generics to ensure that certain\n/// > state variable methods can only be called in some contexts (private,\n/// > public, utility).\n///\n/// The methods of Map are:\n/// - `at` (access state variable for a given key)\n/// (see the method's own doc comments for more info).\n///\n/// ## Generic Parameters\n/// - `K`: The key type (must implement `ToField` trait for hashing)\n/// - `V`: The value type:\n///   - any Aztec state variable (variable that implements the StateVariable trait):\n///     - `PublicMutable`\n///     - `PublicImmutable`\n///     - `DelayedPublicMutable`\n///     - `Map`\n/// - `Context`: The execution context (handles private/public function\n///   contexts)\n///\n/// ## Usage\n/// Maps are typically declared in your contract's #[storage] struct and\n/// accessed\n/// using the `at(key)` method to get the state variable for a specific key.\n/// The resulting state variable can then be read from or written to using its\n/// own methods.\n///\n/// Note that maps cannot be used with owned state variables (variables that\n/// implement the OwnedStateVariable trait) - those need to be wrapped in an\n/// `Owned` state variable instead.\n///\n/// ## Advanced\n/// Internally, `Map` uses a single base storage slot to represent the\n/// mapping\n/// itself, similar to Solidity's approach. Individual key-value pairs are\n/// stored at derived storage slots computed by hashing the base storage\n/// slot\n/// with the key using Poseidon2. This ensures:\n/// - No storage slot collisions between different keys\n/// - Uniform distribution of storage slots across the storage space\n/// - Compatibility with Aztec's storage tree structure\n/// - Gas-efficient storage access patterns similar to Solidity mappings\n///\n/// The storage slot derivation uses `derive_storage_slot_in_map(base_slot,\n/// key)` which computes `poseidon2_hash([base_slot, key.to_field()])`,\n/// ensuring cryptographically secure slot separation.\n///\n/// docs:start:map\npub struct Map<K, V, Context> {\n    pub context: Context,\n    storage_slot: Field,\n}\n\n// Map reserves a single storage slot regardless of what it stores because\n// nothing is stored at said slot: it is only used to derive the storage slots\n// of nested state variables, which is expected to never result in collisions\n// or slots being close to one another due to these being hashes. This mirrors\n// the strategy adopted by Solidity mappings.\nimpl<K, V, Context> StateVariable<1, Context> for Map<K, V, Context> {\n    fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot }\n    }\n\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<K, V, Context> Map<K, V, Context> {\n    /// Returns the state variable associated with the given key.\n    ///\n    /// This is equivalent to accessing `mapping[key]` in Solidity. It returns\n    /// the state variable instance for the specified key, which can then be\n    /// used to read or write the value at that key.\n    ///\n    /// Unlike Solidity mappings which return the value directly, this returns\n    /// the state variable wrapper (like PublicMutable, nested Map etc.)\n    /// that you then call methods on to interact with the actual value.\n    ///\n    /// # Arguments\n    ///\n    /// * `key` - The key to look up in the map. Must implement the ToField\n    ///           trait (which most basic Noir & Aztec types do).\n    ///\n    /// # Returns\n    ///\n    /// * `V` - The state variable instance for this key. You can then call\n    ///         methods like `.read()`, `.write()`, `.get_note()`, etc. on this\n    ///         depending on the specific state variable type.\n    ///\n    /// # Example\n    ///\n    /// ```noir\n    /// // Get a user's balance (assuming PrivateMutable<FieldNote>)\n    /// let user_balance = self.storage.balances.at(user_address);\n    /// let current_note = user_balance.get_note();\n    ///\n    /// // Update the balance\n    /// user_balance.replace(new_note);\n    /// ```\n    ///\n    pub fn at<let N: u32>(self, key: K) -> V\n    where\n        K: ToField,\n        V: StateVariable<N, Context>,\n    {\n        V::new(\n            self.context,\n            derive_storage_slot_in_map(self.storage_slot, key),\n        )\n    }\n}\n","path":"/Users/zac/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/state_vars/map.nr"},"205":{"source":"use crate::context::{PublicContext, UtilityContext};\nuse crate::state_vars::state_variable::StateVariable;\nuse dep::protocol_types::traits::Packable;\n\n/// # PublicMutable\n///\n/// PublicMutable is a public state variable type for values that can be read\n/// and written within #[external(\"public\")] functions of your smart contract.\n///\n/// You can declare a state variable of type PublicMutable within your contract's\n/// #[storage] struct:\n///\n/// E.g.:\n/// `your_variable: PublicMutable<T, Context>`\n/// or:\n/// `your_mapping: Map<Field, PublicMutable<T, Context>>`\n///\n/// The methods of PublicMutable are:\n/// - `read`\n/// - `write`\n/// (see the methods' own doc comments for more info).\n///\n/// ## Example.\n///\n/// A voting contract's proposal count can be represented as a PublicMutable<u64>.\n/// The count can be read by anyone to see how many proposals exist, and incremented\n/// when new proposals are submitted.\n///\n/// # Generic Parameters:\n///\n/// * `T` - The type of value stored (must implement Packable).\n/// * `Context` - The execution context (PublicContext or UtilityContext).\n///\n/// # Advanced\n///\n/// Unlike private state variables which use notes, PublicMutable stores values\n/// directly in Aztec's public data tree. This enables direct read and write\n/// access to the current state during public function execution.\n///\n/// docs:start:public_mutable_struct\npub struct PublicMutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n\nimpl<T, Context, let M: u32> StateVariable<M, Context> for PublicMutable<T, Context>\nwhere\n    T: Packable<N = M>,\n{\n    fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicMutable { context, storage_slot }\n    }\n\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<T> PublicMutable<T, PublicContext> {\n    /// Reads the current value stored in this PublicMutable state variable.\n    ///\n    /// # Returns\n    ///\n    /// * `T` - The current value stored in this PublicMutable.\n    ///\n    /// docs:start:public_mutable_struct_read\n    pub fn read(self) -> T\n    where\n        T: Packable,\n    {\n        self.context.storage_read(self.storage_slot)\n    }\n\n    /// Writes a new value to this PublicMutable state variable.\n    ///\n    /// # Arguments\n    ///\n    /// * `value` - The new value to store in this PublicMutable.\n    ///\n    /// # Advanced\n    ///\n    /// This function updates the value stored in Aztec's public data tree.\n    /// The new value becomes immediately available to subsequent reads within\n    /// the same transaction.\n    ///\n    /// docs:start:public_mutable_struct_write\n    pub fn write(self, value: T)\n    where\n        T: Packable,\n    {\n        self.context.storage_write(self.storage_slot, value);\n    }\n}\n\nimpl<T> PublicMutable<T, UtilityContext> {\n    /// Reads the current value stored in this PublicMutable state variable.\n    ///\n    /// Notice that this function is executable only within a UtilityContext, which\n    /// is an unconstrained environment on the user's local device.\n    ///\n    /// # Returns\n    ///\n    /// * `T` - The current value stored in this PublicMutable.\n    ///\n    pub unconstrained fn read(self) -> T\n    where\n        T: Packable,\n    {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n","path":"/Users/zac/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/state_vars/public_mutable.nr"},"230":{"source":"/// Appends the elements of the second `BoundedVec` to the end of the first one. The resulting `BoundedVec` can have any arbitrary maximum length, but it must be\n/// large enough to fit all of the elements of both the first and second vectors.\npub fn append<T, let ALen: u32, let BLen: u32, let DstLen: u32>(\n    a: BoundedVec<T, ALen>,\n    b: BoundedVec<T, BLen>,\n) -> BoundedVec<T, DstLen> {\n    let mut dst = BoundedVec::new();\n\n    dst.extend_from_bounded_vec(a);\n    dst.extend_from_bounded_vec(b);\n\n    dst\n}\n\nmod test {\n    use super::append;\n\n    #[test]\n    unconstrained fn append_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::new();\n        let b: BoundedVec<_, 14> = BoundedVec::new();\n\n        let result: BoundedVec<Field, 5> = append(a, b);\n\n        assert_eq(result.len(), 0);\n        assert_eq(result.storage(), std::mem::zeroed());\n    }\n\n    #[test]\n    unconstrained fn append_non_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let result: BoundedVec<Field, 8> = append(a, b);\n\n        assert_eq(result.len(), 6);\n        assert_eq(result.storage(), [1, 2, 3, 4, 5, 6, std::mem::zeroed(), std::mem::zeroed()]);\n    }\n\n    #[test(should_fail_with = \"out of bounds\")]\n    unconstrained fn append_non_empty_vecs_insufficient_max_len() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let _: BoundedVec<Field, 5> = append(a, b);\n    }\n}\n","path":"/Users/zac/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/utils/array/append.nr"},"233":{"source":"/// Returns `DstLen` elements from a source array, starting at `offset`. `DstLen` must not be larger than the number\n/// of elements past `offset`.\n///\n/// Examples:\n/// ```\n/// let foo: [Field; 2] = subarray([1, 2, 3, 4, 5], 2);\n/// assert_eq(foo, [3, 4]);\n///\n/// let bar: [Field; 5] = subarray([1, 2, 3, 4, 5], 2); // fails - we can't return 5 elements since only 3 remain\n/// ```\npub fn subarray<T, let SrcLen: u32, let DstLen: u32>(src: [T; SrcLen], offset: u32) -> [T; DstLen] {\n    assert(offset + DstLen <= SrcLen, \"DstLen too large for offset\");\n\n    let mut dst: [T; DstLen] = std::mem::zeroed();\n    for i in 0..DstLen {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\nmod test {\n    use super::subarray;\n\n    #[test]\n    unconstrained fn subarray_into_empty() {\n        // In all of these cases we're setting DstLen to be 0, so we always get back an empty array.\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 2), []);\n    }\n\n    #[test]\n    unconstrained fn subarray_complete() {\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), [1, 2, 3, 4, 5]);\n    }\n\n    #[test]\n    unconstrained fn subarray_different_end_sizes() {\n        // We implicitly select how many values to read in the size of the return array\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4, 5]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2]);\n    }\n\n    #[test(should_fail_with = \"DstLen too large for offset\")]\n    unconstrained fn subarray_offset_too_large() {\n        // With an offset of 1 we can only request up to 4 elements\n        let _: [_; 5] = subarray([1, 2, 3, 4, 5], 1);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subarray_bad_return_value() {\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [3, 3, 4, 5]);\n    }\n}\n","path":"/Users/zac/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/utils/array/subarray.nr"},"234":{"source":"use crate::utils::array;\n\n/// Returns `DstMaxLen` elements from a source BoundedVec, starting at `offset`. `offset` must not be larger than the\n/// original length, and `DstLen` must not be larger than the total number of elements past `offset` (including the\n/// zeroed elements past `len()`).\n///\n/// Only elements at the beginning of the vector can be removed: it is not possible to also remove elements at the end\n/// of the vector by passing a value for `DstLen` that is smaller than `len() - offset`.\n///\n/// Examples:\n/// ```\n/// let foo = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n/// assert_eq(subbvec(foo, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n///\n/// let bar: BoundedVec<_, 1> = subbvec(foo, 2); // fails - we can't return just 1 element since 3 remain\n/// let baz: BoundedVec<_, 10> = subbvec(foo, 3); // fails - we can't return 10 elements since only 7 remain\n/// ```\npub fn subbvec<T, let SrcMaxLen: u32, let DstMaxLen: u32>(\n    bvec: BoundedVec<T, SrcMaxLen>,\n    offset: u32,\n) -> BoundedVec<T, DstMaxLen> {\n    // from_parts_unchecked does not verify that the elements past len are zeroed, but that is not an issue in our case\n    // because we're constructing the new storage array as a subarray of the original one (which should have zeroed\n    // storage past len), guaranteeing correctness. This is because `subarray` does not allow extending arrays past\n    // their original length.\n    BoundedVec::from_parts_unchecked(array::subarray(bvec.storage(), offset), bvec.len() - offset)\n}\n\nmod test {\n    use super::subbvec;\n\n    #[test]\n    unconstrained fn subbvec_empty() {\n        let bvec = BoundedVec::<Field, 0>::from_array([]);\n        assert_eq(subbvec(bvec, 0), bvec);\n    }\n\n    #[test]\n    unconstrained fn subbvec_complete() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), bvec);\n\n        let smaller_capacity = BoundedVec::<_, 5>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), smaller_capacity);\n    }\n\n    #[test]\n    unconstrained fn subbvec_partial() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 3>::from_array([3, 4, 5]));\n    }\n\n    #[test]\n    unconstrained fn subbvec_into_empty() {\n        let bvec: BoundedVec<_, 10> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 5), BoundedVec::<_, 5>::from_array([]));\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_offset_past_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        let _: BoundedVec<_, 1> = subbvec(bvec, 6);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_insufficient_dst_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // We're not providing enough space to hold all of the items inside the original BoundedVec. subbvec can cause\n        // for the capacity to reduce, but not the length (other than by len - offset).\n        let _: BoundedVec<_, 1> = subbvec(bvec, 2);\n    }\n\n    #[test(should_fail_with = \"DstLen too large for offset\")]\n    unconstrained fn subbvec_dst_len_causes_enlarge() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // subbvec does not supprt capacity increases\n        let _: BoundedVec<_, 11> = subbvec(bvec, 0);\n    }\n\n    #[test(should_fail_with = \"DstLen too large for offset\")]\n    unconstrained fn subbvec_dst_len_too_large_for_offset() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // This effectively requests a capacity increase, since there'd be just one element plus the 5 empty slots,\n        // which is less than 7.\n        let _: BoundedVec<_, 7> = subbvec(bvec, 4);\n    }\n}\n","path":"/Users/zac/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/utils/array/subbvec.nr"},"236":{"source":"use std::static_assert;\n\n// These functions are used to facilitate the conversion of log ciphertext between byte and field representations.\n//\n// `bytes_to_fields` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `bytes_from_fields` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between bytes and fields when processing encrypted logs.\n\n/// Converts the input bytes into an array of fields. A Field is ~254 bits meaning that each field can store 31 whole\n/// bytes. Use `bytes_from_fields` to obtain the original bytes array.\n///\n/// The input bytes are chunked into chunks of 31 bytes. Each 31-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (31 bytes) is encoded as [1 * 256^30 + 10 * 256^29 + 3 * 256^28 + ... + 0]\n/// Note: N must be a multiple of 31 bytes\npub fn bytes_to_fields<let N: u32>(bytes: [u8; N]) -> [Field; N / 31] {\n    // Assert that N is a multiple of 31\n    static_assert(N % 31 == 0, \"N must be a multiple of 31\");\n\n    let mut fields = [0; N / 31];\n\n    // Since N is a multiple of 31, we can simply process all chunks fully\n    for i in 0..N / 31 {\n        let mut field = 0;\n        for j in 0..31 {\n            // Shift the existing value left by 8 bits and add the new byte\n            field = field * 256 + bytes[i * 31 + j] as Field;\n        }\n        fields[i] = field;\n    }\n\n    fields\n}\n\n/// Converts an input BoundedVec of fields into a BoundedVec of bytes in big-endian order. Arbitrary Field arrays\n/// are not allowed: this is assumed to be an array obtained via `bytes_to_fields`, i.e. one that actually represents\n/// bytes. To convert a Field array into bytes, use `fields_to_bytes`.\n///\n/// Each input field must contain at most 31 bytes (this is constrained to be so).\n/// Each field is converted into 31 big-endian bytes, and the resulting 31-byte chunks are concatenated\n/// back together in the order of the original fields.\npub fn bytes_from_fields<let N: u32>(fields: BoundedVec<Field, N>) -> BoundedVec<u8, N * 31> {\n    let mut bytes = BoundedVec::new();\n\n    for i in 0..fields.len() {\n        let field = fields.get(i);\n\n        // We expect that the field contains at most 31 bytes of information.\n        field.assert_max_bit_size::<248>();\n\n        // Now we can safely convert the field to 31 bytes.\n        let field_as_bytes: [u8; 31] = field.to_be_bytes();\n\n        for j in 0..31 {\n            bytes.push(field_as_bytes[j]);\n        }\n    }\n\n    bytes\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{bytes_from_fields, bytes_to_fields};\n\n    #[test]\n    unconstrained fn random_bytes_to_fields_and_back(input: [u8; 93]) {\n        let fields = bytes_to_fields(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `bytes_from_fields`\n        // function.\n        let fields_as_bounded_vec = BoundedVec::<_, 6>::from_array(fields);\n\n        let bytes_back = bytes_from_fields(fields_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(bytes_back.len(), input.len());\n        assert_eq(subarray(bytes_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"N must be a multiple of 31\")]\n    unconstrained fn bytes_to_fields_input_length_not_multiple_of_31() {\n        // Try to convert 32 bytes (not a multiple of 31) to fields\n        let _fields = bytes_to_fields([0; 32]);\n    }\n\n}\n","path":"/Users/zac/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/utils/conversion/bytes_to_fields.nr"},"237":{"source":"// These functions are used to facilitate the conversion of log plaintext represented as fields into bytes and back.\n//\n// `fields_to_bytes` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `fields_from_bytes` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between fields and bytes.\n\n/// Converts an input array of fields into a single array of bytes. Use `fields_from_bytes` to obtain the original\n/// field array.\n/// Each field is converted to a 32-byte big-endian array.\n///\n/// For example, if you have a field array [123, 456], it will be converted to a 64-byte array:\n/// [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,123,  // First field (32 bytes)\n///  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,200]  // Second field (32 bytes)\n///\n/// Since a field is ~254 bits, you'll end up with a subtle 2-bit \"gap\" at the big end, every 32 bytes. Be careful\n/// that such a gap doesn't leak information! This could happen if you for example expected the output to be\n/// indistinguishable from random bytes.\npub fn fields_to_bytes<let N: u32>(fields: [Field; N]) -> [u8; 32 * N] {\n    let mut bytes = [0; 32 * N];\n\n    for i in 0..N {\n        let field_as_bytes: [u8; 32] = fields[i].to_be_bytes();\n\n        for j in 0..32 {\n            bytes[i * 32 + j] = field_as_bytes[j];\n        }\n    }\n\n    bytes\n}\n\n/// Converts an input BoundedVec of bytes into a BoundedVec of fields. Arbitrary byte arrays are not allowed: this\n/// is assumed to be an array obtained via `fields_to_bytes`, i.e. one that actually represents fields. To convert\n/// a byte array into Fields, use `bytes_to_fields`.\n///\n/// The input bytes are chunked into chunks of 32 bytes. Each 32-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (32 bytes) is encoded as [1 * 256^31 + 10 * 256^30 + 3 * 256^29 + ... + 0]\n/// Note 1: N must be a multiple of 32 bytes\n/// Note 2: The max value check code was taken from std::field::to_be_bytes function.\npub fn fields_from_bytes<let N: u32>(bytes: BoundedVec<u8, N>) -> BoundedVec<Field, N / 32> {\n    // Assert that input length is a multiple of 32\n    assert(bytes.len() % 32 == 0, \"Input length must be a multiple of 32\");\n\n    let mut fields = BoundedVec::new();\n\n    let p = std::field::modulus_be_bytes();\n\n    // Since input length is a multiple of 32, we can simply process all chunks fully\n    for i in 0..bytes.len() / 32 {\n        let mut field = 0;\n\n        // Process each byte in the 32-byte chunk\n        let mut ok = false;\n\n        for j in 0..32 {\n            let next_byte = bytes.get(i * 32 + j);\n            field = field * 256 + next_byte as Field;\n\n            if !ok {\n                if next_byte != p[j] {\n                    assert(next_byte < p[j], \"Value does not fit in field\");\n                    ok = true;\n                }\n            }\n        }\n        assert(ok, \"Value does not fit in field\");\n\n        fields.push(field);\n    }\n\n    fields\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{fields_from_bytes, fields_to_bytes};\n\n    #[test]\n    unconstrained fn random_fields_to_bytes_and_back(input: [Field; 3]) {\n        // Convert to bytes\n        let bytes = fields_to_bytes(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `fields_from_bytes`\n        // function.\n        // 113 is an arbitrary max length that is larger than the input length of 96.\n        let bytes_as_bounded_vec = BoundedVec::<_, 113>::from_array(bytes);\n\n        // Convert back to fields\n        let fields_back = fields_from_bytes(bytes_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(fields_back.len(), input.len());\n        assert_eq(subarray(fields_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"Input length must be a multiple of 32\")]\n    unconstrained fn to_fields_assert() {\n        // 143 is an arbitrary max length that is larger than 33\n        let input = BoundedVec::<_, 143>::from_array([\n            1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n            25, 26, 27, 28, 29, 30, 31, 32, 33,\n        ]);\n\n        // This should fail since 33 is not a multiple of 32\n        let _fields = fields_from_bytes(input);\n    }\n\n    #[test]\n    unconstrained fn fields_from_bytes_max_value() {\n        let max_field_as_bytes: [u8; 32] = (-1).to_be_bytes();\n        let input = BoundedVec::<_, 32>::from_array(max_field_as_bytes);\n\n        let fields = fields_from_bytes(input);\n\n        // The result should be a largest value storable in a field (-1 since we are modulo-ing)\n        assert_eq(fields.get(0), -1);\n    }\n\n    // In this test we verify that overflow check works by taking the max allowed value, bumping a random byte\n    // and then feeding it to `fields_from_bytes` as input.\n    #[test(should_fail_with = \"Value does not fit in field\")]\n    unconstrained fn fields_from_bytes_overflow(random_value: u8) {\n        let index_of_byte_to_bump = random_value % 32;\n\n        // Obtain the byte representation of the maximum field value\n        let max_field_value_as_bytes: [u8; 32] = (-1).to_be_bytes();\n\n        let byte_to_bump = max_field_value_as_bytes[index_of_byte_to_bump as u32];\n\n        // Skip test execution if the selected byte is already at maximum value (255).\n        // This is acceptable since we are using fuzz testing to generate many test cases.\n        if byte_to_bump != 255 {\n            let mut input = BoundedVec::<_, 32>::from_array(max_field_value_as_bytes);\n\n            // Increment the selected byte to exceed the field's maximum value\n            input.set(index_of_byte_to_bump as u32, byte_to_bump + 1);\n\n            // Attempt the conversion, which should fail due to the value exceeding the field's capacity\n            let _fields = fields_from_bytes(input);\n        }\n    }\n\n}\n","path":"/Users/zac/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/utils/conversion/fields_to_bytes.nr"},"240":{"source":"use protocol_types::{point::Point, utils::field::sqrt};\n\n// I am storing the modulus minus 1 divided by 2 here because full modulus would throw \"String literal too large\" error\n// Full modulus is 21888242871839275222246405745257275088548364400416034343698204186575808495617\nglobal BN254_FR_MODULUS_DIV_2: Field =\n    10944121435919637611123202872628637544274182200208017171849102093287904247808;\n\n/// Converts a point to a byte array.\n///\n/// We don't serialize the point at infinity flag because this function is used in situations where we do not want\n/// to waste the extra byte (encrypted log).\npub fn point_to_bytes(p: Point) -> [u8; 32] {\n    // Note that there is 1 more free bit in the 32 bytes (254 bits currently occupied by the x coordinate, 1 bit for\n    // the \"sign\") so it's possible to use that last bit as an \"is_infinite\" flag if desired in the future.\n    assert(!p.is_infinite, \"Cannot serialize point at infinity as bytes.\");\n\n    let mut result: [u8; 32] = p.x.to_be_bytes();\n\n    if get_sign_of_point(p) {\n        // y is <= (modulus - 1) / 2 so we set the sign bit to 1\n        // Here we leverage that field fits into 254 bits (log2(Fr.MODULUS) < 254) and given that we serialize Fr to 32\n        // bytes and we use big-endian the 2 most significant bits are never populated. Hence we can use one of\n        // the bits as a sign bit.\n        result[0] += 128;\n    }\n\n    result\n}\n\n/**\n * Returns: true if p.y <= MOD_DIV_2, else false.\n */\npub fn get_sign_of_point(p: Point) -> bool {\n    // We store only a \"sign\" of the y coordinate because the rest can be derived from the x coordinate. To get\n    // the sign we check if the y coordinate is less or equal than the curve's order minus 1 divided by 2.\n    // Ideally we'd do `y <= MOD_DIV_2`, but there's no `lte` function, so instead we do `!(y > MOD_DIV_2)`, which is\n    // equivalent, and then rewrite that as `!(MOD_DIV_2 < y)`, since we also have no `gt` function.\n    !BN254_FR_MODULUS_DIV_2.lt(p.y)\n}\n\n/// Returns a `Point` in the Grumpkin curve given its x coordinate.\n///\n/// Because not all values in the field are valid x coordinates of points in the curve (i.e. there\n/// is no corresponding y value in the field that satisfies the curve equation), it may not be\n/// possible to reconstruct a `Point`. `Option::none()` is returned in such cases.\npub fn point_from_x_coord(x: Field) -> Option<Point> {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    sqrt(rhs).map(|y| Point { x, y, is_infinite: false })\n}\n\n/// Returns a `Point` in the Grumpkin curve given its x coordinate and sign for the y coordinate.\n///\n/// Because not all values in the field are valid x coordinates of points in the curve (i.e. there\n/// is no corresponding y value in the field that satisfies the curve equation), it may not be\n/// possible to reconstruct a `Point`. `Option::none()` is returned in such cases.\n///\n/// @param x - The x coordinate of the point\n/// @param sign - The \"sign\" of the y coordinate - determines whether y <= (Fr.MODULUS - 1) / 2\npub fn point_from_x_coord_and_sign(x: Field, sign: bool) -> Option<Point> {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n\n    sqrt(rhs).map(|y| {\n        // If there is a square root, we need to ensure it has the correct \"sign\"\n        let y_is_positive = !BN254_FR_MODULUS_DIV_2.lt(y);\n        let final_y = if y_is_positive == sign { y } else { -y };\n        Point { x, y: final_y, is_infinite: false }\n    })\n}\n\nmod test {\n    use crate::utils::point::{point_from_x_coord, point_from_x_coord_and_sign, point_to_bytes};\n    use dep::protocol_types::point::Point;\n    use dep::protocol_types::utils::field::pow;\n\n    #[test]\n    unconstrained fn test_point_to_bytes_positive_sign() {\n        let p = Point {\n            x: 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73,\n            y: 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_positive_sign = [\n            154, 244, 31, 93, 233, 100, 70, 220, 55, 118, 161, 235, 45, 152, 187, 149, 107, 122,\n            205, 153, 121, 166, 120, 84, 190, 198, 250, 124, 41, 115, 189, 115,\n        ];\n        assert_eq(expected_compressed_point_positive_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_to_bytes_negative_sign() {\n        let p = Point {\n            x: 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5,\n            y: 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_negative_sign = [\n            36, 115, 113, 101, 46, 85, 221, 116, 201, 175, 141, 190, 159, 180, 73, 49, 186, 41, 169,\n            34, 153, 148, 56, 75, 215, 7, 119, 150, 193, 78, 226, 181,\n        ];\n\n        assert_eq(expected_compressed_point_negative_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_from_x_coord_and_sign() {\n        // Test positive y coordinate\n        let x = 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73;\n        let sign = true;\n        let p = point_from_x_coord_and_sign(x, sign).unwrap();\n\n        assert_eq(p.x, x);\n        assert_eq(p.y, 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a);\n        assert_eq(p.is_infinite, false);\n\n        // Test negative y coordinate\n        let x2 = 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5;\n        let sign2 = false;\n        let p2 = point_from_x_coord_and_sign(x2, sign2).unwrap();\n\n        assert_eq(p2.x, x2);\n        assert_eq(p2.y, 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0);\n        assert_eq(p2.is_infinite, false);\n    }\n\n    #[test]\n    unconstrained fn test_point_from_x_coord_valid() {\n        // x = 8 is a known quadratic residue - should give a valid point\n        let result = point_from_x_coord(Field::from(8));\n        assert(result.is_some());\n\n        let point = result.unwrap();\n        assert_eq(point.x, Field::from(8));\n        // Check curve equation y^2 = x^3 - 17\n        assert_eq(pow(point.y, 2), pow(point.x, 3) - 17);\n    }\n\n    #[test]\n    unconstrained fn test_point_from_x_coord_invalid() {\n        // x = 3 is a non-residue for this curve - should give None\n        let x = Field::from(3);\n        let maybe_point = point_from_x_coord(x);\n        assert(maybe_point.is_none());\n    }\n\n}\n","path":"/Users/zac/nargo/github.com/AztecProtocol/aztec-nr/v3.0.0-devnet.6-patch.1/aztec/src/utils/point.nr"},"251":{"source":"use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n","path":"/Users/zac/nargo/github.com/noir-lang/poseidon/v0.1.1/src/poseidon2.nr"},"271":{"source":"use crate::traits::{Deserialize, Empty, FromField, Serialize, ToField};\nuse std::meta::derive;\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct FunctionSelector {\n    // 1st 4-bytes (big-endian leftmost) of abi-encoding of an event.\n    pub inner: u32,\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        FunctionSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n\n#[test]\nfn test_is_valid_selector() {\n    let selector = FunctionSelector::from_signature(\"IS_VALID()\");\n    assert_eq(selector.to_field(), 0x73cdda47);\n}\n\n#[test]\nfn test_long_selector() {\n    let selector =\n        FunctionSelector::from_signature(\"foo_and_bar_and_baz_and_foo_bar_baz_and_bar_foo\");\n    assert_eq(selector.to_field(), 0x7590a997);\n}\n","path":"/Users/zac/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.6-patch.1/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr"},"309":{"source":"use crate::{\n    address::{\n        partial_address::PartialAddress, salted_initialization_hash::SaltedInitializationHash,\n    },\n    constants::{\n        AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1, MAX_FIELD_VALUE,\n        MAX_PROTOCOL_CONTRACTS,\n    },\n    contract_class_id::ContractClassId,\n    hash::poseidon2_hash_with_separator,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, ToPoint, TpkM},\n    traits::{Deserialize, Empty, FromField, Packable, Serialize, ToField},\n    utils::field::{pow, sqrt},\n};\n\n// We do below because `use crate::point::Point;` does not work\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\nuse crate::public_keys::AddressPoint;\nuse std::{\n    embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul as derive_public_key},\n    ops::Add,\n};\nuse std::meta::derive;\n\n// Aztec address\n#[derive(Deserialize, Eq, Packable, Serialize)]\npub struct AztecAddress {\n    pub inner: Field,\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    /// Returns an address's `AddressPoint`, which can be used to create shared secrets with the owner\n    /// of the address. If the address is invalid (i.e. it is not a properly derived Aztec address), then this\n    /// returns `Option::none()`, and no shared secrets can be created.\n    pub fn to_address_point(self) -> Option<AddressPoint> {\n        // We compute the address point by taking our address, setting it to x, and then solving for y in the\n        // equation which defines our bn curve:\n        // y^2 = x^3 - 17; x = address\n        let x = self.inner;\n        let y_squared = pow(x, 3) - 17;\n\n        // An invalid AztecAddress is one for which no y coordinate satisfies the curve equation, which we'll\n        // identify by proving that the square root of y_squared does not exist.\n        let mut y_opt = sqrt(y_squared);\n        if y_opt.is_none() {\n            Option::none()\n        } else {\n            let mut y = y_opt.unwrap();\n\n            // If we get a negative y coordinate (any y where y > MAX_FIELD_VALUE / 2), we pin it to the\n            // positive one (any value where y <= MAX_FIELD_VALUE / 2) by subtracting it from the Field modulus\n            // note: The field modulus is MAX_FIELD_VALUE + 1\n            if (!(y.lt(MAX_FIELD_VALUE / 2) | y.eq(MAX_FIELD_VALUE / 2))) {\n                y = (MAX_FIELD_VALUE + 1) - y;\n            }\n\n            Option::some(\n                AddressPoint { inner: Point { x: self.inner, y, is_infinite: false } },\n            )\n        }\n    }\n\n    pub fn compute(public_keys: PublicKeys, partial_address: PartialAddress) -> AztecAddress {\n        let public_keys_hash = public_keys.hash();\n\n        let pre_address = poseidon2_hash_with_separator(\n            [public_keys_hash.to_field(), partial_address.to_field()],\n            GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        );\n\n        let address_point = derive_public_key(EmbeddedCurveScalar::from_field(pre_address)).add(\n            public_keys.ivpk_m.to_point(),\n        );\n\n        // Note that our address is only the x-coordinate of the full address_point. This is okay because when people want to encrypt something and send it to us\n        // they can recover our full point using the x-coordinate (our address itself). To do this, they recompute the y-coordinate according to the equation y^2 = x^3 - 17.\n        // When they do this, they may get a positive y-coordinate (a value that is less than or equal to MAX_FIELD_VALUE / 2) or\n        // a negative y-coordinate (a value that is more than MAX_FIELD_VALUE), and we cannot dictate which one they get and hence the recovered point may sometimes be different than the one\n        // our secret can decrypt. Regardless though, they should and will always encrypt using point with the positive y-coordinate by convention.\n        // This ensures that everyone encrypts to the same point given an arbitrary x-coordinate (address). This is allowed because even though our original point may not have a positive y-coordinate,\n        // with our original secret, we will be able to derive the secret to the point with the flipped (and now positive) y-coordinate that everyone encrypts to.\n        AztecAddress::from_field(address_point.x)\n    }\n\n    pub fn compute_from_class_id(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash,\n        public_keys: PublicKeys,\n    ) -> Self {\n        let partial_address = PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            salted_initialization_hash,\n        );\n\n        AztecAddress::compute(public_keys, partial_address)\n    }\n\n    pub fn is_protocol_contract(self) -> bool {\n        self.inner.lt(MAX_PROTOCOL_CONTRACTS as Field)\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys() {\n    let public_keys = PublicKeys {\n        npk_m: NpkM {\n            inner: Point {\n                x: 0x22f7fcddfa3ce3e8f0cc8e82d7b94cdd740afa3e77f8e4a63ea78a239432dcab,\n                y: 0x0471657de2b6216ade6c506d28fbc22ba8b8ed95c871ad9f3e3984e90d9723a7,\n                is_infinite: false,\n            },\n        },\n        ivpk_m: IvpkM {\n            inner: Point {\n                x: 0x111223493147f6785514b1c195bb37a2589f22a6596d30bb2bb145fdc9ca8f1e,\n                y: 0x273bbffd678edce8fe30e0deafc4f66d58357c06fd4a820285294b9746c3be95,\n                is_infinite: false,\n            },\n        },\n        ovpk_m: OvpkM {\n            inner: Point {\n                x: 0x09115c96e962322ffed6522f57194627136b8d03ac7469109707f5e44190c484,\n                y: 0x0c49773308a13d740a7f0d4f0e6163b02c5a408b6f965856b6a491002d073d5b,\n                is_infinite: false,\n            },\n        },\n        tpk_m: TpkM {\n            inner: Point {\n                x: 0x00d3d81beb009873eb7116327cf47c612d5758ef083d4fda78e9b63980b2a762,\n                y: 0x2f567d22d2b02fe1f4ad42db9d58a36afd1983e7e2909d1cab61cafedad6193a,\n                is_infinite: false,\n            },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(\n        0x0a7c585381b10f4666044266a02405bf6e01fa564c8517d4ad5823493abd31de,\n    );\n\n    let address = AztecAddress::compute(public_keys, partial_address);\n\n    // The following value was generated by `derivation.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_computed_address_from_partial_and_pubkeys =\n        0x24e4646f58b9fbe7d38e317db8d5636c423fbbdfbe119fc190fe9c64747e0c62;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkeys);\n}\n\n#[test]\nfn compute_preaddress_from_partial_and_pub_keys() {\n    let pre_address = poseidon2_hash_with_separator([1, 2], GENERATOR_INDEX__CONTRACT_ADDRESS_V1);\n    let expected_computed_preaddress_from_partial_and_pubkey =\n        0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(pre_address == expected_computed_preaddress_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    // We use the AZTEC_ADDRESS_LENGTH constant to ensure that there is a match between the derived trait\n    // implementation and the constant.\n    let serialized: [Field; AZTEC_ADDRESS_LENGTH] = address.serialize();\n    let deserialized = AztecAddress::deserialize(serialized);\n    assert_eq(address, deserialized);\n}\n\n#[test]\nfn to_address_point_valid() {\n    // x = 8 where x^3 - 17 = 512 - 17 = 495, which is a residue in this field\n    let address = AztecAddress { inner: 8 };\n    let maybe_point = address.to_address_point();\n    assert(maybe_point.is_some());\n\n    let point = maybe_point.unwrap().inner;\n    // check that x is preserved\n    assert_eq(point.x, Field::from(8));\n\n    // check that the curve equation holds: y^2 == x^3 - 17\n    assert_eq(pow(point.y, 2), pow(point.x, 3) - 17);\n}\n\n#[test]\nunconstrained fn to_address_point_invalid() {\n    // x = 3 where x^3 - 17 = 27 - 17 = 10, which is a non-residue in this field\n    let address = AztecAddress { inner: 3 }; //\n    let maybe_point = address.to_address_point();\n    assert(maybe_point.is_none());\n}\n","path":"/Users/zac/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.6-patch.1/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr"},"330":{"source":"// TODO: Expose other wrapped functions than debug (info, warn)\n// ['silent', 'fatal', 'error', 'warn', 'info', 'verbose', 'debug', 'trace']\n\npub global SILENT_LOG_LEVEL: u8 = 0;\npub global FATAL_LOG_LEVEL: u8 = 1;\npub global ERROR_LOG_LEVEL: u8 = 2;\npub global WARN_LOG_LEVEL: u8 = 3;\npub global INFO_LOG_LEVEL: u8 = 4;\npub global VERBOSE_LOG_LEVEL: u8 = 5;\npub global DEBUG_LOG_LEVEL: u8 = 6;\npub global TRACE_LOG_LEVEL: u8 = 7;\n\n/// Utility function to console.log data in the acir simulator.\n/// Example:\n///   debug_log(\"blah blah this is a debug string\");\npub fn debug_log<let N: u32>(msg: str<N>) {\n    debug_log_format(msg, []);\n}\n\n/// Same as debug_log, but allows to customize the log level.\n/// Consider changing just to 'log'\npub fn debug_log_with_level<let N: u32>(log_level: u8, msg: str<N>) {\n    debug_log_format_with_level(log_level, msg, []);\n}\n\n/// Utility function to console.log data in the acir simulator. This variant receives a format string in which the\n/// `${k}` tokens will be replaced with the k-eth value in the `args` array.\n/// Examples:\n///   debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n///   debug_log_format(\"whole array: {}\", [e1, e2, e3, e4]);\npub fn debug_log_format<let M: u32, let N: u32>(msg: str<M>, args: [Field; N]) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { debug_log_array_oracle_wrapper(DEBUG_LOG_LEVEL, msg, args) };\n}\n\n/// Same as debug_log_format, but allows to customize the log level.\n/// Consider changing just to 'log_format'\npub fn debug_log_format_with_level<let M: u32, let N: u32>(\n    log_level: u8,\n    msg: str<M>,\n    args: [Field; N],\n) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { debug_log_array_oracle_wrapper(log_level, msg, args) };\n}\n\n/// Utility function to console.log data in the acir simulator. This variant receives a format string in which the\n/// `${k}` tokens will be replaced with the k-eth value in the `args` slice.\n/// Examples:\n///   debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n///   debug_log_format(\"whole slice: {}\", [e1, e2, e3, e4]);\npub fn debug_log_format_slice<let M: u32>(log_level: u8, msg: str<M>, args: [Field]) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { debug_log_slice_oracle_wrapper(log_level, msg, args) };\n}\n\n// We provide two versions of the debug log oracle: one that takes args as a slice and another one that takes args as an array.\n// We do this since conversion from array to slice generates overhead in public functions, since opcodes need to be emitted for the conversion.\n// By exposing the two flavors, we avoid conversions since the AVM is able to handle both arrays an slices in this oracle.\n\nunconstrained fn debug_log_slice_oracle_wrapper<let M: u32>(\n    log_level: u8,\n    msg: str<M>,\n    args: [Field],\n) {\n    debug_log_slice_oracle(log_level, msg, args);\n}\n\n// WARNING: sometimes when using debug logs the ACVM errors with: `thrown: \"solver opcode resolution error: cannot solve opcode: expression has too many unknowns x155\"`\n#[oracle(utilityDebugLog)]\nunconstrained fn debug_log_slice_oracle<let M: u32>(log_level: u8, msg: str<M>, args: [Field]) {}\n\nunconstrained fn debug_log_array_oracle_wrapper<let M: u32, let N: u32>(\n    log_level: u8,\n    msg: str<M>,\n    args: [Field; N],\n) {\n    debug_log_array_oracle(log_level, msg, N, args);\n}\n\n#[oracle(utilityDebugLog)]\nunconstrained fn debug_log_array_oracle<let M: u32, let N: u32>(\n    log_level: u8,\n    msg: str<M>,\n    length: u32,\n    args: [Field; N],\n) {}\n","path":"/Users/zac/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.6-patch.1/noir-projects/noir-protocol-circuits/crates/types/src/debug_log.nr"},"340":{"source":"mod poseidon2_chunks;\n\nuse crate::{\n    abis::{\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n        function_selector::FunctionSelector,\n        note_hash::NoteHash,\n        nullifier::Nullifier,\n        private_log::{PrivateLog, PrivateLogData},\n        transaction::tx_request::TxRequest,\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        CONTRACT_CLASS_LOG_SIZE_IN_FIELDS, FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__NOTE_HASH_NONCE,\n        GENERATOR_INDEX__OUTER_NULLIFIER, GENERATOR_INDEX__SILOED_NOTE_HASH,\n        GENERATOR_INDEX__UNIQUE_NOTE_HASH, NULL_MSG_SENDER_CONTRACT_ADDRESS, TWO_POW_64,\n    },\n    merkle_tree::root_from_sibling_path,\n    messaging::l2_to_l1_message::L2ToL1Message,\n    poseidon2::Poseidon2Sponge,\n    side_effect::{Counted, Scoped},\n    traits::{FromField, Hash, ToField},\n    utils::field::{field_from_bytes, field_from_bytes_32_trunc},\n};\n\npub use poseidon2_chunks::poseidon2_absorb_in_chunks_existing_sponge;\nuse poseidon2_chunks::poseidon2_absorb_in_chunks;\nuse std::embedded_curve_ops::EmbeddedCurveScalar;\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256::digest(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(\n        function_leaf,\n        function_leaf_index,\n        function_leaf_sibling_path,\n    )\n}\n\npub fn compute_note_hash_nonce(first_nullifier_in_tx: Field, note_index_in_tx: u32) -> Field {\n    // Hashing the first nullifier with note index in tx is guaranteed to be unique (because all nullifiers are also\n    // unique).\n    poseidon2_hash_with_separator(\n        [first_nullifier_in_tx, note_index_in_tx as Field],\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\n    )\n}\n\npub fn compute_unique_note_hash(note_nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [note_nonce, siloed_note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_nonce_and_unique_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    let note_nonce = compute_note_hash_nonce(first_nullifier, note_index_in_tx);\n    compute_unique_note_hash(note_nonce, siloed_note_hash)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), note_hash],\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\n    )\n}\n\n/// Computes unique note hashes from siloed note hashes\npub fn compute_unique_siloed_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    if siloed_note_hash == 0 {\n        0\n    } else {\n        compute_nonce_and_unique_note_hash(siloed_note_hash, first_nullifier, note_index_in_tx)\n    }\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: Scoped<Counted<NoteHash>>) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_note_hash(note_hash.contract_address, note_hash.innermost())\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), nullifier],\n        GENERATOR_INDEX__OUTER_NULLIFIER,\n    )\n}\n\npub fn silo_nullifier(nullifier: Scoped<Counted<Nullifier>>) -> Field {\n    let value = nullifier.innermost().value;\n    // Q: shouldn't we be checking whether the _whole_ nullifier is empty?\n    // A: We don't have to. The init and inner circuits add contract address to non-empty nullifiers.\n    // So we know we should silo it if the contract address is not empty.\n    if nullifier.contract_address.is_zero() {\n        value // Return `value` instead of 0 because an already-siloed nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, value)\n    }\n}\n\npub fn create_protocol_nullifier(tx_request: TxRequest) -> Scoped<Counted<Nullifier>> {\n    Nullifier { value: tx_request.hash(), note_hash: 0 }.count(1).scope(\n        NULL_MSG_SENDER_CONTRACT_ADDRESS,\n    )\n}\n\npub fn compute_siloed_private_log_field(contract_address: AztecAddress, field: Field) -> Field {\n    poseidon2_hash([contract_address.to_field(), field])\n}\n\npub fn silo_private_log(private_log: Scoped<Counted<PrivateLogData>>) -> PrivateLog {\n    let log = private_log.innermost().log;\n    if private_log.contract_address.is_zero() {\n        log\n    } else {\n        let mut fields = log.fields;\n        fields[0] = compute_siloed_private_log_field(private_log.contract_address, fields[0]);\n        PrivateLog::new(fields, log.length)\n    }\n}\n\npub fn compute_contract_class_log_hash(log: [Field; CONTRACT_CLASS_LOG_SIZE_IN_FIELDS]) -> Field {\n    poseidon2_hash(log)\n}\n\npub fn compute_app_secret_key(\n    master_secret_key: EmbeddedCurveScalar,\n    app_address: AztecAddress,\n    app_secret_generator: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [master_secret_key.hi, master_secret_key.lo, app_address.to_field()],\n        app_secret_generator,\n    )\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    let contract_address_bytes: [u8; 32] = contract_address.to_field().to_be_bytes();\n    let recipient_bytes: [u8; 20] = recipient.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let rollup_version_id_bytes: [u8; 32] = rollup_version_id.to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n\n    let mut bytes: [u8; 148] = std::mem::zeroed();\n    for i in 0..32 {\n        bytes[i] = contract_address_bytes[i];\n        bytes[i + 32] = rollup_version_id_bytes[i];\n        // 64 - 84 are for recipient.\n        bytes[i + 84] = chain_id_bytes[i];\n        bytes[i + 116] = content_bytes[i];\n    }\n\n    for i in 0..20 {\n        bytes[64 + i] = recipient_bytes[i];\n    }\n\n    sha256_to_field(bytes)\n}\n\npub fn silo_l2_to_l1_message(\n    msg: Scoped<L2ToL1Message>,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.inner.recipient,\n            msg.inner.content,\n            rollup_version_id,\n            chain_id,\n        )\n    }\n}\n\n/// Computes sha256 hash of 2 input fields.\n///\n/// @returns A truncated field (i.e., the first byte is always 0).\npub fn accumulate_sha256(v0: Field, v1: Field) -> Field {\n    // Concatenate two fields into 32 x 2 = 64 bytes\n    let v0_as_bytes: [u8; 32] = v0.to_be_bytes();\n    let v1_as_bytes: [u8; 32] = v1.to_be_bytes();\n    let hash_input_flattened = v0_as_bytes.concat(v1_as_bytes);\n\n    sha256_to_field(hash_input_flattened)\n}\n\n#[inline_always]\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    poseidon::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let inputs_with_separator = [separator.to_field()].concat(inputs);\n    poseidon2_hash(inputs_with_separator)\n}\n\n/// Computes a Poseidon2 hash over a dynamic-length subarray of the given input.\n/// Only the first `in_len` fields of `input` are absorbed; any remaining fields are ignored.\n/// The caller is responsible for ensuring that the input is padded with zeros if required.\n#[no_predicates]\npub fn poseidon2_hash_subarray<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_in_chunks(input, in_len);\n    sponge.squeeze()\n}\n\n// NB the below is the same as poseidon::poseidon2::Poseidon2::hash(), but replacing a range check with a bit check,\n// and absorbing in chunks of 3 below.\n#[no_predicates]\npub fn poseidon2_cheaper_variable_hash<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_in_chunks(input, in_len);\n    // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n    // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n    // fixed-length and variable-length hashes do not collide)\n    if in_len != N {\n        sponge.absorb(1);\n    }\n    sponge.squeeze()\n}\n\n// This function is  unconstrained because it is intended to be used in unconstrained context only as\n// in constrained contexts it would be too inefficient.\npub unconstrained fn poseidon2_hash_with_separator_bounded_vec<let N: u32, T>(\n    inputs: BoundedVec<Field, N>,\n    separator: T,\n) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs.get(i));\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    let mut fields = [0; (N + 30) / 31];\n    let mut field_index = 0;\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            fields[field_index] = field_from_bytes(current_field, false);\n            current_field = [0; 31];\n            field_index += 1;\n        }\n    }\n    if field_index != fields.len() {\n        fields[field_index] = field_from_bytes(current_field, false);\n    }\n    poseidon2_hash(fields)\n}\n\n#[test]\nfn poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let sub_chunk_hash = poseidon2_hash_subarray(input, in_len);\n    let fixed_len_hash = poseidon::poseidon2::Poseidon2::hash(fixed_input, fixed_input.len());\n    assert(sub_chunk_hash == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_matches_variable() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let variable_chunk_hash = poseidon2_cheaper_variable_hash(input, in_len);\n    let variable_len_hash = poseidon::poseidon2::Poseidon2::hash(input, in_len);\n    assert(variable_chunk_hash == variable_len_hash);\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = sha256::digest(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result =\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0x3b18c58c739716e76429634a61375c45b3b5cd470c22ab6d3e14cee23dd992);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(\n        AztecAddress::from_field(1),\n        EthAddress::from_field(3),\n        5,\n        2,\n        4,\n    );\n    assert(hash_result == 0xaab2a5828156782b12a1dc6f336e2bc627eb1b9514b02d511f66296990c050);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        L2ToL1Message { recipient: EthAddress::from_field(1), content: 2 }.scope(\n            AztecAddress::from_field(3),\n        ),\n        version,\n        chainId,\n    );\n\n    // The following value was generated by `yarn-project/stdlib/src/hash/hash.test.ts`\n    let hash_from_typescript = 0x0081edf209e087ad31b3fd24263698723d57190bd1d6e9fe056fc0c0a68ee661;\n\n    assert_eq(hash, hash_from_typescript);\n}\n\n#[test]\nunconstrained fn poseidon2_hash_with_separator_bounded_vec_matches_non_bounded_vec_version() {\n    let inputs = BoundedVec::<Field, 4>::from_array([1, 2, 3]);\n    let separator = 42;\n\n    // Hash using bounded vec version\n    let bounded_result = poseidon2_hash_with_separator_bounded_vec(inputs, separator);\n\n    // Hash using regular version\n    let regular_result = poseidon2_hash_with_separator([1, 2, 3], separator);\n\n    // Results should match\n    assert_eq(bounded_result, regular_result);\n}\n","path":"/Users/zac/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.6-patch.1/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr"},"353":{"source":"use utils::derive_serialization_quotes;\n\npub mod utils;\n\n/// Generates the generic parameter declarations for a struct's trait implementation.\n///\n/// This function takes a struct type definition and generates the generic parameter declarations\n/// that go after the `impl` keyword. For example, given a struct with generics `N: u32` and `T`,\n/// it generates `<let N: u32, T>`.\n///\n/// # Parameters\n/// - `s`: The struct type definition to generate generic declarations for\n///\n/// # Returns\n/// A quoted code block containing the generic parameter declarations, or an empty quote if the struct\n/// has no generic parameters\n///\n/// # Example\n/// For a struct defined as:\n/// ```\n/// struct Container<T, let N: u32> {\n///     items: [T; N],\n///     count: u32\n/// }\n/// ```\n///\n/// This function generates:\n/// ```\n/// <let N: u32, T>\n/// ```\ncomptime fn get_generics_declarations(s: TypeDefinition) -> Quoted {\n    let generics = s.generics();\n\n    if generics.len() > 0 {\n        let generics_declarations_items = generics\n            .map(|(name, maybe_integer_typ)| {\n                // The second item in the generics tuple is an Option of an integer type that is Some only if\n                // the generic is numeric.\n                if maybe_integer_typ.is_some() {\n                    // The generic is numeric, so we return a quote defined as e.g. \"let N: u32\"\n                    let integer_type = maybe_integer_typ.unwrap();\n                    quote {let $name: $integer_type}\n                } else {\n                    // The generic is not numeric, so we return a quote containing the name of the generic (e.g. \"T\")\n                    quote {$name}\n                }\n            })\n            .join(quote {,});\n        quote {<$generics_declarations_items>}\n    } else {\n        // The struct doesn't have any generics defined, so we just return an empty quote.\n        quote {}\n    }\n}\n\n/// Generates the `where` clause for a trait implementation that constrains non-numeric generic type parameters.\n///\n/// This function takes a struct type definition and a trait name, and generates a `where` clause that\n/// requires all non-numeric generic type parameters to implement the specified trait.\n///\n/// # Parameters\n/// - `s`: The struct type definition to generate the where clause for\n/// - `trait_name`: The name of the trait that non-numeric generic parameters must implement\n///\n/// # Returns\n/// A quoted code block containing the where clause, or an empty quote if the struct has no non-numeric\n/// generic parameters\n///\n/// # Example\n/// For a struct defined as:\n/// ```\n/// struct Container<T, let N: u32> {\n///     items: [T; N],\n///     count: u32\n/// }\n/// ```\n///\n/// And trait name \"Serialize\", this function generates:\n/// ```\n/// where T: Serialize\n/// ```\ncomptime fn get_where_trait_clause(s: TypeDefinition, trait_name: Quoted) -> Quoted {\n    let generics = s.generics();\n\n    // The second item in the generics tuple is an Option of an integer type that is Some only if the generic is\n    // numeric.\n    let non_numeric_generics =\n        generics.filter(|(_, maybe_integer_typ)| maybe_integer_typ.is_none());\n\n    if non_numeric_generics.len() > 0 {\n        let non_numeric_generics_declarations =\n            non_numeric_generics.map(|(name, _)| quote {$name: $trait_name}).join(quote {,});\n        quote {where $non_numeric_generics_declarations}\n    } else {\n        // There are no non-numeric generics, so we return an empty quote.\n        quote {}\n    }\n}\n\n/// Generates a `Serialize` trait implementation for a struct type.\n///\n/// # Parameters\n/// - `s`: The struct type definition to generate the implementation for\n///\n/// # Returns\n/// A quoted code block containing the trait implementation\n///\n/// # Example\n/// For a struct defined as:\n/// ```\n/// struct Log<N> {\n///     fields: [Field; N],\n///     length: u32\n/// }\n/// ```\n///\n/// This function generates code equivalent to:\n/// ```\n/// impl<let N: u32> Serialize for Log<N> {\n///     let N: u32 = <[Field; N] as Serialize>::N + <u32 as Serialize>::N;\n///\n///     #[inline_always]\n///     fn serialize(self) -> [Field; Self::N] {\n///         let mut serialized_params = [0; _];\n///         let mut offset = 0;\n///\n///         let serialized_member = Serialize::serialize(self.fields);\n///         let serialized_member_len = <[Field; N] as Serialize>::N;\n///         for i in 0..serialized_member_len {\n///             serialized_params[i + offset] = serialized_member[i];\n///         }\n///         offset += serialized_member_len;\n///\n///         let serialized_member = Serialize::serialize(self.length);\n///         let serialized_member_len = <u32 as Serialize>::N;\n///         for i in 0..serialized_member_len {\n///             serialized_params[i + offset] = serialized_member[i];\n///         }\n///         offset += serialized_member_len;\n///\n///         serialized_params\n///     }\n/// }\n/// ```\npub comptime fn derive_serialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let nested_struct = typ.as_data_type().unwrap();\n\n    // We care only about the name and type so we drop the last item of the tuple\n    let params = nested_struct.0.fields(nested_struct.1).map(|(name, typ, _)| (name, typ));\n\n    // Generates the generic parameter declarations (to be placed after the `impl` keyword) and the `where` clause\n    // for the `Serialize` trait.\n    let generics_declarations = get_generics_declarations(s);\n    let where_serialize_clause = get_where_trait_clause(s, quote {Serialize});\n\n    let (function_body, params_len_quote, serialized_params_name) =\n        derive_serialization_quotes(params, true);\n\n    quote {\n        impl$generics_declarations $crate::traits::Serialize for $typ\n            $where_serialize_clause\n        {\n            let N: u32 = $params_len_quote;\n\n            #[inline_always]\n            fn serialize(self) -> [Field; Self::N] {\n                $function_body\n\n                $serialized_params_name\n            }\n        }\n    }\n}\n\n/// Generates a `Deserialize` trait implementation for a given struct `s`.\n///\n/// # Arguments\n/// * `s` - The struct type definition to generate the implementation for\n///\n/// # Returns\n/// A `Quoted` block containing the generated trait implementation\n///\n/// # Requirements\n/// Each struct member type must implement the `Deserialize` trait (it gets used in the generated code).\n///\n/// # Example\n/// For a struct like:\n/// ```\n/// struct MyStruct {\n///     x: AztecAddress,\n///     y: Field,\n/// }\n/// ```\n///\n/// This generates:\n/// ```\n/// impl Deserialize for MyStruct {\n///     let N: u32 = <AztecAddress as Deserialize>::N + <Field as Deserialize>::N;\n///\n///     fn deserialize(serialized: [Field; Self::N]) -> Self {\n///         let mut offset = 0;\n///         let mut member_fields = [0; <AztecAddress as Deserialize>::N];\n///         for i in 0..<AztecAddress as Deserialize>::N {\n///             member_fields[i] = serialized[i + offset];\n///         }\n///         let x = <AztecAddress as Deserialize>::deserialize(member_fields);\n///         offset += <AztecAddress as Deserialize>::N;\n///\n///         let mut member_fields = [0; <Field as Deserialize>::N];\n///         for i in 0..<Field as Deserialize>::N {\n///             member_fields[i] = serialized[i + offset];\n///         }\n///         let y = <Field as Deserialize>::deserialize(member_fields);\n///         offset += <Field as Deserialize>::N;\n///\n///         Self { x, y }\n///     }\n/// }\n/// ```\npub(crate) comptime fn derive_deserialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let nested_struct = typ.as_data_type().unwrap();\n    let params = nested_struct.0.fields(nested_struct.1);\n\n    // Generates the generic parameter declarations (to be placed after the `impl` keyword) and the `where` clause\n    // for the `Deserialize` trait.\n    let generics_declarations = get_generics_declarations(s);\n    let where_deserialize_clause = get_where_trait_clause(s, quote {Deserialize});\n\n    // The following will give us:\n    // <type_of_struct_member_1 as Deserialize>::N + <type_of_struct_member_2 as Deserialize>::N + ...\n    // (or 0 if the struct has no members)\n    let right_hand_side_of_definition_of_n = if params.len() > 0 {\n        params\n            .map(|(_, param_type, _): (Quoted, Type, Quoted)| {\n                quote {\n            <$param_type as $crate::traits::Deserialize>::N\n        }\n            })\n            .join(quote {+})\n    } else {\n        quote {0}\n    };\n\n    // For structs containing a single member, we can enhance performance by directly deserializing the input array,\n    // bypassing the need for loop-based array construction. While this optimization yields significant benefits in\n    // Brillig where the loops are expected to not be optimized, it is not relevant in ACIR where the loops are\n    // expected to be optimized away.\n    let function_body = if params.len() > 1 {\n        // This generates deserialization code for each struct member and concatenates them together.\n        let deserialization_of_struct_members = params\n            .map(|(param_name, param_type, _): (Quoted, Type, Quoted)| {\n                quote {\n                    let mut member_fields = [0; <$param_type as Deserialize>::N];\n                    for i in 0..<$param_type as Deserialize>::N {\n                        member_fields[i] = serialized[i + offset];\n                    }\n                    let $param_name = <$param_type as Deserialize>::deserialize(member_fields);\n                    offset += <$param_type as Deserialize>::N;\n                }\n            })\n            .join(quote {});\n\n        // We join the struct member names with a comma to be used in the `Self { ... }` syntax\n        // This will give us e.g. `a, b, c` for a struct with three fields named `a`, `b`, and `c`.\n        let struct_members = params\n            .map(|(param_name, _, _): (Quoted, Type, Quoted)| quote { $param_name })\n            .join(quote {,});\n\n        quote {\n            let mut offset = 0;\n\n            $deserialization_of_struct_members\n\n            Self { $struct_members }\n        }\n    } else if params.len() == 1 {\n        let param_name = params[0].0;\n        quote {\n            Self { $param_name: $crate::traits::Deserialize::deserialize(serialized) }\n        }\n    } else {\n        quote {\n            Self {}\n        }\n    };\n\n    quote {\n        impl$generics_declarations $crate::traits::Deserialize for $typ\n            $where_deserialize_clause\n        {\n            let N: u32 = $right_hand_side_of_definition_of_n;\n\n            #[inline_always]\n            fn deserialize(serialized: [Field; Self::N]) -> Self {\n                $function_body\n            }\n        }\n    }\n}\n\n/// Generates a `Packable` trait implementation for a given struct `s`.\n///\n/// # Arguments\n/// * `s` - The struct type definition to generate the implementation for\n///\n/// # Returns\n/// A `Quoted` block containing the generated trait implementation\n///\n/// # Requirements\n/// Each struct member type must implement the `Packable` trait (it gets used in the generated code).\n///\n/// # Example\n/// For a struct like:\n/// ```\n/// struct MyStruct {\n///     x: AztecAddress,\n///     y: Field,\n/// }\n/// ```\n///\n/// This generates:\n/// ```\n/// impl Packable for MyStruct {\n///     let N: u32 = 2;\n///\n///     fn pack(self) -> [Field; 2] {\n///         let mut result: [Field; 2] = [0_Field; 2];\n///         let mut offset: u32 = 0_u32;\n///         let packed_member: [Field; 1] = self.x.pack();\n///         let packed_member_len: u32 = <Field as Packable>::N;\n///         for i in 0_u32..packed_member_len {\n///             {\n///                 result[i + offset] = packed_member[i];\n///             }\n///         }\n///         offset = offset + packed_member_len;\n///         let packed_member: [Field; 1] = self.y.pack();\n///         let packed_member_len: u32 = <Field as Packable>::N;\n///         for i in 0_u32..packed_member_len {\n///             {\n///                 result[i + offset] = packed_member[i];\n///             }\n///         }\n///         offset = offset + packed_member_len;\n///         result\n///     }\n///\n///     fn unpack(packed: [Field; 2]) -> Self {\n///         let mut offset: u32 = 0_u32;\n///         let mut member_fields: [Field; 1] = [0_Field; 1];\n///         for i in 0_u32..<AztecAddress as Packable>::N {\n///             member_fields[i] = packed[i + offset];\n///         }\n///         let x: AztecAddress = <AztecAddress as Packable>::unpack(member_fields);\n///         offset = offset + <AztecAddress as Packable>::N;\n///         let mut member_fields: [Field; 1] = [0_Field; 1];\n///         for i in 0_u32..<Field as Packable>::N {\n///             member_fields[i] = packed[i + offset];\n///         }\n///         let y: Field = <Field as Packable>::unpack(member_fields);\n///         offset = offset + <Field as Packable>::N;\n///         Self { x: x, y: y }\n///     }\n/// }\n/// ```\npub comptime fn derive_packable(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let nested_struct = typ.as_data_type().unwrap();\n    let params = nested_struct.0.fields(nested_struct.1);\n\n    // Generates the generic parameter declarations (to be placed after the `impl` keyword) and the `where` clause\n    // for the `Packable` trait.\n    let generics_declarations = get_generics_declarations(s);\n    let where_packable_clause = get_where_trait_clause(s, quote {Packable});\n\n    // The following will give us:\n    // <type_of_struct_member_1 as Packable>::N + <type_of_struct_member_2 as Packable>::N + ...\n    // (or 0 if the struct has no members)\n    let right_hand_side_of_definition_of_n = if params.len() > 0 {\n        params\n            .map(|(_, param_type, _): (Quoted, Type, Quoted)| {\n                quote {\n            <$param_type as $crate::traits::Packable>::N\n        }\n            })\n            .join(quote {+})\n    } else {\n        quote {0}\n    };\n\n    // For structs containing a single member, we can enhance performance by directly returning the packed member,\n    // bypassing the need for loop-based array construction. While this optimization yields significant benefits in\n    // Brillig where the loops are expected to not be optimized, it is not relevant in ACIR where the loops are\n    // expected to be optimized away.\n    let pack_function_body = if params.len() > 1 {\n        // For multiple struct members, generate packing code that:\n        // 1. Packs each member\n        // 2. Copies the packed fields into the result array at the correct offset\n        // 3. Updates the offset for the next member\n        let packing_of_struct_members = params\n            .map(|(param_name, param_type, _): (Quoted, Type, Quoted)| {\n                quote {\n                    let packed_member = $crate::traits::Packable::pack(self.$param_name);\n                    let packed_member_len = <$param_type as $crate::traits::Packable>::N;\n                    for i in 0..packed_member_len {\n                        result[i + offset] = packed_member[i];\n                    }\n                    offset += packed_member_len;\n                }\n            })\n            .join(quote {});\n\n        quote {\n            let mut result = [0; Self::N];\n            let mut offset = 0;\n\n            $packing_of_struct_members\n\n            result\n        }\n    } else if params.len() == 1 {\n        let param_name = params[0].0;\n        quote {\n            $crate::traits::Packable::pack(self.$param_name)\n        }\n    } else {\n        quote {\n            [0; Self::N]\n        }\n    };\n\n    // For structs containing a single member, we can enhance performance by directly unpacking the input array,\n    // bypassing the need for loop-based array construction. While this optimization yields significant benefits in\n    // Brillig where the loops are expected to not be optimized, it is not relevant in ACIR where the loops are\n    // expected to be optimized away.\n    let unpack_function_body = if params.len() > 1 {\n        // For multiple struct members, generate unpacking code that:\n        // 1. Unpacks each member\n        // 2. Copies packed fields into member array at correct offset\n        // 3. Updates offset for next member\n        let unpacking_of_struct_members = params\n            .map(|(param_name, param_type, _): (Quoted, Type, Quoted)| {\n                quote {\n                    let mut member_fields = [0; <$param_type as $crate::traits::Packable>::N];\n                    for i in 0..<$param_type as $crate::traits::Packable>::N {\n                        member_fields[i] = packed[i + offset];\n                    }\n                    let $param_name = <$param_type as $crate::traits::Packable>::unpack(member_fields);\n                    offset += <$param_type as $crate::traits::Packable>::N;\n                }\n            })\n            .join(quote {});\n\n        // We join the struct member names with a comma to be used in the `Self { ... }` syntax\n        let struct_members = params\n            .map(|(param_name, _, _): (Quoted, Type, Quoted)| quote { $param_name })\n            .join(quote {,});\n\n        quote {\n            let mut offset = 0;\n            $unpacking_of_struct_members\n            Self { $struct_members }\n        }\n    } else if params.len() == 1 {\n        let param_name = params[0].0;\n        quote {\n            Self { $param_name: $crate::traits::Packable::unpack(packed) }\n        }\n    } else {\n        quote {\n            Self {}\n        }\n    };\n\n    quote {\n        impl$generics_declarations $crate::traits::Packable for $typ\n            $where_packable_clause\n        {\n            let N: u32 = $right_hand_side_of_definition_of_n;\n\n            #[inline_always]\n            fn pack(self) -> [Field; Self::N] {\n                $pack_function_body\n            }\n\n            #[inline_always]\n            fn unpack(packed: [Field; Self::N]) -> Self {\n                $unpack_function_body\n            }\n        }\n    }\n}\n\nmod test {\n    use crate::traits::{Deserialize, Packable, Serialize};\n\n    #[derive(Deserialize, Eq, Packable, Serialize)]\n    pub struct Empty {}\n\n    #[derive(Deserialize, Eq, Packable, Serialize)]\n    pub struct Smol {\n        a: Field,\n        b: Field,\n    }\n\n    #[derive(Deserialize, Eq, Serialize)]\n    pub struct HasArray {\n        a: [Field; 2],\n        b: bool,\n    }\n\n    #[derive(Deserialize, Eq, Serialize)]\n    pub struct Fancier {\n        a: Smol,\n        b: [Field; 2],\n        c: [u8; 3],\n        d: str<16>,\n    }\n\n    #[derive(Deserialize, Eq, Packable, Serialize)]\n    pub struct HasArrayWithGenerics<T, let N: u32> {\n        pub fields: [T; N],\n        pub length: u32,\n    }\n\n    #[test]\n    fn serde_on_empty() {\n        let original = Empty {};\n        let serialized = original.serialize();\n        assert_eq(serialized, [], \"Serialized does not match empty array\");\n        let deserialized = Empty::deserialize(serialized);\n        assert_eq(deserialized, original, \"Deserialized does not match original\");\n    }\n\n    #[test]\n    fn packable_on_empty() {\n        let original = Empty {};\n        let packed = original.pack();\n        assert_eq(packed, [], \"Packed does not match empty array\");\n        let unpacked = Empty::unpack(packed);\n        assert_eq(unpacked, original, \"Unpacked does not match original\");\n    }\n\n    #[test]\n    fn serde_on_smol() {\n        let smol = Smol { a: 1, b: 2 };\n        let serialized = smol.serialize();\n        assert(serialized == [1, 2], serialized);\n        let deserialized = Smol::deserialize(serialized);\n        assert(deserialized == smol);\n\n        // None of the struct members implements the `Packable` trait so the packed and serialized data should be the same\n        let packed = smol.pack();\n        assert_eq(packed, serialized, \"Packed does not match serialized\");\n    }\n\n    #[test]\n    fn serde_on_has_array() {\n        let has_array = HasArray { a: [1, 2], b: true };\n        let serialized = has_array.serialize();\n        assert(serialized == [1, 2, 1], serialized);\n        let deserialized = HasArray::deserialize(serialized);\n        assert(deserialized == has_array);\n    }\n\n    #[test]\n    fn serde_on_fancier() {\n        let fancier =\n            Fancier { a: Smol { a: 1, b: 2 }, b: [0, 1], c: [1, 2, 3], d: \"metaprogramming!\" };\n        let serialized = fancier.serialize();\n        assert(\n            serialized\n                == [\n                    1, 2, 0, 1, 1, 2, 3, 0x6d, 0x65, 0x74, 0x61, 0x70, 0x72, 0x6f, 0x67, 0x72, 0x61,\n                    0x6d, 0x6d, 0x69, 0x6e, 0x67, 0x21,\n                ],\n            serialized,\n        );\n        let deserialized = Fancier::deserialize(serialized);\n        assert(deserialized == fancier);\n    }\n\n    #[test]\n    fn serde_on_contains_array_with_generics() {\n        let struct_with_array_of_generics = HasArrayWithGenerics { fields: [1, 2, 3], length: 3 };\n        let serialized = struct_with_array_of_generics.serialize();\n        assert(serialized == [1, 2, 3, 3], serialized);\n        let deserialized = HasArrayWithGenerics::deserialize(serialized);\n        assert(deserialized == struct_with_array_of_generics);\n    }\n\n    #[test]\n    fn packable_on_contains_array_with_generics() {\n        let struct_with_array_of_generics = HasArrayWithGenerics { fields: [1, 2, 3], length: 3 };\n        let packed = struct_with_array_of_generics.pack();\n        assert(packed == [1, 2, 3, 3], packed);\n\n        let unpacked = HasArrayWithGenerics::unpack(packed);\n        assert(unpacked == struct_with_array_of_generics);\n    }\n\n}\n","path":"/Users/zac/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.6-patch.1/noir-projects/noir-protocol-circuits/crates/types/src/meta/mod.nr"},"354":{"source":"/// Generates serialization code for a list of parameters and the total length of the serialized array\n///\n/// # Parameters\n/// - `params`: A list of (name, type) tuples to serialize\n/// - `use_self_prefix`: If true, parameters are accessed as `self.$param_name` (for struct members).\n///                      If false, parameters are accessed directly as `$param_name` (for function parameters).\n///\n/// # Returns\n/// A tuple containing:\n/// - Quoted code that serializes the parameters into an array named `serialized_params`\n/// - Quoted code that evaluates to the total length of the serialized array\n/// - Quoted code containing the name of the serialized array\npub comptime fn derive_serialization_quotes(\n    params: [(Quoted, Type)],\n    use_self_prefix: bool,\n) -> (Quoted, Quoted, Quoted) {\n    let prefix_quote = if use_self_prefix {\n        quote { self. }\n    } else {\n        quote {}\n    };\n\n    let params_len_quote = get_params_len_quote(params);\n    let serialized_params_name = quote { serialized_params };\n\n    let body = if params.len() == 0 {\n        quote {\n            let $serialized_params_name: [Field; 0] = [];\n        }\n    } else if params.len() == 1 {\n        // When we have only a single parameter on the input, we can enhance performance by directly returning\n        // the serialized member, bypassing the need for loop-based array construction. While this optimization yields\n        // significant benefits in Brillig where the loops are expected to not be optimized, it is not relevant in ACIR\n        // where the loops are expected to be optimized away.\n\n        let param_name = params[0].0;\n        quote {\n            let $serialized_params_name = $crate::traits::Serialize::serialize($prefix_quote$param_name);\n        }\n    } else {\n        // For multiple struct members, generate serialization code that:\n        // 1. Serializes each member\n        // 2. Copies the serialized fields into the serialize array at the correct offset\n        // 3. Updates the offset for the next member\n        let serialization_of_struct_members = params\n            .map(|(param_name, param_type): (Quoted, Type)| {\n                quote {\n                let serialized_member = $crate::traits::Serialize::serialize($prefix_quote$param_name);\n                let serialized_member_len = <$param_type as $crate::traits::Serialize>::N;\n                for i in 0..serialized_member_len {\n                    $serialized_params_name[i + offset] = serialized_member[i];\n                }\n                offset += serialized_member_len;\n            }\n            })\n            .join(quote {});\n\n        quote {\n            let mut $serialized_params_name = [0; $params_len_quote];\n            let mut offset = 0;\n\n            $serialization_of_struct_members\n        }\n    };\n\n    (body, params_len_quote, serialized_params_name)\n}\n\n/// Generates a quoted expression that computes the total serialized length of function parameters.\n///\n/// # Parameters\n/// * `params` - An array of tuples where each tuple contains a quoted parameter name and its Type. The type needs\n///              to implement the Serialize trait.\n///\n/// # Returns\n/// A quoted expression that evaluates to:\n/// * `0` if there are no parameters\n/// * `(<type1 as Serialize>::N + <type2 as Serialize>::N + ...)` for one or more parameters\npub comptime fn get_params_len_quote(params: [(Quoted, Type)]) -> Quoted {\n    if params.len() == 0 {\n        quote { 0 }\n    } else {\n        let params_quote_without_parentheses = params\n            .map(|(_, param_type): (Quoted, Type)| {\n                quote {\n                    <$param_type as $crate::traits::Serialize>::N\n                }\n            })\n            .join(quote {+});\n        quote { ($params_quote_without_parentheses) }\n    }\n}\n","path":"/Users/zac/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.6-patch.1/noir-projects/noir-protocol-circuits/crates/types/src/meta/utils.nr"},"356":{"source":"use crate::constants::TWO_POW_64;\nuse crate::traits::{Deserialize, Serialize};\nuse std::meta::derive;\n// NB: This is a clone of noir/noir-repo/noir_stdlib/src/hash/poseidon2.nr\n// It exists as we sometimes need to perform custom absorption, but the stdlib version\n// has a private absorb() method (it's also designed to just be a hasher)\n// Can be removed when standalone noir poseidon lib exists: See noir#6679\n\ncomptime global RATE: u32 = 3;\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct Poseidon2Sponge {\n    pub cache: [Field; 3],\n    pub state: [Field; 4],\n    pub cache_size: u32,\n    pub squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2Sponge {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2Sponge::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2Sponge {\n        let mut result =\n            Poseidon2Sponge { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = std::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    pub fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    pub fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let iv: Field = (in_len as Field) * TWO_POW_64;\n        let mut sponge = Poseidon2Sponge::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n","path":"/Users/zac/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.6-patch.1/noir-projects/noir-protocol-circuits/crates/types/src/poseidon2.nr"},"368":{"source":"use crate::{hash::poseidon2_hash, traits::ToField};\n\npub fn derive_storage_slot_in_map<K>(storage_slot: Field, key: K) -> Field\nwhere\n    K: ToField,\n{\n    poseidon2_hash([storage_slot, key.to_field()])\n}\n\nmod test {\n    use crate::{address::AztecAddress, storage::map::derive_storage_slot_in_map, traits::FromField};\n\n    #[test]\n    fn test_derive_storage_slot_in_map_matches_typescript() {\n        let map_slot = 0x132258fb6962c4387ba659d9556521102d227549a386d39f0b22d1890d59c2b5;\n        let key = AztecAddress::from_field(\n            0x302dbc2f9b50a73283d5fb2f35bc01eae8935615817a0b4219a057b2ba8a5a3f,\n        );\n\n        let slot = derive_storage_slot_in_map(map_slot, key);\n\n        // The following value was generated by `map_slot.test.ts`\n        let slot_from_typescript =\n            0x15b9fe39449affd8b377461263e9d2b610b9ad40580553500b4e41d9cbd887ac;\n\n        assert_eq(slot, slot_from_typescript);\n    }\n}\n","path":"/Users/zac/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.6-patch.1/noir-projects/noir-protocol-circuits/crates/types/src/storage/map.nr"},"384":{"source":"use crate::meta::{derive_deserialize, derive_packable, derive_serialize};\nuse crate::utils::field::field_from_bytes;\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic\n// if a value can actually be zero. In a future refactor, we can\n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\npub trait Empty: Eq {\n    fn empty() -> Self;\n\n    fn is_empty(self) -> bool {\n        self.eq(Self::empty())\n    }\n\n    // Requires this Noir fix: https://github.com/noir-lang/noir/issues/9002\n    // fn assert_not_empty<let U: u32>(self, msg: str<U>) { // This msg version was failing with weird compiler errors.\n    //     // We provide a default impl but it's likely inefficient.\n    //     // The reason we include this function is because there's a lot of\n    //     // opportunity for optimisation on a per-struct basis.\n    //     // You only need to show one element is not empty to know that the whole thing\n    //     // is not empty.\n    //     // If you know an element of your struct which should always be nonempty,\n    //     // you can write an impl that solely checks that that element is nonempty.\n    //     assert(!self.is_empty(), msg);\n    // }\n\n    // This default impl is overwritten by types like arrays, because there's a much\n    // more efficient approach.\n    fn assert_empty<let S: u32>(self, msg: str<S>) {\n        assert(self.is_empty(), msg);\n    }\n}\n\nimpl Empty for Field {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl Empty for bool {\n    #[inline_always]\n    fn empty() -> Self {\n        false\n    }\n}\n\nimpl Empty for u1 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u8 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u16 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u32 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u64 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u128 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl<T, let N: u32> Empty for [T; N]\nwhere\n    T: Empty,\n{\n    #[inline_always]\n    fn empty() -> Self {\n        [T::empty(); N]\n    }\n\n    fn is_empty(self) -> bool {\n        self.all(|elem| elem.is_empty())\n    }\n\n    fn assert_empty<let S: u32>(self, msg: str<S>) -> () {\n        self.for_each(|elem| elem.assert_empty(msg))\n    }\n}\n\nimpl<T> Empty for [T]\nwhere\n    T: Empty,\n{\n    #[inline_always]\n    fn empty() -> Self {\n        [T::empty()]\n    }\n\n    fn is_empty(self) -> bool {\n        self.all(|elem| elem.is_empty())\n    }\n\n    fn assert_empty<let S: u32>(self, msg: str<S>) -> () {\n        self.for_each(|elem| elem.assert_empty(msg))\n    }\n}\nimpl<A, B> Empty for (A, B)\nwhere\n    A: Empty,\n    B: Empty,\n{\n    #[inline_always]\n    fn empty() -> Self {\n        (A::empty(), B::empty())\n    }\n}\n\nimpl<T> Empty for Option<T>\nwhere\n    T: Eq,\n{\n    #[inline_always]\n    fn empty() -> Self {\n        Option::none()\n    }\n}\n\n// pub fn is_empty<T>(item: T) -> bool\n// where\n//     T: Empty,\n// {\n//     item.eq(T::empty())\n// }\n\n// pub fn is_empty_array<T, let N: u32>(array: [T; N]) -> bool\n// where\n//     T: Empty,\n// {\n//     array.all(|elem| is_empty(elem))\n// }\n\n// pub fn assert_empty<T>(item: T) -> ()\n// where\n//     T: Empty,\n// {\n//     assert(item.eq(T::empty()))\n// }\n\n// pub fn assert_empty_array<T, let N: u32>(array: [T; N]) -> ()\n// where\n//     T: Empty,\n// {\n//     // A cheaper option than `is_empty_array` for if you don't need to gracefully\n//     // handle a bool result.\n//     // Avoids the `&` operator of `is_empty_array`'s `.all()` call.\n//     for i in 0..N {\n//         assert(is_empty(array[i]));\n//     }\n// }\n\npub trait Hash {\n    fn hash(self) -> Field;\n}\n\npub trait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u1 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u8 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u16 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u32 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u64 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u128 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl<let N: u32> ToField for str<N> {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\npub trait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value != 0\n    }\n}\nimpl FromField for u1 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u1\n    }\n}\nimpl FromField for u8 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u8\n    }\n}\nimpl FromField for u16 {\n    fn from_field(value: Field) -> Self {\n        value as u16\n    }\n}\nimpl FromField for u32 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u32\n    }\n}\nimpl FromField for u64 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u64\n    }\n}\nimpl FromField for u128 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u128\n    }\n}\n\n// docs:start:serialize\n/// Trait for serializing Noir types into arrays of Fields.\n///\n/// An implementation of the Serialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait (and Deserialize) are\n/// typically used to communicate between Noir and TypeScript (via oracles and function arguments).\n///\n/// # On Following Noir's Intrinsic Serialization\n/// When calling a Noir function from TypeScript (TS), first the function arguments are serialized into an array\n/// of fields. This array is then included in the initial witness. Noir's intrinsic serialization is then used\n/// to deserialize the arguments from the witness. When the same Noir function is called from Noir this Serialize trait\n/// is used instead of the serialization in TS. For this reason we need to have a match between TS serialization,\n/// Noir's intrinsic serialization and the implementation of this trait. If there is a mismatch, the function calls\n/// fail with an arguments hash mismatch error message.\n///\n/// # Associated Constants\n/// * `N` - The length of the output Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let N: u32> Serialize for str<N> {\n///     let N: u32 = N;\n///\n///     fn serialize(self) -> [Field; Self::N] {\n///         let bytes = self.as_bytes();\n///         let mut fields = [0; Self::N];\n///         for i in 0..bytes.len() {\n///             fields[i] = bytes[i] as Field;  // Each byte gets its own Field\n///         }\n///         fields\n///     }\n/// }\n/// ```\n#[derive_via(derive_serialize)]\npub trait Serialize {\n    let N: u32;\n\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<let M: u32> Serialize for str<M> {\n    let N: u32 = M;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        let bytes = self.as_bytes();\n        let mut fields = [0; Self::N];\n        for i in 0..bytes.len() {\n            fields[i] = bytes[i] as Field;\n        }\n        fields\n    }\n}\n\n/// Implementation of Deserialize for BoundedVec.\n///\n/// This implementation deserializes a BoundedVec from an array of Fields. The array contains:\n/// 1. The serialized items, each taking up T::N Fields\n/// 2. The length of the BoundedVec as the last Field\n///\n/// # Type Parameters\n/// * `T` - The type of items stored in the BoundedVec, must implement Deserialize\n/// * `M` - The maximum length of the BoundedVec\n///\n/// # Fields Array Layout\n/// [item1_field1, item1_field2, ..., item2_field1, item2_field2, ..., length]\n/// Where:\n/// - itemN_fieldM: The M-th Field of the N-th item (T::N Fields per item)\n/// - length: The number of items in the BoundedVec (1 Field)\n///\n/// Total length N = T::N * M + 1, where:\n/// - T::N is the number of Fields needed to deserialize one item\n/// - M is the maximum length of the BoundedVec\n/// - +1 is for storing the length\n///\n/// # Note\n/// Not deriving this because it's not supported to call derive_deserialize on a \"remote\" struct (and it will never\n/// be supported).\nimpl<T, let M: u32> Deserialize for BoundedVec<T, M>\nwhere\n    T: Deserialize,\n{\n    let N: u32 = <T as Deserialize>::N * M + 1;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        let mut new_bounded_vec: BoundedVec<T, M> = BoundedVec::new();\n\n        // Length is stored in the last field as we need to match intrinsic Noir serialization and the `len` struct\n        // field is after `storage` struct field (see `bounded_vec.nr` in noir-stdlib)\n        let len = fields[<T as Deserialize>::N * M] as u32;\n\n        for i in 0..len {\n            let mut nested_fields = [0; <T as Deserialize>::N];\n            for j in 0..<T as Deserialize>::N {\n                nested_fields[j] = fields[i * <T as Deserialize>::N + j];\n            }\n\n            let item = T::deserialize(nested_fields);\n            new_bounded_vec.push(item);\n        }\n\n        new_bounded_vec\n    }\n}\n\n// This may cause issues if used as program input, because noir disallows empty arrays for program input.\n// I think this is okay because I don't foresee a unit type being used as input. But leaving this comment as a hint\n// if someone does run into this in the future.\nimpl Deserialize for () {\n    let N: u32 = 0;\n\n    fn deserialize(_fields: [Field; Self::N]) -> Self {\n        ()\n    }\n}\n\n// Note: Not deriving this because it's not supported to call derive_serialize on a \"remote\" struct (and it will never\n// be supported).\nimpl<T, let M: u32> Serialize for BoundedVec<T, M>\nwhere\n    T: Serialize,\n{\n    let N: u32 = <T as Serialize>::N * M + 1; // +1 for the length of the BoundedVec\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        let mut fields = [0; Self::N];\n\n        let storage = self.storage();\n\n        for i in 0..M {\n            let serialized_item = storage[i].serialize();\n\n            for j in 0..<T as Serialize>::N {\n                fields[i * <T as Serialize>::N + j] = serialized_item[j];\n            }\n        }\n\n        // Length is stored in the last field as we need to match intrinsic Noir serialization and the `len` struct\n        // field is after `storage` struct field (see `bounded_vec.nr` in noir-stdlib)\n        fields[<T as Serialize>::N * M] = self.len() as Field;\n\n        fields\n    }\n}\n\n// docs:start:deserialize\n/// Trait for deserializing Noir types from arrays of Fields.\n///\n/// An implementation of the Deserialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait is typically used when\n/// deserializing return values from function calls in Noir. Since the same function could be called from TypeScript\n/// (TS), in which case the TS deserialization would get used, we need to have a match between the 2.\n///\n/// # Associated Constants\n/// * `N` - The length of the input Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let M: u32> Deserialize for str<M> {\n///     let N: u32 = M;\n///\n///     #[inline_always]\n///     fn deserialize(fields: [Field; Self::N]) -> Self {\n///         str::<Self::N>::from(fields.map(|value| value as u8))\n///     }\n/// }\n/// ```\n#[derive_via(derive_deserialize)]\npub trait Deserialize {\n    let N: u32;\n\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl<let M: u32> Deserialize for str<M> {\n    let N: u32 = M;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        str::<Self::N>::from(fields.map(|value| value as u8))\n    }\n}\n\n/// Trait for efficiently packing and unpacking Noir types into and from arrays of Fields.\n///\n/// The `Packable` trait allows types to be serialized and deserialized with a focus on minimizing the size of\n/// the resulting Field array. This trait is used when storage efficiency is critical (e.g. when storing data\n/// in the contract's public storage).\n///\n/// # Associated Constants\n/// * `N` - The length of the Field array, known at compile time\n#[derive_via(derive_packable)]\npub trait Packable {\n    let N: u32;\n\n    /// Packs the current value into a compact array of `Field` elements.\n    fn pack(self) -> [Field; N];\n\n    /// Unpacks a compact array of `Field` elements into the original value.\n    fn unpack(fields: [Field; N]) -> Self;\n}\n\n#[test]\nunconstrained fn bounded_vec_serialization() {\n    // Test empty BoundedVec\n    let empty_vec: BoundedVec<Field, 3> = BoundedVec::from_array([]);\n    let serialized = empty_vec.serialize();\n    let deserialized = BoundedVec::<Field, 3>::deserialize(serialized);\n    assert_eq(empty_vec, deserialized);\n    assert_eq(deserialized.len(), 0);\n\n    // Test partially filled BoundedVec\n    let partial_vec: BoundedVec<[u32; 2], 3> = BoundedVec::from_array([[1, 2]]);\n    let serialized = partial_vec.serialize();\n    let deserialized = BoundedVec::<[u32; 2], 3>::deserialize(serialized);\n    assert_eq(partial_vec, deserialized);\n    assert_eq(deserialized.len(), 1);\n    assert_eq(deserialized.get(0), [1, 2]);\n\n    // Test full BoundedVec\n    let full_vec: BoundedVec<[u32; 2], 3> = BoundedVec::from_array([[1, 2], [3, 4], [5, 6]]);\n    let serialized = full_vec.serialize();\n    let deserialized = BoundedVec::<[u32; 2], 3>::deserialize(serialized);\n    assert_eq(full_vec, deserialized);\n    assert_eq(deserialized.len(), 3);\n    assert_eq(deserialized.get(0), [1, 2]);\n    assert_eq(deserialized.get(1), [3, 4]);\n    assert_eq(deserialized.get(2), [5, 6]);\n}\n","path":"/Users/zac/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.6-patch.1/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr"},"386":{"source":"use crate::traits::Packable;\n\nglobal BOOL_PACKED_LEN: u32 = 1;\nglobal U8_PACKED_LEN: u32 = 1;\nglobal U16_PACKED_LEN: u32 = 1;\nglobal U32_PACKED_LEN: u32 = 1;\nglobal U64_PACKED_LEN: u32 = 1;\nglobal U128_PACKED_LEN: u32 = 1;\nglobal FIELD_PACKED_LEN: u32 = 1;\nglobal I8_PACKED_LEN: u32 = 1;\nglobal I16_PACKED_LEN: u32 = 1;\nglobal I32_PACKED_LEN: u32 = 1;\nglobal I64_PACKED_LEN: u32 = 1;\n\nimpl Packable for bool {\n    let N: u32 = BOOL_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> bool {\n        (fields[0] as u1) != 0\n    }\n}\n\nimpl Packable for u8 {\n    let N: u32 = U8_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Packable for u16 {\n    let N: u32 = U16_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Packable for u32 {\n    let N: u32 = U32_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Packable for u64 {\n    let N: u32 = U64_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Packable for u128 {\n    let N: u32 = U128_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Packable for Field {\n    let N: u32 = FIELD_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Packable for i8 {\n    let N: u32 = I8_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as u8 as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u8 as i8\n    }\n}\n\nimpl Packable for i16 {\n    let N: u32 = I16_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as u16 as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u16 as i16\n    }\n}\n\nimpl Packable for i32 {\n    let N: u32 = I32_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as u32 as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u32 as i32\n    }\n}\n\nimpl Packable for i64 {\n    let N: u32 = I64_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as u64 as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u64 as i64\n    }\n}\n\nimpl<T, let M: u32> Packable for [T; M]\nwhere\n    T: Packable,\n{\n    let N: u32 = M * <T as Packable>::N;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        let mut result: [Field; Self::N] = std::mem::zeroed();\n        for i in 0..M {\n            let serialized = self[i].pack();\n            for j in 0..<T as Packable>::N {\n                result[i * <T as Packable>::N + j] = serialized[j];\n            }\n        }\n        result\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; M] = std::mem::zeroed();\n        reader.read_struct_array::<T, <T as Packable>::N, M>(Packable::unpack, result)\n    }\n}\n\n#[test]\nfn test_u16_packing() {\n    let a: u16 = 10;\n    assert_eq(a, u16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i8_packing() {\n    let a: i8 = -10;\n    assert_eq(a, i8::unpack(a.pack()));\n}\n\n#[test]\nfn test_i16_packing() {\n    let a: i16 = -10;\n    assert_eq(a, i16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i32_packing() {\n    let a: i32 = -10;\n    assert_eq(a, i32::unpack(a.pack()));\n}\n\n#[test]\nfn test_i64_packing() {\n    let a: i64 = -10;\n    assert_eq(a, i64::unpack(a.pack()));\n}\n","path":"/Users/zac/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.6-patch.1/noir-projects/noir-protocol-circuits/crates/types/src/type_packing.nr"},"387":{"source":"use crate::traits::{Deserialize, Serialize};\n\nglobal U1_SERIALIZED_LEN: u32 = 1;\nglobal BOOL_SERIALIZED_LEN: u32 = 1;\nglobal U8_SERIALIZED_LEN: u32 = 1;\nglobal U16_SERIALIZED_LEN: u32 = 1;\nglobal U32_SERIALIZED_LEN: u32 = 1;\nglobal U64_SERIALIZED_LEN: u32 = 1;\nglobal U128_SERIALIZED_LEN: u32 = 1;\nglobal FIELD_SERIALIZED_LEN: u32 = 1;\nglobal I8_SERIALIZED_LEN: u32 = 1;\nglobal I16_SERIALIZED_LEN: u32 = 1;\nglobal I32_SERIALIZED_LEN: u32 = 1;\nglobal I64_SERIALIZED_LEN: u32 = 1;\n\nimpl Serialize for bool {\n    let N: u32 = BOOL_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for bool {\n    let N: u32 = BOOL_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> bool {\n        fields[0] != 0\n    }\n}\n\nimpl Serialize for u1 {\n    let N: u32 = U1_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u1 {\n    let N: u32 = U1_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u1\n    }\n}\n\nimpl Serialize for u8 {\n    let N: u32 = U8_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u8 {\n    let N: u32 = U8_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize for u16 {\n    let N: u32 = U16_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u16 {\n    let N: u32 = U16_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Serialize for u32 {\n    let N: u32 = U32_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u32 {\n    let N: u32 = U32_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize for u64 {\n    let N: u32 = U64_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u64 {\n    let N: u32 = U64_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize for u128 {\n    let N: u32 = U128_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u128 {\n    let N: u32 = U128_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Serialize for Field {\n    let N: u32 = FIELD_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self]\n    }\n}\n\nimpl Deserialize for Field {\n    let N: u32 = FIELD_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Serialize for i8 {\n    let N: u32 = I8_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as u8 as Field]\n    }\n}\n\nimpl Deserialize for i8 {\n    let N: u32 = I8_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u8 as i8\n    }\n}\n\nimpl Serialize for i16 {\n    let N: u32 = I16_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as u16 as Field]\n    }\n}\n\nimpl Deserialize for i16 {\n    let N: u32 = I16_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u16 as i16\n    }\n}\n\nimpl Serialize for i32 {\n    let N: u32 = I32_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as u32 as Field]\n    }\n}\n\nimpl Deserialize for i32 {\n    let N: u32 = I32_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u32 as i32\n    }\n}\n\nimpl Serialize for i64 {\n    let N: u32 = I64_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as u64 as Field]\n    }\n}\n\nimpl Deserialize for i64 {\n    let N: u32 = I64_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u64 as i64\n    }\n}\n\nimpl<T, let M: u32> Serialize for [T; M]\nwhere\n    T: Serialize,\n{\n    let N: u32 = <T as Serialize>::N * M;\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        let mut result: [Field; _] = std::mem::zeroed();\n        for i in 0..M {\n            let serialized_t = self[i].serialize();\n            for j in 0..<T as Serialize>::N {\n                result[i * <T as Serialize>::N + j] = serialized_t[j];\n            }\n        }\n        result\n    }\n}\n\nimpl<T, let M: u32> Deserialize for [T; M]\nwhere\n    T: Deserialize,\n{\n    let N: u32 = <T as Deserialize>::N * M;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; M] = std::mem::zeroed();\n        reader.read_struct_array::<T, <T as Deserialize>::N, M>(Deserialize::deserialize, result)\n    }\n}\n\nimpl<T> Serialize for Option<T>\nwhere\n    T: Serialize,\n{\n    let N: u32 = <T as Serialize>::N + 1;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        let mut result: [Field; Self::N] = std::mem::zeroed();\n\n        result[0] = if self.is_some() { 1 } else { 0 };\n\n        let value_serialized = self.unwrap_unchecked().serialize();\n        for i in 0..<T as Serialize>::N {\n            result[1 + i] = value_serialized[i];\n        }\n\n        result\n    }\n}\n\nimpl<T> Deserialize for Option<T>\nwhere\n    T: Deserialize,\n{\n    let N: u32 = <T as Deserialize>::N + 1;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        if fields[0] == 1 {\n            let mut value_fields = [0; <T as Deserialize>::N];\n            for i in 0..<T as Deserialize>::N {\n                value_fields[i] = fields[1 + i];\n            }\n\n            Option::some(T::deserialize(value_fields))\n        } else {\n            Option::none()\n        }\n    }\n}\n\nmod test {\n    use crate::traits::{Deserialize, Serialize};\n\n    #[test]\n    fn u16_serialization() {\n        let a: u16 = 10;\n        assert_eq(a, u16::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i8_serialization() {\n        let a: i8 = -10;\n        assert_eq(a, i8::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i16_serialization() {\n        let a: i16 = -10;\n        assert_eq(a, i16::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i32_serialization() {\n        let a: i32 = -10;\n        assert_eq(a, i32::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i64_serialization() {\n        let a: i64 = -10;\n        assert_eq(a, i64::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn option_field_serialization() {\n        let opt_some = Option::some(5);\n        assert_eq(Option::<_>::deserialize(opt_some.serialize()), opt_some);\n\n        let opt_none = Option::none();\n        assert_eq(Option::<Field>::deserialize(opt_none.serialize()), opt_none);\n    }\n\n    #[test]\n    fn array_serialization() {\n        let array = [1, 2, 3, 4];\n\n        let serialized: [Field; 4] = array.serialize();\n        let deserialized: [Field; 4] = Deserialize::deserialize(serialized);\n        assert_eq(deserialized, array);\n    }\n\n    #[test]\n    fn nested_array_serialization() {\n        let nested_array = [[1, 2, 3, 4], [5, 6, 7, 8]];\n\n        let serialized: [Field; 8] = nested_array.serialize();\n        let deserialized: [[Field; 4]; 2] = Deserialize::deserialize(serialized);\n\n        assert_eq(deserialized, nested_array);\n    }\n\n    #[test]\n    fn option_array_serialization() {\n        let opt_some = Option::some([2, 5]);\n        assert_eq(Option::<_>::deserialize(opt_some.serialize()), opt_some);\n\n        let opt_none = Option::none();\n        assert_eq(Option::<Field>::deserialize(opt_none.serialize()), opt_none);\n    }\n}\n","path":"/Users/zac/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.6-patch.1/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr"},"392":{"source":"global KNOWN_NON_RESIDUE: Field = 5; // This is a non-residue in Noir's native Field.\n\npub fn field_from_bytes<let N: u32>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}\n\n// Convert a 32 byte array to a field element by truncating the final byte\npub fn field_from_bytes_32_trunc(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..15 {\n        // covers bytes 16..30 (31 is truncated and ignored)\n        low = low + (bytes32[15 + 15 - i] as Field) * v;\n        v = v * 256;\n        // covers bytes 0..14\n        high = high + (bytes32[14 - i] as Field) * v;\n    }\n    // covers byte 15\n    low = low + (bytes32[15] as Field) * v;\n\n    low + high * v\n}\n\n// TODO to radix returns u8, so we cannot use bigger radixes. It'd be ideal to use a radix of the maximum range-constrained integer noir supports\npub fn full_field_less_than(lhs: Field, rhs: Field) -> bool {\n    lhs.lt(rhs)\n}\n\npub fn full_field_greater_than(lhs: Field, rhs: Field) -> bool {\n    rhs.lt(lhs)\n}\n\npub fn min(f1: Field, f2: Field) -> Field {\n    if f1.lt(f2) {\n        f1\n    } else {\n        f2\n    }\n}\n\nglobal C1: u32 = 28;\nglobal C3: Field = 40770029410420498293352137776570907027550720424234931066070132305055;\nglobal C5: Field = 19103219067921713944291392827692070036145651957329286315305642004821462161904;\n\npub fn pow(x: Field, y: Field) -> Field {\n    let mut r = 1 as Field;\n    let b: [u1; 254] = y.to_le_bits();\n\n    for i in 0..254 {\n        r *= r;\n        r *= (b[254 - 1 - i] as Field) * x + (1 - b[254 - 1 - i] as Field);\n    }\n\n    r\n}\n\n/// Returns Option::some(sqrt) if there is a square root, and Option::none() if there isn't.\npub fn sqrt(x: Field) -> Option<Field> {\n    // Safety: if the hint returns the square root of x, then we simply square it\n    // check the result equals x. If x is not square, we return a value that\n    // enables us to prove that fact (see the `else` clause below).\n    let (is_sq, maybe_sqrt) = unsafe { __sqrt(x) };\n\n    if is_sq {\n        let sqrt = maybe_sqrt;\n        validate_sqrt_hint(x, sqrt);\n        Option::some(sqrt)\n    } else {\n        let not_sqrt_hint = maybe_sqrt;\n        validate_not_sqrt_hint(x, not_sqrt_hint);\n        Option::none()\n    }\n}\n\n// Boolean indicating whether Field element is a square, i.e. whether there exists a y in Field s.t. x = y*y.\nunconstrained fn is_square(x: Field) -> bool {\n    let v = pow(x, -1 / 2);\n    v * (v - 1) == 0\n}\n\n// Tonelli-Shanks algorithm for computing the square root of a Field element.\n// Requires C1 = max{c: 2^c divides (p-1)}, where p is the order of Field\n// as well as C3 = (C2 - 1)/2, where C2 = (p-1)/(2^c1),\n// and C5 = ZETA^C2, where ZETA is a non-square element of Field.\n// These are pre-computed above as globals.\nunconstrained fn tonelli_shanks_sqrt(x: Field) -> Field {\n    let mut z = pow(x, C3);\n    let mut t = z * z * x;\n    z *= x;\n    let mut b = t;\n    let mut c = C5;\n\n    for i in 0..(C1 - 1) {\n        for _j in 1..(C1 - i - 1) {\n            b *= b;\n        }\n\n        z *= if b == 1 { 1 } else { c };\n\n        c *= c;\n\n        t *= if b == 1 { 1 } else { c };\n\n        b = t;\n    }\n\n    z\n}\n\n// NB: this doesn't return an option, because in the case of there _not_ being a square root, we still want to return a field element that allows us to then assert in the _constrained_ sqrt function that there is no sqrt.\nunconstrained fn __sqrt(x: Field) -> (bool, Field) {\n    let is_sq = is_square(x);\n    if is_sq {\n        let sqrt = tonelli_shanks_sqrt(x);\n        (true, sqrt)\n    } else {\n        // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n        // Facts:\n        // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n        // - If x is a square, LS(x) = 1\n        // - If x is not a square, LS(x) = -1\n        // - If x = 0, LS(x) = 0.\n        //\n        // Hence:\n        // sq * sq = sq // 1 * 1 = 1\n        // non-sq * non-sq = sq // -1 * -1 = 1\n        // sq * non-sq = non-sq // -1 * 1 = -1\n        //\n        // See: https://en.wikipedia.org/wiki/Legendre_symbol\n        let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n        let not_sqrt = tonelli_shanks_sqrt(demo_x_not_square);\n        (false, not_sqrt)\n    }\n}\n\nfn validate_sqrt_hint(x: Field, hint: Field) {\n    assert(hint * hint == x, f\"The claimed_sqrt {hint} is not the sqrt of x {x}\");\n}\n\nfn validate_not_sqrt_hint(x: Field, hint: Field) {\n    // We need this assertion, because x = 0 would pass the other assertions in this\n    // function, and we don't want people to be able to prove that 0 is not square!\n    assert(x != 0, \"0 has a square root; you cannot claim it is not square\");\n    // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n    //\n    // Facts:\n    // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n    // - If x is a square, LS(x) = 1\n    // - If x is not a square, LS(x) = -1\n    // - If x = 0, LS(x) = 0.\n    //\n    // Hence:\n    // 1. sq * sq = sq // 1 * 1 = 1\n    // 2. non-sq * non-sq = sq // -1 * -1 = 1\n    // 3. sq * non-sq = non-sq // -1 * 1 = -1\n    //\n    // See: https://en.wikipedia.org/wiki/Legendre_symbol\n    //\n    // We want to demonstrate that this below multiplication falls under bullet-point (2):\n    let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n    // I.e. we want to demonstrate that `demo_x_not_square` has Legendre symbol 1\n    // (i.e. that it is a square), so we prove that it is square below.\n    // Why do we want to prove that it has LS 1?\n    // Well, since it was computed with a known-non-residue, its squareness implies we're\n    // in case 2 (something multiplied by a known-non-residue yielding a result which\n    // has a LS of 1), which implies that x must be a non-square. The unconstrained\n    // function gave us the sqrt of demo_x_not_square, so all we need to do is\n    // assert its squareness:\n    assert(\n        hint * hint == demo_x_not_square,\n        f\"The hint {hint} does not demonstrate that {x} is not a square\",\n    );\n}\n\n#[test]\nunconstrained fn bytes_field_test() {\n    // Tests correctness of field_from_bytes_32_trunc against existing methods\n    // Bytes representing 0x543e0a6642ffeb8039296861765a53407bba62bd1c97ca43374de950bbe0a7\n    let inputs = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167,\n    ];\n    let field = field_from_bytes(inputs, true);\n    let return_bytes: [u8; 31] = field.to_be_bytes();\n    assert_eq(inputs, return_bytes);\n    // 32 bytes - we remove the final byte, and check it matches the field\n    let inputs2 = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167, 158,\n    ];\n    let field2 = field_from_bytes_32_trunc(inputs2);\n    let return_bytes2: [u8; 31] = field.to_be_bytes();\n\n    assert_eq(return_bytes2, return_bytes);\n    assert_eq(field2, field);\n}\n\n#[test]\nunconstrained fn max_field_test() {\n    // Tests the hardcoded value in constants.nr vs underlying modulus\n    // NB: We can't use 0-1 in constants.nr as it will be transpiled incorrectly to ts and sol constants files\n    let max_value = crate::constants::MAX_FIELD_VALUE;\n    assert_eq(max_value, 0 - 1);\n    // modulus == 0 is tested elsewhere, so below is more of a sanity check\n    let max_bytes: [u8; 32] = max_value.to_be_bytes();\n    let mod_bytes = std::field::modulus_be_bytes();\n    for i in 0..31 {\n        assert_eq(max_bytes[i], mod_bytes[i]);\n    }\n    assert_eq(max_bytes[31], mod_bytes[31] - 1);\n}\n\n#[test]\nunconstrained fn sqrt_valid_test() {\n    let x = 16; // examples: 16, 9, 25, 81\n    let result = sqrt(x);\n    assert(result.is_some());\n    assert_eq(result.unwrap() * result.unwrap(), x);\n}\n\n#[test]\nunconstrained fn sqrt_invalid_test() {\n    let x = KNOWN_NON_RESIDUE; // has no square root in the field\n    let result = sqrt(x);\n    assert(result.is_none());\n}\n","path":"/Users/zac/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.6-patch.1/noir-projects/noir-protocol-circuits/crates/types/src/utils/field.nr"},"396":{"source":"pub struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_u64(&mut self) -> u64 {\n        self.read() as u64\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() != 0\n    }\n\n    pub fn read_array<let K: u32>(&mut self) -> [Field; K] {\n        let mut result = [0; K];\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array());\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(\n        &mut self,\n        deserialise: fn([Field; K]) -> T,\n        mut result: [T; C],\n    ) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert_eq(self.offset, self.data.len(), \"Reader did not read all data\");\n    }\n}\n","path":"/Users/zac/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.6-patch.1/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr"},"481":{"source":"use aztec::macros::aztec;\n\n// ============ Hat Type Constants ============\n// Based on ELO delta (loser_elo - winner_elo)\n// Positive = underdog victory (impressive), Negative = expected win (less impressive)\nglobal HAT_CROWN: u8 = 0;         // delta > +200 (major upset)\nglobal HAT_LAUREL_WREATH: u8 = 1; // delta +100 to +200 (underdog victory)\nglobal HAT_WIZARD_HAT: u8 = 2;    // delta -100 to +100 (fair match)\nglobal HAT_TOP_HAT: u8 = 3;       // delta -200 to -100 (slight favorite)\nglobal HAT_BOWLER_HAT: u8 = 4;    // delta -300 to -200 (clear favorite)\nglobal HAT_BASEBALL_CAP: u8 = 5;  // delta -400 to -300 (strong favorite)\nglobal HAT_DUNCE_CAP: u8 = 6;     // delta < -400 (crushing weaker opponent)\n\n// ============ Quality Constants ============\n// Based on winner's ELO rating\nglobal QUALITY_TATTERED: u8 = 0;  // ELO < 800\nglobal QUALITY_SHODDY: u8 = 1;    // ELO 800-1000\nglobal QUALITY_PLAIN: u8 = 2;     // ELO 1000-1200\nglobal QUALITY_FINE: u8 = 3;      // ELO 1200-1400\nglobal QUALITY_ELEGANT: u8 = 4;   // ELO 1400-1600\nglobal QUALITY_MAJESTIC: u8 = 5;  // ELO 1600-1800\nglobal QUALITY_LEGENDARY: u8 = 6; // ELO 1800-2000\nglobal QUALITY_MYTHIC: u8 = 7;    // ELO 2000+\n\n/// Compute hat type from ELO delta (loser_elo - winner_elo)\n/// Positive delta = underdog victory = more impressive hat\n/// Negative delta = expected win = less impressive hat\npub fn compute_hat_type(winner_elo: u32, loser_elo: u32) -> u8 {\n    let delta: i32 = loser_elo as i32 - winner_elo as i32;\n\n    if delta > 200 {\n        HAT_CROWN\n    } else if delta > 100 {\n        HAT_LAUREL_WREATH\n    } else if delta >= -100 {\n        HAT_WIZARD_HAT\n    } else if delta >= -200 {\n        HAT_TOP_HAT\n    } else if delta >= -300 {\n        HAT_BOWLER_HAT\n    } else if delta >= -400 {\n        HAT_BASEBALL_CAP\n    } else {\n        HAT_DUNCE_CAP\n    }\n}\n\n/// Compute hat quality from winner's ELO rating\npub fn compute_hat_quality(winner_elo: u32) -> u8 {\n    if winner_elo >= 2000 {\n        QUALITY_MYTHIC\n    } else if winner_elo >= 1800 {\n        QUALITY_LEGENDARY\n    } else if winner_elo >= 1600 {\n        QUALITY_MAJESTIC\n    } else if winner_elo >= 1400 {\n        QUALITY_ELEGANT\n    } else if winner_elo >= 1200 {\n        QUALITY_FINE\n    } else if winner_elo >= 1000 {\n        QUALITY_PLAIN\n    } else if winner_elo >= 800 {\n        QUALITY_SHODDY\n    } else {\n        QUALITY_TATTERED\n    }\n}\n\n#[aztec]\npub contract HatNFT {\n    use aztec::{\n        macros::{events::event, functions::{external, initializer}, storage::storage},\n        protocol_types::address::AztecAddress,\n        state_vars::{Map, public_mutable::PublicMutable},\n    };\n    use crate::{compute_hat_type, compute_hat_quality};\n\n    /// Emitted when a new hat NFT is minted\n    #[event]\n    struct HatMinted {\n        token_id: u32,\n        owner: AztecAddress,\n        game_id: u32,\n        hat_type: u8,\n        hat_quality: u8,\n    }\n\n    /// Emitted when a hat NFT is transferred\n    #[event]\n    struct HatTransferred {\n        token_id: u32,\n        from: AztecAddress,\n        to: AztecAddress,\n    }\n\n    #[storage]\n    struct Storage<Context> {\n        /// Auto-incrementing token ID counter\n        token_counter: PublicMutable<u32, Context>,\n        /// Map from token_id to owner address\n        public_owners: Map<u32, PublicMutable<AztecAddress, Context>, Context>,\n        /// Map from token_id to existence flag\n        nft_exists: Map<u32, PublicMutable<bool, Context>, Context>,\n        /// Map from token_id to game_id\n        hat_game_ids: Map<u32, PublicMutable<u32, Context>, Context>,\n        /// Map from token_id to hat type (0-6, see HAT_* constants)\n        hat_types: Map<u32, PublicMutable<u8, Context>, Context>,\n        /// Map from token_id to hat quality (0-7, see QUALITY_* constants)\n        hat_qualities: Map<u32, PublicMutable<u8, Context>, Context>,\n        /// Authorized minter (chess contract address) - set once in constructor\n        minter: PublicMutable<AztecAddress, Context>,\n    }\n\n    #[initializer]\n    #[external(\"public\")]\n    fn constructor(chess_contract: AztecAddress) {\n        assert(chess_contract != AztecAddress::zero(), \"Minter cannot be zero address\");\n        self.storage.minter.write(chess_contract);\n        self.storage.token_counter.write(0);\n    }\n\n    /// Mint a new hat NFT to the winner. Only callable by the authorized minter (chess contract).\n    #[external(\"public\")]\n    fn mint_hat(to: AztecAddress, game_id: u32, winner_elo: u32, loser_elo: u32) {\n        // Only the authorized minter can call this\n        let minter = self.storage.minter.read();\n        let caller = self.context.msg_sender().expect(f\"msg_sender must be set\");\n        assert(caller == minter, \"Only minter can mint\");\n        assert(to != AztecAddress::zero(), \"Cannot mint to zero address\");\n\n        // Get next token ID\n        let token_id = self.storage.token_counter.read();\n\n        // Compute hat attributes from ELO ratings\n        let hat_type = compute_hat_type(winner_elo, loser_elo);\n        let hat_quality = compute_hat_quality(winner_elo);\n\n        // Store NFT data\n        self.storage.public_owners.at(token_id).write(to);\n        self.storage.nft_exists.at(token_id).write(true);\n        self.storage.hat_game_ids.at(token_id).write(game_id);\n        self.storage.hat_types.at(token_id).write(hat_type);\n        self.storage.hat_qualities.at(token_id).write(hat_quality);\n\n        // Increment counter\n        self.storage.token_counter.write(token_id + 1);\n\n        // Emit event\n        self.emit(HatMinted {\n            token_id,\n            owner: to,\n            game_id,\n            hat_type,\n            hat_quality,\n        });\n    }\n\n    /// Transfer a hat NFT from one address to another. Caller must be the current owner.\n    #[external(\"public\")]\n    fn transfer(from: AztecAddress, to: AztecAddress, token_id: u32) {\n        // Check token exists\n        let exists = self.storage.nft_exists.at(token_id).read();\n        assert(exists, \"Token does not exist\");\n\n        // Check caller is the owner\n        let owner = self.storage.public_owners.at(token_id).read();\n        assert(owner == from, \"From address is not the owner\");\n        let caller = self.context.msg_sender().expect(f\"msg_sender must be set\");\n        assert(caller == from, \"Only owner can transfer\");\n        assert(to != AztecAddress::zero(), \"Cannot transfer to zero address\");\n\n        // Update owner\n        self.storage.public_owners.at(token_id).write(to);\n\n        // Emit event\n        self.emit(HatTransferred { token_id, from, to });\n    }\n\n    /// Get the owner of a token\n    #[external(\"utility\")]\n    unconstrained fn owner_of(token_id: u32) -> AztecAddress {\n        let exists = self.storage.nft_exists.at(token_id).read();\n        assert(exists, \"Token does not exist\");\n        self.storage.public_owners.at(token_id).read()\n    }\n\n    /// Get metadata for a hat NFT\n    /// Returns (game_id, hat_type, hat_quality)\n    /// Hat types: 0=Crown, 1=Laurel Wreath, 2=Wizard Hat, 3=Top Hat, 4=Bowler Hat, 5=Baseball Cap, 6=Dunce Cap\n    /// Qualities: 0=Tattered, 1=Shoddy, 2=Plain, 3=Fine, 4=Elegant, 5=Majestic, 6=Legendary, 7=Mythic\n    #[external(\"utility\")]\n    unconstrained fn get_hat_metadata(token_id: u32) -> (u32, u8, u8) {\n        let exists = self.storage.nft_exists.at(token_id).read();\n        assert(exists, \"Token does not exist\");\n\n        let game_id = self.storage.hat_game_ids.at(token_id).read();\n        let hat_type = self.storage.hat_types.at(token_id).read();\n        let hat_quality = self.storage.hat_qualities.at(token_id).read();\n\n        (game_id, hat_type, hat_quality)\n    }\n\n    /// Get total number of minted tokens\n    #[external(\"utility\")]\n    unconstrained fn total_supply() -> u32 {\n        self.storage.token_counter.read()\n    }\n\n    /// Get the authorized minter address\n    #[external(\"utility\")]\n    unconstrained fn get_minter() -> AztecAddress {\n        self.storage.minter.read()\n    }\n\n    /// Check if a token exists\n    #[external(\"utility\")]\n    unconstrained fn exists(token_id: u32) -> bool {\n        self.storage.nft_exists.at(token_id).read()\n    }\n}\n","path":"/Users/zac/aztec-chess-stable/contracts/hat_nft/src/main.nr"}}}